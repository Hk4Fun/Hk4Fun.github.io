<!DOCTYPE html>
<html >
<head>

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no" />
<meta name="author" content="Hk4Fun" />
<!--prettify代码高亮主题css引入-->
<link href="/plugins/prettify/prettify.css" rel="stylesheet">


<meta name="description" content="每个题目标题链接到 github，可以查看其他的解题思路、测试用例以及拓展题目 这里只贴上书中题目的最优解法和代码 另外，这里参考的是剑指offer第一版的题目顺序 补充部分添加的是剑指offer第二版多出来的几道题目">
<meta name="keywords" content="剑指offer,算法,数据结构">
<meta property="og:type" content="article">
<meta property="og:title" content="剑指offer题解（Python实现）">
<meta property="og:url" content="https://hk4fun.github.io/2019/01/31/剑指offer题解（Python实现）/index.html">
<meta property="og:site_name" content="Hk4Fun&#39;s Blog">
<meta property="og:description" content="每个题目标题链接到 github，可以查看其他的解题思路、测试用例以及拓展题目 这里只贴上书中题目的最优解法和代码 另外，这里参考的是剑指offer第一版的题目顺序 补充部分添加的是剑指offer第二版多出来的几道题目">
<meta property="og:image" content="https://ws1.sinaimg.cn/large/006giLD5ly1fwx65siwcwj30h103bjr8.jpg">
<meta property="og:image" content="https://ws1.sinaimg.cn/large/006giLD5ly1fwx66yx85wj302s03dmwx.jpg">
<meta property="og:updated_time" content="2019-02-03T05:05:19.212Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="剑指offer题解（Python实现）">
<meta name="twitter:description" content="每个题目标题链接到 github，可以查看其他的解题思路、测试用例以及拓展题目 这里只贴上书中题目的最优解法和代码 另外，这里参考的是剑指offer第一版的题目顺序 补充部分添加的是剑指offer第二版多出来的几道题目">
<meta name="twitter:image" content="https://ws1.sinaimg.cn/large/006giLD5ly1fwx65siwcwj30h103bjr8.jpg">

<link rel="apple-touch-icon" href= "/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="Hk4Fun&#39;s Blog" type="application/atom+xml">



    <link rel="shortcut icon" href="/img/blog.jpg">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">



<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>剑指offer题解（Python实现） | Hk4Fun&#39;s Blog</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: false,
        isPost: true,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: true
    }
</script>


    <script>
        yiliaConfig.jquery_ui = [true, "//cdn.bootcss.com/jqueryui/1.10.4/jquery-ui.min.js", "//cdn.bootcss.com/jqueryui/1.10.4/css/jquery-ui.min.css"];
    </script>



    <script> yiliaConfig.rootUrl = "\/";</script>



    <script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-59ce63134e828feb"></script>



    <script>
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?7e01cbfd0c4fd52d389e022356692311";
            var s = document.getElementsByTagName("script")[0]; 
            s.parentNode.insertBefore(hm, s);
        })();
    </script>


</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/blog.jpg" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">Hk4Fun</a></h1>
        </hgroup>

        
        <p class="header-subtitle">人是不能闲太久的</p>
        <p class="header-subtitle">闲久了，努力一下就以为在拼命</p>
        

        
            <form id="search-form">
            <input type="text" id="local-search-input" name="q" placeholder="search..." class="search form-control" autocomplete="off" autocorrect="off" searchonload="true" />
            <i class="fa fa-times" onclick="resetSearch()"></i>
            </form>
            <div id="local-search-result"></div>
            <p class='no-result'>No results found <i class='fa fa-spinner fa-pulse'></i></p>
        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">ABOUT ME</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa GitHub" href="https://github.com/Hk4Fun" title="GitHub"></a>
                            
                                <a class="fa 知乎" href="https://www.zhihu.com/people/Hk4Fun/activities" title="知乎"></a>
                            
                                <a class="fa 微信" href="http://ox186n2j0.bkt.clouddn.com/wexinhaoyou.jpg" title="微信"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CPython/">CPython</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Django/">Django</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ORM/">ORM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PEP/">PEP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web/">Web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/coroutine/">coroutine</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/wtfpython/">wtfpython</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/元类编程/">元类编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/剑指offer/">剑指offer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构/">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/源码剖析/">源码剖析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/环境搭建/">环境搭建</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/魔法方法/">魔法方法</a></li></ul>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" href="https://hexo.io">Hexo</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://pages.github.com/">GitHub</a>
                    
                      <a class="main-nav-link switch-friends-link" href="http://moxfive.xyz/">MOxFIVE</a>
                    
                    </div>
                </section>
                

                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">Hk4Fun</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/blog.jpg" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">Hk4Fun</a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">ABOUT ME</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa GitHub" target="_blank" href="https://github.com/Hk4Fun" title="GitHub"></a>
                            
                                <a class="fa 知乎" target="_blank" href="https://www.zhihu.com/people/Hk4Fun/activities" title="知乎"></a>
                            
                                <a class="fa 微信" target="_blank" href="http://ox186n2j0.bkt.clouddn.com/wexinhaoyou.jpg" title="微信"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap"><article id="post-剑指offer题解（Python实现）" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/01/31/剑指offer题解（Python实现）/" class="article-date">
      <time datetime="2019-01-31T10:11:06.000Z" itemprop="datePublished">2019-01-31</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      剑指offer题解（Python实现）
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        

        
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/剑指offer/">剑指offer</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据结构/">数据结构</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法/">算法</a></li></ul>
    </div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>每个题目标题链接到 <a href="https://github.com/Hk4Fun/algorithm_offer/tree/master/target_offer" target="_blank" rel="external">github</a>，可以查看其他的解题思路、测试用例以及拓展题目</p>
<p>这里只贴上书中题目的最优解法和代码</p>
<p>另外，这里参考的是剑指offer第一版的题目顺序</p>
<p>补充部分添加的是剑指offer第二版多出来的几道题目</p>
<a id="more"></a>
<h2 id="二维数组中的查找"><a href="#二维数组中的查找" class="headerlink" title=" 二维数组中的查找"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/3_1_%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE.py" target="_blank" rel="external"> 二维数组中的查找</a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。<br>请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<h3 id="最优题解"><a href="#最优题解" class="headerlink" title="最优题解"></a>最优题解</h3><p>时间（O（m+n）），空间（O（1））</p>
<p>从右上角或左下角开始查找，这里选择右上角<br>如果当前元素大于target, 剔除target所在列（col左移-1）<br>如果当前元素小于target, 剔除target所在行（row下移+1）<br>否则等于，结束查找<br>每一次查找都在数组的查找范围中剔除一行或一列，每一步都缩小了查找的范围<br>直到找到要查找的数字，或者查找范围为空</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="python">class Solution:
    def Find(self, target, array):
        if array is None: return False
        i , j = 0, len(array[0]) - 1
        while i &lt; len(array) and j &gt;= 0:
            if array[i][j] &gt; target:
                j -= 1
            elif array[i][j] &lt; target:
                i += 1
            else: 
                return True
        return False
</code></pre>
<h3 id="拓展题目"><a href="#拓展题目" class="headerlink" title="拓展题目"></a>拓展题目</h3><ul>
<li><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/3_2_%E6%8E%92%E5%BA%8F%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E4%BB%8E%E5%B0%8F%E5%88%B0%E5%A4%A7%E7%AC%ACk%E4%B8%AA%E6%95%B0.py" target="_blank" rel="external">排序矩阵中从小到大第k个数</a></li>
</ul>
<h2 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/4_%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC.py" target="_blank" rel="external">替换空格</a></h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>请实现一个函数，将一个字符串中的空格替换成“%20”。<br>例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>
<h3 id="最优题解-1"><a href="#最优题解-1" class="headerlink" title="最优题解"></a>最优题解</h3><p>使用内置方法replace最佳，这里给出书上的解法：</p>
<p>原地替换，需要移动替换位置之后的字符，若从左到右扫描，一边移动一边替换，时间复杂度为O（n^2）</p>
<p>可以考虑从右到左扫描，使用两个索引，一个指向源字符串的末尾oldIdx，另一个指向替换后字符串的末尾newIdx， 没碰到空格时直接复制，碰到空格时newIdx左移3格写入‘20%’，oldIdx左移一格（每替换一个空格，长度增加2，因此替换后字符串的长度=原来长度+2*空格数目），直到newIdx越过oldIdx来到oldIdx的左边则扫描结束</p>
<p>注：如果是c/c++可以实现原地替换，但python中的str为不可变对象，只能返回新的字符串，所以这里的原地替换只是模拟书中的方法，实际上还是返回一个新的字符串</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre><code class="python">class Solution:
    def replaceSpace(self, s):
        if s is None: return &#39;&#39;
        spaceCount = sum(ch == &#39; &#39; for ch in s)
        newIdx = len(s) + spaceCount * 2 - 1
        oldIdx = len(s) - 1
        newStr = list(s) + [&#39;&#39;] * (spaceCount * 2)
        while 0 &lt;= oldIdx &lt; newIdx:
            if newStr[oldIdx] == &#39; &#39;:
                newStr[newIdx - 2: newIdx + 1] = &#39;%20&#39;
                newIdx -= 3
            else:
                newStr[newIdx] = newStr[oldIdx]
                newIdx -= 1
            oldIdx -= 1
        return &#39;&#39;.join(newStr)
</code></pre>
<h2 id="从尾到头打印链表"><a href="#从尾到头打印链表" class="headerlink" title="从尾到头打印链表"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/5_%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8.py" target="_blank" rel="external">从尾到头打印链表</a></h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个链表，从尾到头打印链表每个节点的值（不能改变原链表结构）</p>
<h3 id="最优题解-2"><a href="#最优题解-2" class="headerlink" title="最优题解"></a>最优题解</h3><p>时间（O（n）），空间（O（n））</p>
<p>可以自己用list模拟栈，也可以使用递归借助系统栈，这里使用递归实现</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><pre><code class="python">class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None

class Solution:
    # 返回从尾部到头部的列表值序列
    def ListReverse(self, listNode):
        def recursive(node):
            if node:
                recursive(node.next)
                res.append(node.val)

        res = []
        recursive(listNode)
        return res
</code></pre>
<h2 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/6_1_%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E5%89%8D%E5%BA%8F%E4%B8%AD%E5%BA%8F%EF%BC%89.py" target="_blank" rel="external">重建二叉树</a></h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。<br>假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p>
<h3 id="最优题解-3"><a href="#最优题解-3" class="headerlink" title="最优题解"></a>最优题解</h3><p>前序的第一个元素是根结点的值，在中序中找到该值，<br>中序中该值的左边的元素是根结点的左子树，右边是右子树，然后递归的处理左边和右边</p>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><pre><code class="python">class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution:
    # 返回构造的TreeNode根节点
    def reConstructBinaryTree(self, pre, tin):
        def build(preL, preR, tinL, tinR):
            if preL &gt; preR or tinL &gt; tinR: return
            idx = tin.index(pre[preL])
            node = TreeNode(pre[preL])
            node.left = build(preL+1, idx + preL - tinL, tinL, idx - 1)
            node.right = build(idx + preL - tinL + 1, preR, idx + 1, tinR)
            return node

        return build(0, len(pre)-1, 0, len(tin) - 1)
</code></pre>
<h3 id="举一反三"><a href="#举一反三" class="headerlink" title="举一反三"></a>举一反三</h3><ul>
<li><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/6_2_%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E4%B8%AD%E5%BA%8F%E5%90%8E%E5%BA%8F%EF%BC%89.py" target="_blank" rel="external">重建二叉树（中序后序）</a></li>
</ul>
<h2 id="用两个栈实现队列"><a href="#用两个栈实现队列" class="headerlink" title="用两个栈实现队列"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/7_1_%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97.py" target="_blank" rel="external">用两个栈实现队列</a></h2><h3 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h3><p>用两个栈来实现一个队列，完成队列的入队和出队操作</p>
<h3 id="最优题解-4"><a href="#最优题解-4" class="headerlink" title="最优题解"></a>最优题解</h3><p>stack1用来入队，stack2用来出队<br>出队时若stack2有数据直接弹出，无数据就要把stack1中的全部弹出并压入stack2，然后stack2继续出队<br>入队时不管stack1有没有数据，直接压入</p>
<h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><pre><code class="python">class Solution:
    def __init__(self):
        self.stack1 = []
        self.stack2 = []

    def In(self, x):  # 入队时不管stack1有没有数据，直接压入
        self.stack1.append(x)

    def Out(self):
        if not self.stack1 and not self.stack2:
            return
        if not self.stack2:  # stack2无数据就要把stack1中的全部弹出并压入stack2
            while self.stack1:
                self.stack2.append(self.stack1.pop())
        return self.stack2.pop()  # stack2继续出队
</code></pre>
<h3 id="举一反三-1"><a href="#举一反三-1" class="headerlink" title="举一反三"></a>举一反三</h3><ul>
<li><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/7_2_%E7%94%A8%E4%B8%A4%E4%B8%AA%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88.py" target="_blank" rel="external">用两个队列实现栈</a></li>
</ul>
<h2 id="旋转数组的最小数字"><a href="#旋转数组的最小数字" class="headerlink" title="旋转数组的最小数字"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/8_%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97.py" target="_blank" rel="external">旋转数组的最小数字</a></h2><h3 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h3><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。<br>输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。<br>例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。</p>
<h3 id="最优题解-5"><a href="#最优题解-5" class="headerlink" title="最优题解"></a>最优题解</h3><p>部分排序，则可用二分查找，注意在等于的时候让high-1，顺序查找，退化成O(n)<br>（注意到[1,0,1,1,1]和[1,1,1,0,1]的区别，此时无法判断最小值在哪边，故只能用顺序查找）：</p>
<ul>
<li>array[mid] &gt; array[high]</li>
</ul>
<p>出现这种情况的array类似[3,4,5,6,0,1,2]，<br>此时最小数字一定在mid的右边<br>low = mid + 1</p>
<ul>
<li>array[mid] == array[high]</li>
</ul>
<p>出现这种情况的array类似 [1,0,1,1,1] 或者[1,1,1,0,1]，<br>此时最小数字不好判断在mid左边还是右边,这时只好一个一个试<br>high = high - 1</p>
<ul>
<li>array[mid] &lt; array[high]</li>
</ul>
<p>出现这种情况的array类似[2,2,3,4,5,6,6]，<br>此时最小数字一定就是array[mid]或者在mid的左边，因为右边必然都是递增的<br>若 mid = 0 ,说明low与high之间未发生旋转，最小数字就是array[mid]，<br>或者array[mid-1]&gt;array[mid]，则最小数字也是array[mid]<br>否则mid不为零且array[mid-1]&lt;=array[mid]，最小数字在mid的左边，high = mid - 1</p>
<h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><pre><code class="python">class Solution:
    def minNumber(self, rotateArray):
        if not rotateArray: return 0
        l, r = 0, len(rotateArray) - 1
        while l &lt;= r:
            m = l + ((r - l) &gt;&gt; 1)
            if rotateArray[m] &gt; rotateArray[-1]:
                l = m + 1
            elif rotateArray[m] &lt; rotateArray[-1]:
                if m == 0 or rotateArray[m - 1] &gt; rotateArray[m]:
                    return rotateArray[m]
                else:
                    r = m - 1
            else:
                r -= 1
</code></pre>
<h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/9_1_%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97.py" target="_blank" rel="external">斐波那契数列</a></h2><h3 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个整数n，输出斐波那契数列的第n项f(n)（n从0开始，f(0)=0，f(1)=1）</p>
<h3 id="最优题解-6"><a href="#最优题解-6" class="headerlink" title="最优题解"></a>最优题解</h3><p>a, b = b, a + b</p>
<h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><pre><code class="python">class Solution:
    def Fibonacci(self, n):
        a, b = 0, 1
        for _ in range(n):
            a, b = b, a + b
        return a
</code></pre>
<h3 id="举一反三-2"><a href="#举一反三-2" class="headerlink" title="举一反三"></a>举一反三</h3><ul>
<li><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/9_2_%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6.py" target="_blank" rel="external">青蛙跳台阶</a></li>
<li><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/9_3_%E5%8F%98%E6%80%81%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6.py" target="_blank" rel="external">变态青蛙跳台阶</a></li>
<li><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/9_4_%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%96.py" target="_blank" rel="external">矩形覆盖</a></li>
</ul>
<h2 id="二进制中1的个数"><a href="#二进制中1的个数" class="headerlink" title="二进制中1的个数"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/10_1_%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0.py" target="_blank" rel="external">二进制中1的个数</a></h2><h3 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p>
<h3 id="最优题解-7"><a href="#最优题解-7" class="headerlink" title="最优题解"></a>最优题解</h3><p>利用一个位运算技巧：一个整数减1后总是把它二进制表示的最右边的1变为0<br>这里有两种情况：最右边的1在最末位和不在最末位<br>但无论怎样，减一后的数与原数相与就一定可以把最右的1变为0<br>有一点要注意：由于c/c++/java中int位数限定32位，<br>所以n最后一定被全部变为0，循环退出；<br>但python就有区别了，python的整数位数不止32位，<br>所以在负数情况下1的位数会多出很多，所以应先&amp;0xffffffff，保留后面32位，前面全部变成0</p>
<h3 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h3><pre><code class="python">class Solution:
    def NumberOf1(self, n):
        n &amp;= 0xffffffff
        count = 0
        while n:
            n &amp;= n - 1
            count += 1
        return count
</code></pre>
<h3 id="举一反三-3"><a href="#举一反三-3" class="headerlink" title="举一反三"></a>举一反三</h3><ul>
<li><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/10_2_2%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9.py" target="_blank" rel="external">2的整数次方</a></li>
<li><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/10_3_%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB.py" target="_blank" rel="external">汉明距离</a></li>
</ul>
<h2 id="数值的整数次方"><a href="#数值的整数次方" class="headerlink" title="数值的整数次方"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/11_%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9.py" target="_blank" rel="external">数值的整数次方</a></h2><h3 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方</p>
<h3 id="最优题解-8"><a href="#最优题解-8" class="headerlink" title="最优题解"></a>最优题解</h3><p>注意点：</p>
<ol>
<li>base = 0 且 exponent &lt; 0 时发生除零错误；</li>
<li>exponent &lt; 0 时要作倒数；</li>
<li>0^0=1</li>
<li>判断 base 是否等于 0 时不能直接 == ，因为base为浮点数，有误差。<br>如果两个小数的差的绝对值很小，比如小于0.0000001，就可以认为它们相等；</li>
<li>乘方可以考虑用快速幂（递归实现）</li>
</ol>
<h3 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h3><pre><code>class Solution:
    def Power(self, base, exponent):
        def is_equal(num1, num2):
            return abs(num1 - num2) &lt; 0.0000001

        def PowerWithUnsignedExponent(base, exponent):
            if exponent == 0:
                return 1
            if exponent == 1:
                return base
            result = PowerWithUnsignedExponent(base, exponent &gt;&gt; 1)  # 除2用位运算
            result *= result
            if exponent &amp; 1 == 1:  # 判奇偶模2用位运算
                result *= base
            return result

        if is_equal(base, 0.0) and exponent &lt; 0:
            return
        result = PowerWithUnsignedExponent(base, abs(exponent))
        if exponent &lt; 0:
            return 1.0 / result
        return result
</code></pre><h2 id="打印1到最大的n位数"><a href="#打印1到最大的n位数" class="headerlink" title="打印1到最大的n位数"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/12_%E6%89%93%E5%8D%B01%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0.py" target="_blank" rel="external">打印1到最大的n位数</a></h2><h3 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入数字n, 按顺序打印从1最大的n位十进制数，比如输入3, 则打印出1、2、3、到最大的3位数即999<br>（这里不打印，而是返回一个list）</p>
<h3 id="最优题解-9"><a href="#最优题解-9" class="headerlink" title="最优题解"></a>最优题解</h3><p>由于没有位数限制，所以要考虑大数问题，用字符串或数组表示大数<br>需要注意的问题是字符串或者数组的最高位对于数字上的最低位<br>在字符串表达的数字上模拟加法，然后将字符串表达的数值打印出来</p>
<h3 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h3><pre><code class="python">class Solution:
    def Print1ToMaxOfNDigits(self, n):
        def RmStartZero(number):  # 去掉前面多余的0
            if int(&#39;&#39;.join(number)) == 0:  # 全0直接返回
                return number
            num = number[:]  # 拷贝，因为pop操作会修改number的长度
            while not int(num[0]):
                num.pop(0)
            return num

        def Increment(number):
            isOverflow = False
            nTakeOver = 0
            nLength = len(number)
            for i in range(nLength - 1, -1, -1):
                nSum = int(number[i]) + nTakeOver
                if i == nLength - 1:
                    nSum += 1
                if nSum &gt;= 10:
                    if i == 0:
                        isOverflow = True
                    else:
                        nSum -= 10
                        nTakeOver = 1
                        number[i] = str(nSum)
                else:
                    number[i] = str(nSum)
                    break
            return isOverflow

        if n &lt;= 0: return
        res = []
        number = [&#39;0&#39;] * n
        while not Increment(number):
            res.append(&#39;&#39;.join(RmStartZero(number)))
        return res
</code></pre>
<h2 id="在O-1-时间删除链表节点"><a href="#在O-1-时间删除链表节点" class="headerlink" title="在O(1)时间删除链表节点"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/13_%E5%9C%A8O%281%29%E6%97%B6%E9%97%B4%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E8%8A%82%E7%82%B9.py" target="_blank" rel="external">在O(1)时间删除链表节点</a></h2><h3 id="题目描述-10"><a href="#题目描述-10" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定单向链表的头指针和一个结点指针,定义一个函数在O(1)时间删除该结点</p>
<h3 id="最优题解-10"><a href="#最优题解-10" class="headerlink" title="最优题解"></a>最优题解</h3><p>不必顺序查找到结点i的前一个节点再删除，这样是O(n)，<br>要删除结点i，可以先把i的下一个结点j的内容复制到i，然后把i的指针指向j的下一个结点，<br>最后再删除结点j，其效果刚好是把结点i给删除了<br>即：当我们想删除一个结点时，并不一定要删除这个结点本身，<br>可以先把下一个结点的内容复制出来覆盖被删除结点的内容，然后把下一个结点删除<br>考虑两种特殊情况：<br>1、如果要删除的是尾结点，它没有下一个结点，此时只能从头开始顺序遍历得到该节点的前序结点，并完成删除<br>2、如果链表中只有一个结点，即要删除的节点是头结点（它连前序结点都没有），需要单独处理（删除后设为NULL）</p>
<h3 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h3><pre><code class="python">class ListNode:
    def __init__(self, x=None):
        self.val = x
        self.next = None

    def delete(self):
        self.val = None
        self.next = None

class Solution:
    def DeleteNode(self, ListHead, ToBeDeleted):
        # 返回删除后链表的头结点
        if not ListHead or not ToBeDeleted: return # 头结点和要删除结点都为空返回None
        if ToBeDeleted.next is not None:  # 要删除的结点不是尾结点
            Next = ToBeDeleted.next
            ToBeDeleted.val = Next.val
            ToBeDeleted.next = Next.next
            Next.delete()
        elif ListHead == ToBeDeleted:  # 要删除的结点是头结点
            ListHead.delete()
        else:  # 要删除的结点是尾结点
            Node = ListHead
            while Node.next is not ToBeDeleted:
                Node = Node.next
            Node.next = None
            ToBeDeleted.delete()
        return ListHead
</code></pre>
<h2 id="使奇数位于偶数前面"><a href="#使奇数位于偶数前面" class="headerlink" title="使奇数位于偶数前面"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/14_%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2.py" target="_blank" rel="external">使奇数位于偶数前面</a></h2><h3 id="题目描述-11"><a href="#题目描述-11" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，<br>使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，<br>并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p>
<h3 id="最优题解-11"><a href="#最优题解-11" class="headerlink" title="最优题解"></a>最优题解</h3><p>时间（O（n）），空间（O（n））</p>
<p>首先统计奇数的个数i，然后新建一个等长数组，遍历原数组。<br>设置两个指针， 奇数从0开始复制，偶数从i开始（奇数末尾）。<br>稳定排序，时间复杂度降下来了，但空间复杂度提高了。</p>
<h3 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h3><pre><code class="python">class Solution:
    def reOrderArray(self, array):
        odd = 0 # 奇数开始位置
        even = sum(i &amp; 1 for i in array) # 统计奇数个数，为偶数开始位置
        res = [0] * len(array)
        for i in array:
            if i &amp; 1:
                res[odd] = i
                odd += 1
            else:
                res[even] = i
                even += 1
        return res
</code></pre>
<h2 id="链表倒数第k个结点"><a href="#链表倒数第k个结点" class="headerlink" title="链表倒数第k个结点"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/15_1_%E9%93%BE%E8%A1%A8%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9.py" target="_blank" rel="external">链表倒数第k个结点</a></h2><h3 id="题目描述-12"><a href="#题目描述-12" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个单向链表，输出该链表中倒数第k个结点。</p>
<h3 id="最优题解-12"><a href="#最优题解-12" class="headerlink" title="最优题解"></a>最优题解</h3><p>双指针。<br>定义两个指针，第一个先从头开始走k步，第二个保持不动；从第k步开始，第二个指针也开始从头遍历。<br>由于两个指针的距离保持在k，所以当第一个指针遍历完整个链表时，第二个指针正好来到倒数第k个结点</p>
<h3 id="代码-12"><a href="#代码-12" class="headerlink" title="代码"></a>代码</h3><pre><code class="python">class Solution:
    def FindKthToTail(self, head, k):
        if not head: return
        l = r = head
        while k and r:
            r = r.next
            k -= 1
        if k != 0 and r is None: return # k 大于链表长度
        while r:
            l, r = l.next, r.next
        return l
</code></pre>
<h3 id="举一反三-4"><a href="#举一反三-4" class="headerlink" title="举一反三"></a>举一反三</h3><ul>
<li><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/15_2_%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%97%B4%E7%BB%93%E7%82%B9.py" target="_blank" rel="external">链表中间结点</a></li>
<li><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/15_3_%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E5%90%AB%E7%8E%AF.py" target="_blank" rel="external">判断链表是否含环</a></li>
<li><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/15_4_%E5%90%AB%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E5%85%A5%E5%8F%A3%E7%82%B9.py" target="_blank" rel="external">含环链表的入口点</a></li>
<li><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/15_5_%E5%90%AB%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E9%95%BF%E5%BA%A6%E5%92%8C%E7%8E%AF%E7%9A%84%E9%95%BF%E5%BA%A6.py" target="_blank" rel="external">含环链表的长度和环的长度</a></li>
<li><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/15_6_%E6%97%A0%E7%8E%AF%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E7%9B%B8%E4%BA%A4.py" target="_blank" rel="external">无环单向链表的相交</a></li>
</ul>
<h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/16_%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8.py" target="_blank" rel="external">反转链表</a></h2><h3 id="题目描述-13"><a href="#题目描述-13" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个链表的头结点，反转该链表并输出反转后链表的头结点</p>
<h3 id="最优题解-13"><a href="#最优题解-13" class="headerlink" title="最优题解"></a>最优题解</h3><p>定义三个指针，分别指向当前遍历到的结点、它的前一个结点以及后一个结点<br>指向后一个结点的指针是为了防止链表断裂，因为需要把当前结点的下一个指针指向前一个结点</p>
<h3 id="代码-13"><a href="#代码-13" class="headerlink" title="代码"></a>代码</h3><pre><code class="python">class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None
class Solution:
    # 返回ListNode
    def ReverseList(self, pHead):
        pre, cur = None, pHead
        while cur:
            cur.next, cur, pre = pre, cur.next, cur
            # 上面的一行相当于下面四行
            # next = cur.next  # 先保存下一个结点防止断裂
            # cur.next = pre
            # pre = cur
            # cur = next
        return pre
</code></pre>
<h2 id="合并两个排序的链表"><a href="#合并两个排序的链表" class="headerlink" title="合并两个排序的链表"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/17_%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8.py" target="_blank" rel="external">合并两个排序的链表</a></h2><h3 id="题目描述-14"><a href="#题目描述-14" class="headerlink" title="题目描述"></a>题目描述</h3><p>合并两个单调递增的链表，使得合并后的链表仍然单调递增</p>
<h3 id="最优题解-14"><a href="#最优题解-14" class="headerlink" title="最优题解"></a>最优题解</h3><p>使用一个尾指针，每次比较把较小的结点连接到尾结点后面，记得最后将剩余的链表链接到尾结点后面</p>
<h3 id="代码-14"><a href="#代码-14" class="headerlink" title="代码"></a>代码</h3><pre><code class="python">class Solution:
    # 返回合并后的链表头结点
    def Merge(self, pHead1, pHead2):
        dummy = tail = ListNode(0)
        while pHead1 and pHead2:
            if pHead1.val &lt;= pHead2.val:
                tail.next = pHead1
                pHead1 = pHead1.next
            else:
                tail.next = pHead2
                pHead2 = pHead2.next
            tail = tail.next
        tail.next = pHead1 or pHead2  # 记得将剩余的链表链接到尾结点后面
        return dummy.next  # 伪结点的下一个结点才是真正的头结点
</code></pre>
<h2 id="树的子结构"><a href="#树的子结构" class="headerlink" title="树的子结构"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/18_%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84.py" target="_blank" rel="external">树的子结构</a></h2><h3 id="题目描述-15"><a href="#题目描述-15" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入两棵二叉树A，B，判断B是不是A的子结构（空树不是任意一个树的子结构）</p>
<h3 id="最优题解-15"><a href="#最优题解-15" class="headerlink" title="最优题解"></a>最优题解</h3><p>先递归遍历（先序遍历）树A，找到相同的根结点子树，<br>再用递归分别判断该子树的左右子树是否与B一样，递归结束的条件是来到B的叶结点</p>
<h3 id="代码-15"><a href="#代码-15" class="headerlink" title="代码"></a>代码</h3><pre><code class="python">class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution:
    # pRoot1是A的根节点，pRoot2是B的根节点
    def HasSubtree(self, pRoot1, pRoot2):
        def check(root1, root2):
            # 用于递归判断树的每个节点是否相同
            # 需要注意的地方是: 前两个if语句不可以颠倒顺序
            # 如果颠倒顺序, 会先判断root1是否为None,
            # 其实这个时候root2的结点已经遍历完并确定相等了,但是返回了False
            if root2 is None: return True
            if root1 is None: return False
            if root1.val != root2.val: return False
            return check(root1.left, root2.left) and check(root1.right, root2.right)

        if not pRoot1 or not pRoot2: return False
        if check(pRoot1, pRoot2): return True
        return self.HasSubtree(pRoot1.left, pRoot2) or self.HasSubtree(pRoot1.right, pRoot2)
</code></pre>
<h2 id="二叉树的镜像"><a href="#二叉树的镜像" class="headerlink" title="二叉树的镜像"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/19_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F.py" target="_blank" rel="external">二叉树的镜像</a></h2><h3 id="题目描述-16"><a href="#题目描述-16" class="headerlink" title="题目描述"></a>题目描述</h3><p>将给定的二叉树变换为原二叉树的镜像。</p>
<h3 id="最优题解-16"><a href="#最优题解-16" class="headerlink" title="最优题解"></a>最优题解</h3><p>递归实现，前序遍历二叉树的每个结点，<br>如果遍历到的结点有子结点，就交换它的两个子结点，<br>当交换完所有的非叶子结点的左右子结点之后，就得到了树的镜像</p>
<h3 id="代码-16"><a href="#代码-16" class="headerlink" title="代码"></a>代码</h3><pre><code class="python">class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None
class Solution:
    # 返回镜像树的根节点
    def Mirror(self, root):
        if root is None: return
        root.left, root.right = root.right, root.left
        self.Mirror(root.left)
        self.Mirror(root.right)
        return root
</code></pre>
<h2 id="顺时针打印矩阵"><a href="#顺时针打印矩阵" class="headerlink" title="顺时针打印矩阵"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/20_%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5.py" target="_blank" rel="external">顺时针打印矩阵</a></h2><h3 id="题目描述-17"><a href="#题目描述-17" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，<br>例如，如果输入如下矩阵：<br>[[ 1,  2,  3,  4],<br> [ 5,  6,  7,  8],<br> [ 9, 10, 11, 12],<br> [13, 14, 15, 16]]<br>则依次打印出数字 1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</p>
<h3 id="最优题解-17"><a href="#最优题解-17" class="headerlink" title="最优题解"></a>最优题解</h3><p>时间O（n*m）, 空间O（1）</p>
<p>一个圈其实只要左上角（startR, startC）和右下角（endR, endC）确定了整个圈也就确定了，<br>​        因此外层循环控制左上角和右下角的变化，内层循环根据这两个坐标分情况绕圈打印就可以了<br>​        外层循环如何控制两个坐标？只需每次让 （startR++, startC++）和 （endR–, endC–）<br>​        什么时候退出？当右下角来到左上角的左上方时退出，换句话讲就是当<br>​        startR &lt;= endR and startC &lt;= endC 时我们才可以进入内层循环打印圈<br>​        那内层循环如何分情况打印圈？情况就三种：<br>​        1、当 startR == endR 时，说明只剩一行<br>​        2、当 startC == endC 时，说明只剩一列<br>​        3、否则为一般情况，绕圈打印即可</p>
<h3 id="代码-17"><a href="#代码-17" class="headerlink" title="代码"></a>代码</h3><pre><code class="python">class Solution:
    # matrix类型为二维列表，需要返回列表
    def PrintMatrix(self, matrix):
        def printEdge(startR, startC, endR, endC):
            if startR == endR:  # 只剩一行
                for col in range(startC, endC + 1):
                    res.append(matrix[startR][col])
            elif startC == endC:  # 只剩一列
                for row in range(startR, endR + 1):
                    res.append(matrix[row][startC])
            else:  # 一般情况
                curR, curC = startR, startC
                while curC != endC:  # 从左到右
                    res.append(matrix[curR][curC])
                    curC += 1
                while curR != endR:  # 从上到下
                    res.append(matrix[curR][curC])
                    curR += 1
                while curC != startC:  # 从右到左
                    res.append(matrix[curR][curC])
                    curC -= 1
                while curR != startR:  # 从下到上
                    res.append(matrix[curR][curC])
                    curR -= 1

        if not matrix: return
        startR, startC, endR, endC = 0, 0, len(matrix) - 1, len(matrix[0]) - 1
        res = []
        while startR &lt;= endR and startC &lt;= endC:
            printEdge(startR, startC, endR, endC)
            startR += 1
            startC += 1
            endR -= 1
            endC -= 1
        return res
</code></pre>
<h3 id="举一反三-5"><a href="#举一反三-5" class="headerlink" title="举一反三"></a>举一反三</h3><ul>
<li><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/20_2_%E9%A1%BA%E6%97%B6%E9%92%88%E5%A1%AB%E5%85%85%E7%9F%A9%E9%98%B5.py" target="_blank" rel="external">顺时针填充矩阵</a></li>
</ul>
<h2 id="包含min函数的栈"><a href="#包含min函数的栈" class="headerlink" title="包含min函数的栈"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/21_%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88.py" target="_blank" rel="external">包含min函数的栈</a></h2><h3 id="题目描述-18"><a href="#题目描述-18" class="headerlink" title="题目描述"></a>题目描述</h3><p>定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的min函数。<br>在该栈中，调用min、push及pop的时间复杂度都是O(1)</p>
<h3 id="最优题解-18"><a href="#最优题解-18" class="headerlink" title="最优题解"></a>最优题解</h3><p>设置一个辅助栈，每次入栈时把最小元素<br>（之前的最小值（辅助栈栈顶）和新压入栈的元素两者的较小值）保存在辅助栈中<br>出栈时辅助栈一起出栈，这样就可以保证辅助栈的栈顶是最小值</p>
<h3 id="代码-18"><a href="#代码-18" class="headerlink" title="代码"></a>代码</h3><pre><code class="python">class Solution:
    def __init__(self):
        self.stack = []
        self.minstack = []

    def push(self, node):
        self.stack.append(node)
        if not self.minstack or node &lt;= self.min():
            self.minstack.append(node)
        else:
            self.minstack.append(self.min())

    def pop(self):
        if not self.stack: return
        self.minstack.pop()
        return self.stack.pop()

    def top(self):
        return self.stack if self.stack else None

    def min(self):
        return self.minstack[-1] if self.minstack else None
</code></pre>
<h2 id="栈的压入弹出序列"><a href="#栈的压入弹出序列" class="headerlink" title="栈的压入弹出序列"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/22_%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97.py" target="_blank" rel="external">栈的压入弹出序列</a></h2><h3 id="题目描述-19"><a href="#题目描述-19" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。<br>假设压入栈的所有数字均不相等。<br>例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，<br>但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p>
<h3 id="最优题解-19"><a href="#最优题解-19" class="headerlink" title="最优题解"></a>最优题解</h3><p>设置一个辅助栈，用来装压栈序列，不断压入压栈序列的数，每压入一次，<br>就看一下当前栈顶元素是否为当前弹出数，是的话弹出并遍历下一个弹出数，<br>继续检查，直到辅助栈空或者当前栈顶元素不为弹出序列第一个，<br>就继续压入压栈序列的数，直到压完所有的数，最终检查辅助栈是否为空，空则说明该序列为弹出序列<br>即：如果下一个弹出的数字刚好是栈顶数字，那么直接弹出。如果下一个弹出的数字不在栈顶，<br>就把压栈序列中还没入栈的数字压入辅助栈，直到把下一个需要弹出的数字压入栈顶为止。<br>如果所有的数字都压入栈了仍然没有找到下一个弹出的数字，那么该序列就不可能是一个弹出序列</p>
<h3 id="代码-19"><a href="#代码-19" class="headerlink" title="代码"></a>代码</h3><pre><code class="python">class Solution:
    def IsPopOrder(self, pushV, popV):
        if not pushV or not popV or len(pushV) != len(popV):
            return False
        stack, i = [], 0
        for num in pushV:
            stack.append(num)
            while stack and stack[-1] == popV[i]:
                i += 1
                stack.pop()
        return stack == []
</code></pre>
<h2 id="从上往下打印二叉树"><a href="#从上往下打印二叉树" class="headerlink" title="从上往下打印二叉树"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/23_%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91.py" target="_blank" rel="external">从上往下打印二叉树</a></h2><h3 id="题目描述-20"><a href="#题目描述-20" class="headerlink" title="题目描述"></a>题目描述</h3><p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p>
<h3 id="最优题解-20"><a href="#最优题解-20" class="headerlink" title="最优题解"></a>最优题解</h3><p>相当于宽度优先搜索（BFS），用队列来实现：<br>每次从头部取出一个结点时，如果该结点有子结点，<br>就把该结点的子结点从左到右依次放入队列末尾，<br>重复前面的步骤，直到队列为空</p>
<h3 id="代码-20"><a href="#代码-20" class="headerlink" title="代码"></a>代码</h3><pre><code class="python">class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution:
    # 返回从上到下每个节点值列表，例：[1,2,3]
    def PrintFromTopToBottom(self, root):
        if root is None: return []
        res, level = [], [root]
        while level:
            next_level = []
            for node in level:
                res.append(node.val)
                if node.left:
                    next_level.append(node.left)
                if node.right:
                    next_level.append(node.right)
            level = next_level
        return res
</code></pre>
<h2 id="二叉搜索树的后序遍历序列"><a href="#二叉搜索树的后序遍历序列" class="headerlink" title="二叉搜索树的后序遍历序列"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/24_2_%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97.py" target="_blank" rel="external">二叉搜索树的后序遍历序列</a></h2><h3 id="题目描述-21"><a href="#题目描述-21" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。<br>假设输入的数组的任意两个数字都互不相同。</p>
<h3 id="最优题解-21"><a href="#最优题解-21" class="headerlink" title="最优题解"></a>最优题解</h3><p>二叉搜索树对于每一个非叶子节点, 均有结点左子节点&lt;当前节点&lt;结点右子节点<br>后序序列的最后一个值为二叉搜索树根节点的值，前面含有左子树和右子树结点<br>根据二叉搜索树的特性，根节点前面的序列分为两个区域，左边为左子树区，<br>值都比根节点小，右边为右子树区，值都比根节点大，<br>不满足该特性的序列就不是某二叉搜索树的后序遍历的结果，<br>注意左子树区域和右子树区域分别又是一棵二叉搜索树，因此递归检查这两个区域</p>
<h3 id="代码-21"><a href="#代码-21" class="headerlink" title="代码"></a>代码</h3><pre><code class="python">class Solution:
    def VerifySquenceOfBST(self, sequence):
        def verify(seq):
            if not seq or len(seq) == 1: return True
            for i in range(len(seq)):
                if seq[i] &gt; seq[-1]: break
            # 如果是前序遍历就必须加上 i+=1
            # 这里不用的原因在于seq[-1]是哨兵
            # i一定会在小于区的右边界的右边元素停下
            for j in range(i, len(seq) - 1):
                if seq[j] &lt; seq[-1]: return False
            return verify(seq[:i]) and verify(seq[i:-1])
        if not sequence: return False
        return verify(sequence)
</code></pre>
<h3 id="举一反三-6"><a href="#举一反三-6" class="headerlink" title="举一反三"></a>举一反三</h3><p><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/24_1_%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97.py" target="_blank" rel="external">二叉搜索树的前序遍历序列</a></p>
<h2 id="二叉树中和为某一值的路径"><a href="#二叉树中和为某一值的路径" class="headerlink" title="二叉树中和为某一值的路径"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/25_%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84.py" target="_blank" rel="external">二叉树中和为某一值的路径</a></h2><h3 id="题目描述-22"><a href="#题目描述-22" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一颗二叉树和一个整数，输出二叉树中结点值的和为输入整数的所有路径。<br>路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。</p>
<h3 id="最优题解-22"><a href="#最优题解-22" class="headerlink" title="最优题解"></a>最优题解</h3><p>前序遍历，每来到一个结点就检查当前和是否为期望和，所以需要把当前和作为参数传递。</p>
<h3 id="代码-22"><a href="#代码-22" class="headerlink" title="代码"></a>代码</h3><pre><code class="python">class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution:
    # 返回二维列表，内部每个列表表示找到的路径
    def FindPath(self, root, expectNumber):
        def find(root, cursum):
            if not root: return 
            path.append(root.val)
            cursum += root.val
            if not root.left and not root.right and cursum == expectNumber:
                res.append(path[:]) 
            find(root.left, cursum)
            find(root.right, cursum)
            path.pop() # 结点返回时记得把当前结点从路径中删除

        res, path = [], []
        find(root, 0)
        return res
</code></pre>
<h2 id="复杂链表的复制"><a href="#复杂链表的复制" class="headerlink" title="复杂链表的复制"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/26_%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6.py" target="_blank" rel="external">复杂链表的复制</a></h2><h3 id="题目描述-23"><a href="#题目描述-23" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个复杂链表（每个节点中有节点值，以及两个指针，<br>next指向下一个节点，random指向任意一个节点），<br>返回结果为复制后复杂链表的head。</p>
<h3 id="最优题解-23"><a href="#最优题解-23" class="headerlink" title="最优题解"></a>最优题解</h3><p>时间复杂度O(n)，空间复杂度O(1)</p>
<p>第一步，复制原链表的结点N并创建新结点N’，再把N’链接到N的后面；</p>
<p>第二步，设置每个N’的random。如果原链表上的结点N的random指向S，则它对应的复制结点N’的random指向S的下一个结点S’</p>
<p>第三步，把这个长链表拆分成两个链表，奇数位置上的结点组成原链表，偶数位置上的结点组成复制链表</p>
<h3 id="代码-23"><a href="#代码-23" class="headerlink" title="代码"></a>代码</h3><pre><code class="python">class Solution:
    def __init__(self, x):
        self.label = x
        self.next = None
        self.random = None

    def Clone(self, pHead):
        def clone(head):
            while head:
                cloneNode = RandomListNode(head.label)
                cloneNode.next = head.next
                head.next = cloneNode
                head = cloneNode.next

        def connect(head):
            clone = head.next
            while head:
                clone.random = head.random.next if head.random else None
                head = clone.next
                clone = head.next if head else None

        def split(head):
            clone = cloneHead = head.next
            while head:
                head.next = clone.next
                head = head.next
                clone.next = head.next if head else None
                clone = clone.next
            return cloneHead

        if pHead is None: return
        clone(pHead)
        connect(pHead)
        return split(pHead)
</code></pre>
<h2 id="二叉搜索树与双向链表"><a href="#二叉搜索树与双向链表" class="headerlink" title="二叉搜索树与双向链表"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/27_%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.py" target="_blank" rel="external">二叉搜索树与双向链表</a></h2><h3 id="题目描述-24"><a href="#题目描述-24" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。<br>要求不能创建任何新的结点，只能调整树中结点指针的指向。</p>
<h3 id="最优题解-24"><a href="#最优题解-24" class="headerlink" title="最优题解"></a>最优题解</h3><p>二叉搜索树与双向链表的每个结点均含有两个指针，数据结构类似，可以实现相互转换</p>
<p><img src="https://ws1.sinaimg.cn/large/006giLD5ly1fwx65siwcwj30h103bjr8.jpg" alt="转换示意图"></p>
<p>中序遍历，同时设置一个指针指向当前双向链表的最后一个结点，<br>每个被遍历到的结点都与当前双向链表的最后一个结点互相连接，<br>同时更新该指针为当前被遍历到的结点</p>
<h3 id="代码-24"><a href="#代码-24" class="headerlink" title="代码"></a>代码</h3><pre><code class="python">class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution:
    def __init__(self):
        self.last = None

    def Convert(self, pRootOfTree):
        def convert(root):
            if not root: return 
            convert(root.left)
            self.last.right = root
            root.left = self.last
            self.last = root
            convert(root.right)

        if not pRootOfTree: return
        dummy = self.last = TreeNode(0)
        convert(pRootOfTree)
        dummy.right.left = None  # 去掉伪结点
        return dummy.right  # 伪结点的右边是真正的头结点
</code></pre>
<h2 id="字符串的排列"><a href="#字符串的排列" class="headerlink" title="字符串的排列"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/28_1_%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97.py" target="_blank" rel="external">字符串的排列</a></h2><h3 id="题目描述-25"><a href="#题目描述-25" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个字符串,按字典序打印出该字符串中字符的所有排列。<br>例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。<br>输入描述:<br>输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。</p>
<h3 id="最优题解-25"><a href="#最优题解-25" class="headerlink" title="最优题解"></a>最优题解</h3><p>递归，从头到尾逐个字符抽出来，剩下字符的进行排列<br>最后再把抽出来的那个字符与排列好的字符串拼在一起返回即可<br>只剩下一个字符时直接返回该字符</p>
<h3 id="代码-25"><a href="#代码-25" class="headerlink" title="代码"></a>代码</h3><pre><code class="python">class Solution:
    def Permutation(self, ss):
        def permutation(ss):
            if len(ss) == 1: return [ss]
            res = []
            for i in range(len(ss)):
                for s in permutation(ss[:i] + ss[i + 1:]):
                    res.append(ss[i] + s)
            return res

        if not ss: return []
        return sorted(list(set(permutation(ss))))
</code></pre>
<h3 id="举一反三-7"><a href="#举一反三-7" class="headerlink" title="举一反三"></a>举一反三</h3><ul>
<li><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/28_2_%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E7%BB%84%E5%90%88.py" target="_blank" rel="external">字符串的组合</a></li>
<li><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/28_3_%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98.py" target="_blank" rel="external">八皇后问题</a></li>
</ul>
<h2 id="数组中出现次数超过一半的数字"><a href="#数组中出现次数超过一半的数字" class="headerlink" title="数组中出现次数超过一半的数字"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/29_%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97.py" target="_blank" rel="external">数组中出现次数超过一半的数字</a></h2><h3 id="题目描述-26"><a href="#题目描述-26" class="headerlink" title="题目描述"></a>题目描述</h3><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。<br>例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。<br>由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</p>
<h3 id="最优题解-26"><a href="#最优题解-26" class="headerlink" title="最优题解"></a>最优题解</h3><p>时间O（n），空间O（1）</p>
<p>采用阵地攻守的思想：<br>先让第一个数作为守阵地的士兵，HP=1；<br>遇到相同元素，相当于支援兵，补血，HP+1;<br>遇到不相同元素，相当于敌人，掉血，HP-1；<br>当HP削减为0时，以下一个数作为守阵地的士兵；<br>继续下去，到最后还留在阵地上的士兵，有可能是最强士兵（士兵个数超过一半）。<br>为防止该士兵坐收渔翁之利，需再加一次循环，检查该士兵个数是否真的超过一半。</p>
<h3 id="代码-26"><a href="#代码-26" class="headerlink" title="代码"></a>代码</h3><pre><code class="python">class Solution:
    def MoreThanHalfNum(self, numbers):
        if not numbers: return 0
        master = numbers[0]
        hp = 1
        for num in numbers[1:]:
            if hp == 0:
                master = num
                hp = 1
            elif num == master: 
                hp += 1
            else:
                hp -= 1
        isHalf = sum(num == master for num in numbers) &gt; len(numbers) &gt;&gt; 1
        return master if isHalf else 0
</code></pre>
<h2 id="最小的K个数"><a href="#最小的K个数" class="headerlink" title="最小的K个数"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/30_%E6%9C%80%E5%B0%8F%E7%9A%84K%E4%B8%AA%E6%95%B0.py" target="_blank" rel="external">最小的K个数</a></h2><h3 id="题目描述-27"><a href="#题目描述-27" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4</p>
<h3 id="最优题解-27"><a href="#最优题解-27" class="headerlink" title="最优题解"></a>最优题解</h3><p>时间O(nlogk)，空间O(1)</p>
<p>基于Partition的算法, 只有当我们可以修改输入的数组时可用。<br>利用Partition找到第(k-1)小的数(从0开始)，则数组左边的k个数字就是最小的k个数字（这k个数字不一定是排序的）</p>
<h3 id="代码-27"><a href="#代码-27" class="headerlink" title="代码"></a>代码</h3><pre><code class="python">class Solution:
    def GetLeastNumbers(self, tinput, k):
        def partition(l, r):  # 基于快排的partition
            pivot = tinput[l] # 首元素为枢轴标杆
            while l &lt; r:
                while l &lt; r and tinput[r] &gt;= pivot: r -= 1
                tinput[l] = tinput[r]
                while l &lt; r and tinput[l] &lt;= pivot: l += 1
                tinput[r] = tinput[l]
            tinput[l] = pivot
            return l

        if not tinput or k &lt;= 0 or len(tinput) &lt; k: return []
        l, r = 0, len(tinput) - 1
        # 以下类似二分， 只不过分界线不再是mid，而是通过partition求得
        while l &lt;= r:
            idx = partition(l, r)
            if idx &lt; k - 1:
                l = idx + 1
            elif idx &gt; k - 1:
                r = idx - 1
            else:
                return sorted(tinput[:k])
</code></pre>
<h2 id="连续子数组的最大和"><a href="#连续子数组的最大和" class="headerlink" title="连续子数组的最大和"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/31_%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C.py" target="_blank" rel="external">连续子数组的最大和</a></h2><h3 id="题目描述-28"><a href="#题目描述-28" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个整型数组，数组中一个或连续的多个整数组成一个子数组。<br>求所有子数组的和的最大值，要求时间复杂度为O(n)</p>
<h3 id="最优题解-28"><a href="#最优题解-28" class="headerlink" title="最优题解"></a>最优题解</h3><p>动态规划。<br>设 f(i) 为以第 i 个数结尾的连续子数组的最大和，则状态转移方程为：<br><code>f(i) = max(f(i-1)+array[i], array[i])</code><br>最后结果为max(f(i))<br>优化：f(i)只与f(i-1)有关，即只与前一状态有关，所以空间上可以由O(n)降为O(1)</p>
<p>该状态转移方程的意义是：<br>如果以第 i-1 个数字结尾的子数组中所有数字的和加上当前第 i 个数字比当前第 i 个数字本身还要小，<br>那么就舍弃前面的累加而直接选择第 i 个数字本身作为最大值<br>最后求所有以第 i 个数结尾的连续子数组最大和的最大值</p>
<h3 id="代码-28"><a href="#代码-28" class="headerlink" title="代码"></a>代码</h3><pre><code class="python">class Solution:
    def FindGreatestSumOfSubArray(self, array):
        if not array: return
        curSum = maxSum = array[0]
        for num in array[1:]:
            curSum = max(num, curSum + num)
            maxSum = max(maxSum, curSum)
        return maxSum
</code></pre>
<h2 id="从1到n中1出现的次数"><a href="#从1到n中1出现的次数" class="headerlink" title="从1到n中1出现的次数"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/32_%E4%BB%8E1%E5%88%B0n%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0.py" target="_blank" rel="external">从1到n中1出现的次数</a></h2><h3 id="题目描述-29"><a href="#题目描述-29" class="headerlink" title="题目描述"></a>题目描述</h3><p>原题：输入一个整数n，求从1到n这n个整数的十进制表示中1出现的次数<br>扩展：改成X出现的次数，X∈[1,9]</p>
<h3 id="最优题解-29"><a href="#最优题解-29" class="headerlink" title="最优题解"></a>最优题解</h3><p>链接：<a href="https://www.nowcoder.net/questionTerminal/bd7f978302044eee894445e244c7eee6" target="_blank" rel="external">https://www.nowcoder.net/questionTerminal/bd7f978302044eee894445e244c7eee6</a><br>来源：牛客网<br>参考博文：<a href="http://www.cnblogs.com/nailperry/p/4752987.html" target="_blank" rel="external">http://www.cnblogs.com/nailperry/p/4752987.html</a> ，主要就是从数字出发找规律。</p>
<p>一、1的数目</p>
<p>编程之美上给出的规律：</p>
<ol>
<li>如果第i位（自右至左，从1开始标号）上的数字为0，则第i位可能出现1的次数由更高位决定<br> （若没有高位，视高位为0），等于更高位数字*当前位数的权重10^(i-1)。</li>
<li>如果第i位上的数字为1，则第i位上可能出现1的次数不仅受更高位影响，还受低位影响<br> （若没有低位，视低位为0），等于更高位数字*当前位数的权重10^(i-1)+（低位数字+1）。</li>
<li>如果第i位上的数字大于1，则第i位上可能出现1的次数仅由更高位决定（若没有高位，视高位为0），<br>等于（更高位数字+1）*当前位数的权重10^(i-1)。</li>
</ol>
<p>二、X的数目</p>
<p>这里的X∈[1,9]，因为X=0不符合下列规律，需要单独计算。<br>首先要知道以下的规律：<br>从 1 至 10，在它们的个位数中，任意的 X 都出现了 1 次。<br>从 1 至 100，在它们的十位数中，任意的 X 都出现了 10 次。<br>从 1 至 1000，在它们的百位数中，任意的 X 都出现了 100 次。<br>依此类推，从1至10^i，在它们的左数第二位（右数第i位）中，任意的X都出现了10^(i-1)次。<br>这个规律很容易验证，这里不再多做说明。</p>
<p>接下来以 n=2593, X=5 为例来解释如何得到数学公式。从 1 至 2593 中，数字 5 总计出现了 813 次，<br>其中有 259 次出现在个位，260 次出现在十位，294 次出现在百位，0 次出现在千位。<br>现在依次分析这些数据，首先是个位。从 1 至 2590 中，包含了 259 个 10，因此任意的 X 都出现了 259 次。<br>最后剩余的三个数 2591, 2592 和 2593，因为它们最大的个位数字 3 &lt; X，因此不会包含任何 5。<br>（也可以这么看，3 &lt; X，则个位上可能出现的X的次数仅由更高位决定，等于更高位数字（259） * 10 ^ (1 - 1) = 259）。<br>然后是十位。从 1 至 2500 中，包含了 25 个 100，因此任意的 X 都出现了  25 * 10 = 250  次。<br>剩下的数字是从 2501 至 2593，它们最大的十位数字 9 &gt; X，因此会包含全部 10 个 5。<br>最后总计 250 + 10 = 260。（也可以这么看，9 &gt; X，则十位上可能出现的X的次数仅由更高位决定，<br>等于更高位数字(25 + 1) * 10 ^ (2 -  1) = 260）。<br>接下来是百位。从 1 至 2000 中，包含了 2 个 1000，因此任意的 X 都出现了  2 * 100 = 200  次。<br>剩下的数字是从 2001 至 2593，它们最大的百位数字 5 == X，这时情况就略微复杂，<br>它们的百位肯定是包含 5 的，但不会包含全部 100 个。如果把百位是 5 的数字列出来，<br>是从 2500 至 2593，数字的个数与百位和十位数字相关，是 93 + 1 = 94。最后总计 200 + 94 = 294。<br>（也可以这么看，5==X，则百位上可能出现X的次数不仅受更高位影响，还受低位影响，<br>等于更高位数字（2） * 10 ^ (3 - 1) + (93 + 1) = 294）。<br>最后是千位。现在已经没有更高位，因此直接看最大的千位数字 2 &lt; X，所以不会包含任何 5。<br>（也可以这么看，2 &lt; X，则千位上可能出现的X的次数仅由更高位决定，等于更高位数字(0) * 10 ^ (4 - 1) = 0）。<br>到此为止，已经计算出全部数字 5 的出现次数。<br>总结一下以上的算法，可以看到，当计算右数第 i 位包含的 X 的个数时：<br>取第i位左边（所有高位）的数字，乘以  10 ^ (i - 1) ，得到基础值  a 。<br>取第i位数字，计算修正值：<br>如果小于 X，则结果为  a 。<br>如果大于 X，则结果为  a + 10 ^ (i - 1) 。<br>如果等于 X，则取第 i 位右边（所有低位）数字，设为  b ，最后结果为  a + b + 1 。<br>相应的代码非常简单，效率也非常高，时间复杂度只有  O( lg n) 。</p>
<h3 id="代码-29"><a href="#代码-29" class="headerlink" title="代码"></a>代码</h3><pre><code class="python">class Solution:
    def NumberOf1Between1AndN(self, n):
        count, weight = 0, 1
        while weight &lt;= n:
            low = n % weight
            high = n // weight
            cur = high % 10
            base = (high // 10) * weight
            if cur &lt; 1:
                count += base
            elif cur &gt; 1:
                count += base + weight
            else:
                count += base + low + 1
            weight *= 10
        return count
</code></pre>
<h2 id="把数组排成最小的数"><a href="#把数组排成最小的数" class="headerlink" title="把数组排成最小的数"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/33_%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0.py" target="_blank" rel="external">把数组排成最小的数</a></h2><h3 id="题目描述-30"><a href="#题目描述-30" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。<br>例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p>
<h3 id="最优题解-30"><a href="#最优题解-30" class="headerlink" title="最优题解"></a>最优题解</h3><p>最直接的做法就是把数组中所有数字进行全排列，然后把每个排列拼接起来，最后求出拼起来的数字的最小值，<br>易知算法复杂度高达O(n!)，所以不推荐。这里定义一个新的比较规则：<br>对于两个数字m,n，可以拼接成mn和nm。若mn &lt; nm，则定义m &lt; n；若mn &gt; nm，则定义m &gt; n；若mn = nm，则定义m = n<br>将数组中的数按照上述比较规则从小到大进行排序，最后将排序的数组进行拼接即为数组所能拼成的最小数<br>证明见书第一版P179~180</p>
<h3 id="代码-30"><a href="#代码-30" class="headerlink" title="代码"></a>代码</h3><pre><code class="python">class Solution:
    def PrintMinNumber(self, numbers):
        from functools import cmp_to_key
        return &#39;&#39;.join(sorted([str(num) for num in numbers], key = cmp_to_key(lambda x, y: int(x + y) - int(y + x))))
</code></pre>
<h2 id="丑数"><a href="#丑数" class="headerlink" title="丑数"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/34_%E4%B8%91%E6%95%B0.py" target="_blank" rel="external">丑数</a></h2><h3 id="题目描述-31"><a href="#题目描述-31" class="headerlink" title="题目描述"></a>题目描述</h3><p>把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。<br>习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</p>
<h3 id="最优题解-31"><a href="#最优题解-31" class="headerlink" title="最优题解"></a>最优题解</h3><p>创建数组保存已经找到的丑数并排好序，关键在于如何生成下一个丑数<br>数组中最后一个丑数最大，记为M。设置index2，标记该位置的数乘以2大于M，<br>同理设置index3、index5，这样每次只需求<code>min(A[index2] * 2,A[index3] * 3,A[index5] * 5)</code><br>就可求出下一个丑数，然后更新三个标记。<br>这样关键就在于如何更新这三个标记，<br>仔细推敲可以发现其实只需让那些指向的数乘相应因子等于当前M的标记往后移一位即可，<br>因为 <code>M = min(A[index2] * 2,A[index3] * 3,A[index5] * 5)</code>，则至少有个标记是要往后移的，<br>且移一位即可，后面那个数乘以相应的因子一定大于M。<br>那么其他指向的数乘相应因子不等于当前M的标记为什么没有必要移动呢？<br>还是因为 <code>M = min(A[index2] * 2,A[index3] * 3,A[index5] * 5)</code>， 既然M是其中最小的，<br>那么其他的标记所指向的数乘以相应因子一定就比M大了，没有必要更新<br>这样就可以把三个并列的while简化成三个并列的if</p>
<p>这里谈谈为什么要使用这三个index，且为什么这样做可以保证按顺序产生下一个丑数。<br>按照正常的理解，后面的丑数都是由前面已经产生的某个丑数乘2或乘3或乘5得到，<br>为了按照顺序，必须把前面每个丑数乘2或乘3或乘5得到的值中取大于当前最后一个丑数的最小值。<br>那么问题来了，有必要把每个丑数都乘这三个因子然后取最小值？<br>我们发现每个丑数都要经历乘2乘3乘5的过程，但却没有必要在同一次竞争下一个丑数中乘，<br>所以我们反过来，标记上那些需要乘2或乘3或乘5的数，使得index2指向的数就要乘2，<br>因为它在下一次竞争中可能会胜利，index3和index5同理。为了满足以上规则，<br>我们让这三个标记从左向右各自独立遍历，这样也就让每个数都会经历乘2或乘3或乘5的过程，<br>且如果标记的数乘以相应因子后竞争胜利了，那么该标记就要往后挪1位，<br>因为新的丑数是该标记因子乘以它指向的数竞争胜利而生成的，<br>所以该数乘以该因子已经没有参与下一次竞争的机会了，相应的因子标记就该往后挪，<br>使得下一个数参与新的竞争。而其他竞争失败的标记不用动，因为它们还有竞争胜利的机会，<br>毕竟每次胜利的是那个乘积最小的。</p>
<h3 id="代码-31"><a href="#代码-31" class="headerlink" title="代码"></a>代码</h3><pre><code class="python">class Solution:
    def GetUglyNumber(self, index):
        if not index: return 0
        idx2 = idx3 = idx5 = 0
        uglynums = [1]
        for _ in range(index-1):
            uglynums.append(min(uglynums[idx2]*2, uglynums[idx3]*3, uglynums[idx5]*5))
            # 可能会有多个标记竞争胜利，即丑数恰好是前面标记所在值的公倍数
            # 因此必须是并列的if，不能if...elif...else
            if uglynums[-1] == uglynums[idx2]*2: idx2 += 1
            if uglynums[-1] == uglynums[idx3]*3: idx3 += 1
            if uglynums[-1] == uglynums[idx5]*5: idx5 += 1
        return uglynums[-1]
</code></pre>
<h2 id="第一个只出现一次的字符"><a href="#第一个只出现一次的字符" class="headerlink" title="第一个只出现一次的字符"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/35_1_%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6.py" target="_blank" rel="external">第一个只出现一次的字符</a></h2><h3 id="题目描述-32"><a href="#题目描述-32" class="headerlink" title="题目描述"></a>题目描述</h3><p>在一个字符串(1&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置,不存在就返回-1</p>
<h3 id="最优题解-32"><a href="#最优题解-32" class="headerlink" title="最优题解"></a>最优题解</h3><p>时间复杂度O(n)，空间复杂度O(1)（不会超过256个键值对）</p>
<p>利用python的字典建立哈希表，键记录字母，值记录字母出现的次数。<br>第一次遍历建立哈希表，第二次遍历找到第一个值为1的键（字母）。<br>​       </p>
<h3 id="代码-32"><a href="#代码-32" class="headerlink" title="代码"></a>代码</h3><pre><code class="python">from collections import OrderedDict
class Solution:
    def FirstNotRepeatingChar(self, s):
        table = OrderedDict()
        for ch in s:
            table[ch] = table.setdefault(ch, 0) + 1
        for ch, v in table.items():
            if v == 1:
                return s.index(ch)
        return -1
</code></pre>
<h3 id="举一反三-8"><a href="#举一反三-8" class="headerlink" title="举一反三"></a>举一反三</h3><ul>
<li><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/35_2_%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6.py" target="_blank" rel="external">字符串中删除字符</a></li>
<li><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/35_3_%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E7%AC%A6.py" target="_blank" rel="external">删除重复的字符</a></li>
<li><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/35_4_%E5%8F%98%E4%BD%8D%E8%AF%8D.py" target="_blank" rel="external">变位词</a></li>
</ul>
<h2 id="数组中的逆序对"><a href="#数组中的逆序对" class="headerlink" title="数组中的逆序对"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/36_%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9.py" target="_blank" rel="external">数组中的逆序对</a></h2><h3 id="题目描述-33"><a href="#题目描述-33" class="headerlink" title="题目描述"></a>题目描述</h3><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。<br>输入一个数组, 求出这个数组中逆序对的总数</p>
<h3 id="最优题解-33"><a href="#最优题解-33" class="headerlink" title="最优题解"></a>最优题解</h3><p>归并排序，在合并时统计逆序对个数。</p>
<p>设合并的两个数组为a1和a2，用两个指针p1，p2，指向a1和a2的末尾元素，并每次比较两个指针指向的数字。</p>
<p>如果p1数字大于p2，则构成逆序对，并且逆序对的数目等于p2之前的元素个数(包括p2指向的元素)，因为a2是已经排好序的，则p2之前的数都小于p1指向的数。</p>
<p>反之，如果p1数字小于等于p2，则不构成逆序对。每一次比较都把较大的数从后往前复制到一个辅助数组里,确保辅助数组里的数字是递增排序的。</p>
<p>然后把较大的数的指针往前移一位，进行下一轮比较。所以总的逆序对数就是先把数组分隔成子数组，先统计出两个子数组内部的逆序对数，然后统计出两个相邻子数组之间的逆序对数，三者之和。</p>
<h3 id="代码-33"><a href="#代码-33" class="headerlink" title="代码"></a>代码</h3><pre><code class="python">class Solution:
        def merge(data, copy, l, r):
            if l == r: return 0
            m = (l + r) // 2
            # 注意这里的copy和data位置交换了，这样就能保证递归回来时，上一层拿到的data是下一层已经排好序的copy
            left = merge(copy, data, l, m) # 左区域的逆序对个数
            right = merge(copy, data, m + 1, r) # 右区域的逆序对个数
            i, j = m, r  # i初始化为前半段最后一个数字的下标，j初始化为后半段最后一个数字的下标
            count, copyIdx = 0, r
            while i &gt;= l and j &gt;= m + 1:
                # 复制的时候统计两个子数组之间的逆序对数
                if data[i] &gt; data[j]:
                    copy[copyIdx] = data[i]
                    count += j - m  # 逆序对的数目等于j之前的元素个数(包括j指向的元素)
                    i -= 1
                else:
                    copy[copyIdx] = data[j]
                    j -= 1
                copyIdx -= 1
            # 将剩下复制到辅助数组里
            while i &gt;= l:
                copy[copyIdx] = data[i]
                i -= 1
                copyIdx -= 1
            while j &gt;= m + 1:
                copy[copyIdx] = data[j]
                j -= 1
                copyIdx -= 1
            return left + right + count # 总逆序对个数 = 左区域 + 右区域 + 合并

        if not data: return 0
        return merge(data, data[:], 0, len(data) - 1)
</code></pre>
<h2 id="两个链表的第一个公共结点"><a href="#两个链表的第一个公共结点" class="headerlink" title="两个链表的第一个公共结点"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/37_%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E7%BB%93%E7%82%B9.py" target="_blank" rel="external">两个链表的第一个公共结点</a></h2><h3 id="题目描述-34"><a href="#题目描述-34" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入两个单向无环链表，找出它们的第一个公共结点。</p>
<h3 id="最优题解-34"><a href="#最优题解-34" class="headerlink" title="最优题解"></a>最优题解</h3><p>时间复杂度O(m+n)，空间复杂度O(1)。</p>
<p>两个链表指针 p1，p2 从头开始一起遍历，但是p1来到末尾时指向另一个链表的头结点（不是指向原链表的头结点），p2也一样。</p>
<p>这样第一次遍历时，短的链表指针（假如为p1）来到长链表（假如为l2）的头结点，此时p2还在l2上，且p2距离末尾（l2-l1）。</p>
<p>p2来到l1头结点时，p1在l2上距离末尾（l2-(l2-l1)）此时p1的位置正好就是长指针先出发来到二者长度差的位置，下面一起遍历一定能够相遇</p>
<p>即使没有公共结点，也会在None处一起返回（相当于相遇）</p>
<p>整个过程最坏情况下p1、p2各遍历两个链表一次，所以时间复杂度O(m+n)，空间复杂度O(1)。   </p>
<h3 id="代码-34"><a href="#代码-34" class="headerlink" title="代码"></a>代码</h3><pre><code class="python">class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None

class Solution:
    def FindFirstCommonNode(self, pHead1, pHead2):
        cur1, cur2 = pHead1, pHead2
        while cur1 is not cur2:
            cur1 = cur1.next if cur1 else pHead2
            cur2 = cur2.next if cur2 else pHead1
        return cur1
</code></pre>
<h2 id="数字在排序数组中出现的次数"><a href="#数字在排序数组中出现的次数" class="headerlink" title="数字在排序数组中出现的次数"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/38_1_%E6%95%B0%E5%AD%97%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0.py" target="_blank" rel="external">数字在排序数组中出现的次数</a></h2><h3 id="题目描述-35"><a href="#题目描述-35" class="headerlink" title="题目描述"></a>题目描述</h3><p>统计一个数字在排序数组中出现的次数</p>
<h3 id="最优题解-35"><a href="#最优题解-35" class="headerlink" title="最优题解"></a>最优题解</h3><p>既然是排好序的，那么自然想到二分法了。总体思路是找到第一个k的位置，再找到最后一个k的位置，相减加一。<br>先查找第一个k的位置：<br>如果中间的数字比k大，那么k只可能出现在数组的前半段，下一轮就只在数组的前半段查找就可以了。<br>如果中间的数字比k小，那么k只可能出现在数组的后半段，下一轮就只在数组的后半段查找就可以了。<br>关键是如果中间的数字等于k呢？我们先判断该数字是不是第一个k。<br>如果中间数字前面不是k，则该中间数字刚好就是第一个k；<br>如果中间数字前面也是k，则第一个k肯定在数组前半段，下一轮我们仍然需要在数组前半段查找。O(logn)</p>
<h3 id="代码-35"><a href="#代码-35" class="headerlink" title="代码"></a>代码</h3><pre><code class="python">class Solution:
    def GetNumberOfK(self, data, k):
        def firstK():
            l , r = 0 , len(data) - 1
            while l &lt;= r:
                m = l + ((r - l) &gt;&gt; 1)
                if data[m] &lt; k:
                    l = m + 1
                elif data[m] &gt; k:
                    r = m - 1
                else:
                    if m == 0 or data[m - 1] &lt; k:
                        return m
                    else:
                        r = m - 1
            return -1

        def lastK():
            l , r = 0 , len(data) - 1
            while l &lt;= r:
                m = l + ((r - l) &gt;&gt; 1)
                if data[m] &lt; k:
                    l = m + 1
                elif data[m] &gt; k:
                    r = m - 1
                else:
                    if m == len(data) - 1 or data[m + 1] &gt; k:
                        return m
                    else:
                        l = m + 1
            return -1

        if not data: return 0
        first, last = firstK(), lastK()
        return last - first + 1 if first != -1 else 0
</code></pre>
<h3 id="举一反三-9"><a href="#举一反三-9" class="headerlink" title="举一反三"></a>举一反三</h3><ul>
<li><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/38_2_%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97.py" target="_blank" rel="external">缺失的数字</a></li>
<li><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/38_3_%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%80%BC%E5%92%8C%E4%B8%8B%E6%A0%87%E7%9B%B8%E7%AD%89%E7%9A%84%E5%85%83%E7%B4%A0.py" target="_blank" rel="external">数组中数值和下标相等的元素</a></li>
</ul>
<h2 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/39_1_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6.py" target="_blank" rel="external">二叉树的深度</a></h2><h3 id="题目描述-36"><a href="#题目描述-36" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一棵二叉树，求该树的深度。<br>从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p>
<h3 id="最优题解-36"><a href="#最优题解-36" class="headerlink" title="最优题解"></a>最优题解</h3><p>递归实现，树的深度=max(左子树深度，右子树深度)+1</p>
<h3 id="代码-36"><a href="#代码-36" class="headerlink" title="代码"></a>代码</h3><pre><code class="python">class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution:
    def TreeDepth(self, pRoot):
        if not pRoot: return 0
        return max(self.TreeDepth1(pRoot.left), self.TreeDepth1(pRoot.right)) + 1
</code></pre>
<h2 id="判断平衡二叉树"><a href="#判断平衡二叉树" class="headerlink" title="判断平衡二叉树"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/39_2_%E5%88%A4%E6%96%AD%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.py" target="_blank" rel="external">判断平衡二叉树</a></h2><h3 id="题目描述-37"><a href="#题目描述-37" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一棵二叉树，判断该二叉树是否是平衡二叉树。<br>注：平衡二叉树任意结点的左右子树深度相差不超过1，空树算平衡二叉树</p>
<h3 id="最优题解-37"><a href="#最优题解-37" class="headerlink" title="最优题解"></a>最优题解</h3><p>根据后序遍历的特点，当遍历到某一结点时该结点的左右子树已经遍历结束。<br>因此在遍历每个结点的时候记录以它为根节点的树的深度，这样在遍历到某个结点时<br>既知道了左右子树的深度，也知道左右子树是否为平衡二叉树(递归)，即一边计算深度一边判断是否平衡。<br>书上用变量left和right来单独表示左右子树的深度，函数返回的是true或者false，<br>其实不用这两个变量，我们直接把树的深度返回即可，这样根节点可直接拿到左右子树的深度，<br>因为我们注意到深度总是大于等于0的，所以我们只需定义当子树不平衡时返回-1即可，<br>这样根节点也就可以通过左右子树返回的深度是否大于等于0来间接判断左右子树是否平衡</p>
<h3 id="代码-37"><a href="#代码-37" class="headerlink" title="代码"></a>代码</h3><pre><code class="python">class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution:
    def IsBalanced_Solution(self, pRoot):
        def isBalanced(root):
            if root is None: return 0
            left = isBalanced(root.left)
            if left == -1: return -1 # 提前返回，不用遍历右子树了
            right = isBalanced(root.right)
            if right == -1 or abs(left - right) &gt; 1: return -1
            return max(left, right) + 1
        return isBalanced(pRoot) &gt;= 0
</code></pre>
<h2 id="数组中只出现一次的两个数字"><a href="#数组中只出现一次的两个数字" class="headerlink" title="数组中只出现一次的两个数字"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/40_1_%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97%EF%BC%88%E5%85%B6%E4%BB%96%E5%87%BA%E7%8E%B02%E6%AC%A1%EF%BC%89.py" target="_blank" rel="external">数组中只出现一次的两个数字</a></h2><h3 id="题目描述-38"><a href="#题目描述-38" class="headerlink" title="题目描述"></a>题目描述</h3><p>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</p>
<h3 id="最优题解-38"><a href="#最优题解-38" class="headerlink" title="最优题解"></a>最优题解</h3><p>时间复杂度O(n)，空间复杂度O(1)</p>
<p>既然其他的数字都出现了两次，那么可以把数组中所有数异或，则两次的相互抵消，一次的相互异或，<br>即最终的异或结果相当于两个出现一次的数相异或。如果只有一个数字是出现一次的，<br>那么异或结果就是那个数了，但这里有两个，于是我们想着把它俩给分开，使得各自在一个数组里，<br>且每个数组除了那个出现一次的数以外其他数都是出现两次，这样两个数组分别异或就可以找出这两个数了。<br>关键是如何把它俩分开且数组里其他数都是成双成对？我们仍然把整个数组相异或，<br>得到的结果一定不为0（因为这两个数一定不一样），那么二进制中一定有一个位置为1。<br>那么我们可以以最右边的1为标准，把整个数组中该位为1的数划分为一组，为0的划分为一组。这样做一举两得：<br>一来把那两个出现一次的数分开了，<br>二来把成对的数放在了同一个数组里了（因为相同的数其二进制位一致）。<br>我们其实还可以再优化一下：在第二次循环时，只需把标准位是1的数异或起来就可以了，<br>那么最终结果就是那两个数字中的一个，此时把该数与第一次循环的异或结果再次异或就可以拿到另一个数了</p>
<h3 id="代码-38"><a href="#代码-38" class="headerlink" title="代码"></a>代码</h3><pre><code class="python">class Solution:
    # 返回[a,b] 其中ab是出现一次的两个数字
    def FindNumsAppearOnce(self, array):
        xor_sum = a = 0
        for i in array:
            xor_sum ^= i
        last1 = xor_sum &amp; -xor_sum  # 取出最右边的1
        for i in array:
            if i &amp; last1:
                a ^= i
        return [a, a ^ xor_sum]
</code></pre>
<h3 id="举一反三-10"><a href="#举一反三-10" class="headerlink" title="举一反三"></a>举一反三</h3><p><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/40_2_%E6%95%B0%E7%BB%84%E4%B8%AD%E5%94%AF%E4%B8%80%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97%EF%BC%88%E5%85%B6%E4%BB%96%E5%87%BA%E7%8E%B03%E6%AC%A1%EF%BC%89.py" target="_blank" rel="external">数组中唯一只出现一次的数字（其他出现3次）</a></p>
<h2 id="和为s的两个数字"><a href="#和为s的两个数字" class="headerlink" title="和为s的两个数字"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/41_1_%E5%92%8C%E4%B8%BAs%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97.py" target="_blank" rel="external">和为s的两个数字</a></h2><h3 id="题目描述-39"><a href="#题目描述-39" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，<br>如果有多对数字的和等于S，输出乘积最小的两个数。<br>对应每个测试案例，输出两个数，小的先输出。</p>
<h3 id="最优题解-39"><a href="#最优题解-39" class="headerlink" title="最优题解"></a>最优题解</h3><p>双指针，左右夹逼。<br>设置两个指针分别指向第一个和最后一个数，如果它们的和等于s，我们就找到了这两个数；<br>如果小于s，由于数组已经排好序，所以只需让较小数的指针往后移；如果大于s，<br>则让较大数的指针往前移。最终找到的第一对就是乘积最大的</p>
<h3 id="代码-39"><a href="#代码-39" class="headerlink" title="代码"></a>代码</h3><pre><code class="python">class Solution:
    def FindNumbersWithSum3(self, array, sum):
        if array: 
            l , r = 0, len(array) - 1
            while l &lt; r: # 当 l==r 时，指向同一个数，则不再是不同位置的两个数，结束循环
                if array[l] + array[r] &lt; tsum:
                    l += 1
                elif array[l] + array[r] &gt; tsum:
                    r -= 1
                else:
                    return [array[l], array[r]]
        return []
</code></pre>
<h2 id="和为s的连续正整数序列"><a href="#和为s的连续正整数序列" class="headerlink" title="和为s的连续正整数序列"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/41_2_%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B4%E6%95%B0%E5%BA%8F%E5%88%97.py" target="_blank" rel="external">和为s的连续正整数序列</a></h2><h3 id="题目描述-40"><a href="#题目描述-40" class="headerlink" title="题目描述"></a>题目描述</h3><p>找出所有和为S的连续正整数序列(至少含有两个数)。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序</p>
<h3 id="最优题解-40"><a href="#最优题解-40" class="headerlink" title="最优题解"></a>最优题解</h3><p>双指针问题</p>
<p>用两个数small和big分别表示序列的最小值和最大值。首先把small初始化为1，big初始化为2。<br>如果从small到big的序列的和大于s，可以从序列中去掉较小值，也就是增大small的值。<br>如果从small到big的序列的和小于s，可以增大big，让序列包含更多的数字。<br>因为序列至少要有两个连续的数字，所以small的上限是(s-1)/2，big的上限是(s-1)/2+1</p>
<h3 id="代码-40"><a href="#代码-40" class="headerlink" title="代码"></a>代码</h3><pre><code class="python">class Solution:
    def FindContinuousSequence(self, sum):
        if sum &lt; 3: return []
        l, r, curSum = 1, 2, 3
        lTop = (sum - 1) // 2
        rTop = lTop + 1
        res = []
        while r &lt;= rTop:
            while l &lt;= lTop and curSum &gt; sum:
                curSum -= l  # 先减再右移
                l += 1
            if curSum == sum:
                res.append(list(range(l, r + 1)))
            r += 1  # 如果curSum &lt; sum，那么r后移；如果找到了一个序列，那么r也后移继续寻找下一个序列
            curSum += r  # 先右移再加
        return res
</code></pre>
<h2 id="翻转单词顺序"><a href="#翻转单词顺序" class="headerlink" title="翻转单词顺序"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/42_1_%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F.py" target="_blank" rel="external">翻转单词顺序</a></h2><h3 id="题目描述-41"><a href="#题目描述-41" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个英文句子, 翻转句子中单词的顺序,但单词内字符的顺序不变<br>为简单起见, 标点符号和前面的单词属于同一个单词</p>
<h3 id="最优题解-41"><a href="#最优题解-41" class="headerlink" title="最优题解"></a>最优题解</h3><p>两次翻转，第一次整体翻转，第二次每个单词再翻转（也可以先每个单词翻转然后整体翻转）</p>
<h3 id="代码-41"><a href="#代码-41" class="headerlink" title="代码"></a>代码</h3><pre><code class="python">class Solution:
    def ReverseSentence(self, s):
        return &#39; &#39;.join(w[::-1] for w in s[::-1].split(&#39; &#39;))
</code></pre>
<h2 id="左旋转字符串"><a href="#左旋转字符串" class="headerlink" title="左旋转字符串"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/42_2_%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88%E5%BE%AA%E7%8E%AF%E5%B7%A6%E7%A7%BB%EF%BC%89.py" target="_blank" rel="external">左旋转字符串</a></h2><h3 id="题目描述-42"><a href="#题目描述-42" class="headerlink" title="题目描述"></a>题目描述</h3><p>汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。<br>对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。<br>例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。</p>
<h3 id="最优题解-42"><a href="#最优题解-42" class="headerlink" title="最优题解"></a>最优题解</h3><p>先分片后拼接</p>
<h3 id="代码-42"><a href="#代码-42" class="headerlink" title="代码"></a>代码</h3><pre><code class="python">class Solution:
    def LeftRotateString(self, s, n):
        if not s: return &#39;&#39;
        return s[n%len(s):] + s[:n%len(s)] # 考虑重复左移，所以n % len(s)
</code></pre>
<h2 id="n个骰子的点数"><a href="#n个骰子的点数" class="headerlink" title="n个骰子的点数"></a><a href="n%E4%B8%AA%E9%AA%B0%E5%AD%90%E7%9A%84%E7%82%B9%E6%95%B0">n个骰子的点数</a></h2><h3 id="题目描述-43"><a href="#题目描述-43" class="headerlink" title="题目描述"></a>题目描述</h3><p>把n个骰子扔在地上, 所有骰子朝上一面的点数和为s。<br>输入n, 打印出s的所有可能的值出现的次数（原题要求输出概率，为了方便这里只需输出次数）</p>
<h3 id="最优题解-43"><a href="#最优题解-43" class="headerlink" title="最优题解"></a>最优题解</h3><p>设n个骰子投掷点数和为s的出现次数是F(n, s)，<br>则F(n, s)等于(n-1)个骰子投掷的点数和为s-1、s-2、s-3、s-4、s-5、s-6时的次数的总和：<br>即 F(n, s) = F(n - 1, s - 1) + F(n - 1, s - 2) + F(n - 1, s - 3)  + F(n - 1, s - 4) + F(n - 1, s - 5) + F(n - 1, s - 6)。<br>所有的和出现次数总和为6^n，概率为F(n, s)/6^n。(n &lt;= s &lt;= 6n)</p>
<h3 id="代码-43"><a href="#代码-43" class="headerlink" title="代码"></a>代码</h3><pre><code class="python">class Solution:
    def DicesProbability(self, n):
        if not n or n &lt; 1:
            return
        maxVal = 6
        count = [[0] * (maxVal * n + 1), []]  # 构造两个数组来存放每一个和出现的次数，下标表示和，里面的值代表次数
        flag = 0  # 用flag来反复利用这两个数组
        for i in range(1, maxVal + 1):  # 一开始只有一个骰子，当然次数都为1
            count[flag][i] = 1
        for i in range(2, n + 1):  # 逐渐加入其他骰子
            # 一开始另一个数组要初始化为0，因为每加入一个骰子就会使前面的和次数成为0
            # 比如，先是1个骰子时和为1的次数为1，当加入第二个骰子时，和为1是不可能出现的
            # 换句话说，就是和的范围是动态变化的，且一直往右移
            count[1 - flag] = [0] * (maxVal * n + 1)
            for j in range(i, maxVal * i + 1):  # i &lt;= s &lt;= 6*i
                k = 1
                while k &lt;= j and k &lt;= maxVal:
                    # F(n, s) = F(n - 1, s - 1) + F(n - 1, s - 2) + F(n - 1, s - 3) + F(n - 1, s - 4) + F(n - 1, s - 5) + F(n - 1, s - 6)
                    count[1 - flag][j] += count[flag][j - k]
                    k += 1
            flag = 1 - flag  # 将flag更新，flag永远指向求和好的数组
        return [(i, count[flag][i]) for i in range(n, maxVal * n + 1)]
</code></pre>
<h2 id="扑克牌的顺子"><a href="#扑克牌的顺子" class="headerlink" title="扑克牌的顺子"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/44_%E6%89%91%E5%85%8B%E7%89%8C%E7%9A%84%E9%A1%BA%E5%AD%90.py" target="_blank" rel="external">扑克牌的顺子</a></h2><h3 id="题目描述-44"><a href="#题目描述-44" class="headerlink" title="题目描述"></a>题目描述</h3><p>从扑克牌中随机抽取5张牌，判断是不是顺子，即这5张牌是不是连续的。2~10为数字本身，A为1，J~K为11~13，<br>而大小王可以看成任意数字。为方便起见这里把大小王看成0，且规定含有对子时不为顺子。<br>注意：这里大小王的个数不限，且输入参数的AJQK和大小王已经转换成相应数字</p>
<h3 id="最优题解-44"><a href="#最优题解-44" class="headerlink" title="最优题解"></a>最优题解</h3><p>时间O(n)，空间n(1)</p>
<ol>
<li>除0外没有重复的数(用位图来记录每个出现过的数字)，</li>
<li>max - min &lt; 5 （由于max和min动态变化，但最终max-min=4）</li>
</ol>
<h3 id="代码-44"><a href="#代码-44" class="headerlink" title="代码"></a>代码</h3><pre><code class="python">class Solution:
    def IsContinuous1(self, numbers):
        if not numbers or len(numbers) != 5:
            return False
        # 把A、J、Q、K转化一下
        # transDict = {&#39;A&#39;: 1, &#39;J&#39;: 11, &#39;Q&#39;: 12, &#39;K&#39;: 13}
        # for i in range(len(numbers)):
        #     if numbers[i] in transDict.keys():
        #         numbers[i] = transDict[numbers[i]]
        min = 14
        max = -1
        flag = 0  # 用位图来记录每个出现过的数字
        for i in range(len(numbers)):
            number = numbers[i]
            if number &lt; 0 or number &gt; 13: return False
            if number == 0: continue
            if ((flag &gt;&gt; number) &amp; 1) == 1: return False  # 如果出现过，那么再次出现就是对子了
            flag |= (1 &lt;&lt; number)  # 记录出现过的数字
            if number &gt; max: max = number
            if number &lt; min: min = number
            if max - min &gt;= 5: return False
        return True
</code></pre>
<h2 id="圆圈中最后剩下的数字（约瑟夫环问题）"><a href="#圆圈中最后剩下的数字（约瑟夫环问题）" class="headerlink" title="圆圈中最后剩下的数字（约瑟夫环问题）"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/45_%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97%EF%BC%88%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E9%97%AE%E9%A2%98%EF%BC%89.py" target="_blank" rel="external">圆圈中最后剩下的数字（约瑟夫环问题）</a></h2><h3 id="题目描述-45"><a href="#题目描述-45" class="headerlink" title="题目描述"></a>题目描述</h3><p>0, 1, 2, n-1这n个数字排成一个圆环, 从数字0开始每次从这个圆圈里删除第m个数字<br>求这个圆圈中最后剩下的一个数字。</p>
<h3 id="最优题解-45"><a href="#最优题解-45" class="headerlink" title="最优题解"></a>最优题解</h3><p>时间O(n)，空间O(1)</p>
<p>推导递归公式。定义f(n,m)表示每次在n个数字0，1，…，n-1中每次删除第m个数字最后剩下的数字，则有递归公式：</p>
<p>f(n,m) = [f(n-1,m)+m]%n  if n&gt;1；0  if n=1</p>
<p>具体推导过程直接看书P230~231</p>
<h3 id="代码-45"><a href="#代码-45" class="headerlink" title="代码"></a>代码</h3><pre><code class="python">class Solution:
    # 循环实现
    def LastRemaining(self, n, m):
        if not n or not m:
            return -1
        last = 0
        for i in range(2, n + 1):
            last = (last + m) % i
        return last
</code></pre>
<h2 id="求前n项和（各种限制）"><a href="#求前n项和（各种限制）" class="headerlink" title="求前n项和（各种限制）"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/46_%E6%B1%82%E5%89%8Dn%E9%A1%B9%E5%92%8C%EF%BC%88%E5%90%84%E7%A7%8D%E9%99%90%E5%88%B6%EF%BC%89.py" target="_blank" rel="external">求前n项和（各种限制）</a></h2><h3 id="题目描述-46"><a href="#题目描述-46" class="headerlink" title="题目描述"></a>题目描述</h3><p>求1+2+3+…+n，<br>要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p>
<h3 id="最优题解-46"><a href="#最优题解-46" class="headerlink" title="最优题解"></a>最优题解</h3><p>利用and运算的短路原则退出递归</p>
<h3 id="代码-46"><a href="#代码-46" class="headerlink" title="代码"></a>代码</h3><pre><code class="python">class Solution:
    def Sum(self, n):
        return n and (n + self.Sum(n - 1))
</code></pre>
<h2 id="不用加减乘除做加法"><a href="#不用加减乘除做加法" class="headerlink" title="不用加减乘除做加法"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/47_%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95.py" target="_blank" rel="external">不用加减乘除做加法</a></h2><h3 id="题目描述-47"><a href="#题目描述-47" class="headerlink" title="题目描述"></a>题目描述</h3><p>写一个函数，求两个整数之和，要求在函数体内不得使用+、-、 *  、/四则运算符号</p>
<h3 id="最优题解-47"><a href="#最优题解-47" class="headerlink" title="最优题解"></a>最优题解</h3><p>位运算，<br>1.两个数异或：相当于每一位相加，而不考虑进位；<br>2.两个数相与，并左移一位：相当于求得进位；<br>3.将上述两步的结果相加：相当于重复执行上述两步，直到不产生进位<br>由于python的整型是无限位数的，所以有可能导致不断进位，所以需要截取后32位，即&amp;0xffffffff<br>但这样就会导致和为负数时由于截取使得结果为正数，所以需要检查一下如果结果的最高位为1，<br>说明结果为负数，需要将最高位左边所有的0变为1，这样就可以变为负数，然后按照补码转换成正确的数值<br>(无需进行补码转换，机器内部自动转换)。也就是说需要保持右边32位不变而左边所有位取反，<br>所以可以先把右边32位局部取反，然后整体取反。局部取反可以^0xffffffff，而整体取反直接~</p>
<h3 id="代码-47"><a href="#代码-47" class="headerlink" title="代码"></a>代码</h3><pre><code class="python">class Solution:
    def Add(self, num1, num2):
        mask = 0xffffffff
        while num2:
            num1, num2 = (num1 ^ num2) &amp; mask, ((num1 &amp; num2) &lt;&lt; 1) &amp; mask
        return num1 if num1 &gt;&gt; 31 == 0 else ~(num1 ^ mask)
</code></pre>
<h2 id="把字符串转换成整数"><a href="#把字符串转换成整数" class="headerlink" title="把字符串转换成整数"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/49_%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E6%95%B0.py" target="_blank" rel="external">把字符串转换成整数</a></h2><h3 id="题目描述-48"><a href="#题目描述-48" class="headerlink" title="题目描述"></a>题目描述</h3><p>将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0</p>
<h3 id="最优题解-48"><a href="#最优题解-48" class="headerlink" title="最优题解"></a>最优题解</h3><p>考虑这么几点：<br>1、有无正负号<br>2、只有正负号<br>3、多个正负号开头<br>4、空串或None<br>5、非法字符<br>由于python整型无限长，所以不考虑正负溢出<br>（一般对于32位整型来讲，最大正整数是0x7fffffff，最小负整数是0x80000000）</p>
<h3 id="代码-48"><a href="#代码-48" class="headerlink" title="代码"></a>代码</h3><pre><code class="python">class Solution:
    def StrToInt(self, s):
        if not s:
            return 0
        start = 0  # 标记开始转换的位置
        minus = False  # 标记正负
        if s[0] == &#39;-&#39;:
            start = 1
            minus = True
        elif s[0] == &#39;+&#39;:
            start = 1
        sum = 0
        for i in range(start, len(s)):
            if s[i] &lt; &#39;0&#39; or s[i] &gt; &#39;9&#39;:  # 含有非法字符返回0
                return 0
            sum = sum * 10 + ord(s[i]) - ord(&#39;0&#39;)
        return -1 * sum if minus else sum
</code></pre>
<h2 id="二叉树的最低公共祖先"><a href="#二叉树的最低公共祖先" class="headerlink" title="二叉树的最低公共祖先"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/50_3_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E4%BD%8E%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.py" target="_blank" rel="external">二叉树的最低公共祖先</a></h2><h3 id="题目描述-49"><a href="#题目描述-49" class="headerlink" title="题目描述"></a>题目描述</h3><p>找出二叉树中两个结点的最低公共祖先（没有指向父节点的指针）</p>
<h3 id="最优题解-49"><a href="#最优题解-49" class="headerlink" title="最优题解"></a>最优题解</h3><p>结束递归：<br>如果遇到了目标节点就返回那个目标节点，表示找到了该结点；<br>如果是None就返回None，表示没有找到。<br>继续递归：<br>既不是None也不是目标节点，说明要接着递归往下左右子树遍历，<br>收集下面传上来的有关子树中出现目标节点的信息<br>处理递归返回的信息：<br>如果左子树、右子树都有找到，说明自己就是最小公共祖先了，返回本身；<br>只有一边找到，则说明自己不是最小公共祖先，而是在最小公共祖先的上面，<br>且间接说明这个传上来的结点就是最小公共祖先，把这个传上来的结点继续往上传；<br>两边都没有找到则直接返回None，表示没有找到。</p>
<h3 id="代码-49"><a href="#代码-49" class="headerlink" title="代码"></a>代码</h3><pre><code class="python">class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution:
    def findParent(self, root, pNode1, pNode2):
        if root in {None, pNode1, pNode2}: return root
        left = self.findParent(root.left, pNode1, pNode2)
        right = self.findParent(root.right, pNode1, pNode2)
        return root if left and right else left or right
</code></pre>
<h3 id="举一反三-11"><a href="#举一反三-11" class="headerlink" title="举一反三"></a>举一反三</h3><ul>
<li><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/50_1_%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E4%BD%8E%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.py" target="_blank" rel="external">二叉搜索树的最低公共祖先</a></li>
<li><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/50_2_%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E4%BD%8E%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.py" target="_blank" rel="external">满二叉树的最低公共祖先</a></li>
</ul>
<h2 id="数组中重复的数字"><a href="#数组中重复的数字" class="headerlink" title="数组中重复的数字"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/51_%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97.py" target="_blank" rel="external">数组中重复的数字</a></h2><h3 id="题目描述-50"><a href="#题目描述-50" class="headerlink" title="题目描述"></a>题目描述</h3><p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。<br>数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。<br>请找出数组中重复的数字，没有则返回-1。<br>例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是重复的数字2或者3。</p>
<h3 id="最优题解-50"><a href="#最优题解-50" class="headerlink" title="最优题解"></a>最优题解</h3><p>时间O(n), 空间O(1)</p>
<p>由于长度为n的数组里的所有数字都在0到n-1的范围内，所以如果没有重复数字的话，<br>那么从小到大排序后的数组每个数和它的下标应该是相等的。所以我们只需从头遍历数组，<br>看每个数字和它下标是否相等，相等就遍历下一个，<br>不相等就和它应该在的位置上（下标和它相等）的数字交换，<br>交换前先检查一下如果那个数字和它相等那么就找到了重复数字了，并且没有必要交换，遍历下一个。</p>
<h3 id="代码-50"><a href="#代码-50" class="headerlink" title="代码"></a>代码</h3><pre><code class="python">class Solution:
    # 返回重复数字的列表
    def duplicate(self, nums):
        if not nums: return -1
        i, res = 0, []
        while i &lt; len(nums):
            idx = nums[i]
            if i == idx:
                i += 1
            elif nums[i] == nums[idx]:
                res.append(nums[i])
                i += 1
            else:  # 只是交换，i不移动，因为交换过来的数还未检测
                nums[i], nums[idx] = nums[idx], nums[i]
        return res if res else -1
</code></pre>
<h2 id="构建乘积数组"><a href="#构建乘积数组" class="headerlink" title="构建乘积数组"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/52_%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84.py" target="_blank" rel="external">构建乘积数组</a></h2><h3 id="题目描述-51"><a href="#题目描述-51" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1]<br>使得B中的元素B[i]=A[0]*A<a href="https://github.com/Hk4Fun/algorithm_offer/tree/master/target_offer" target="_blank" rel="external">1</a>*…*A[i-1]*A[i+1]*…*A[n-1]，不能使用除法。</p>
<h3 id="最优题解-51"><a href="#最优题解-51" class="headerlink" title="最优题解"></a>最优题解</h3><p>时间O(n)，空间O(1)</p>
<p>把B[i]拆成前i项和后（n-i）项，分别求乘积，再相乘<br>即B[i]=C[i]*D[i]=(A[0]*A<a href="https://github.com/Hk4Fun/algorithm_offer/tree/master/target_offer" target="_blank" rel="external">1</a>* …*A[i-1])*(A[i+1]*…*A[n-1])<br>而C[i]=C[i-1]*A[i-1], D[i]=D[i+1]*A[i+1]<br>同时利用数组B的空间来节省数组C和D的空间</p>
<h3 id="代码-51"><a href="#代码-51" class="headerlink" title="代码"></a>代码</h3><pre><code class="python">class Solution:
    def multiply(self, A):
        if not A or len(A) == 1:
            return
        length = len(A)
        B = [1]
        for i in range(1, length):
            B.append(B[i - 1] * A[i - 1])  # 自上而下计算上三角
        tmp = 1
        for i in range(length - 2, -1, -1):
            tmp *= A[i + 1]  # 自下而上计算下三角
            B[i] *= tmp  # B[i]=C[i]*D[i]
        return B
</code></pre>
<h2 id="正则表达式匹配"><a href="#正则表达式匹配" class="headerlink" title="正则表达式匹配"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/53_%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D.py" target="_blank" rel="external">正则表达式匹配</a></h2><h3 id="题目描述-52"><a href="#题目描述-52" class="headerlink" title="题目描述"></a>题目描述</h3><p>请实现一个函数用来匹配包括’.’和’*‘的正则表达式。<br>模式中的字符’.’表示任意一个字符，而’ <em> ‘表示它前面的字符可以出现任意次（包含0次）。<br>在本题中，匹配是指字符串的所有字符匹配整个模式。<br>例如，字符串”aaa”与模式”a.a”和”ab\</em>ac*a”匹配，但是与”aa.a”和”ab*a”均不匹配</p>
<h3 id="最优题解-52"><a href="#最优题解-52" class="headerlink" title="最优题解"></a>最优题解</h3><p>当模式中的第二个字符是“*”时：<br>如果字符串第一个字符跟模式第一个字符不匹配，则模式后移2个字符，字符串不变，继续匹配；<br>如果字符串第一个字符跟模式第一个字符匹配，可以有3种匹配方式：<br>1、字符串后移1字符，模式不变，即继续匹配字符下一位，因为*可以匹配多位；<br>2、模式后移2字符，字符串不变，相当于x*被忽略；<br>3、字符串后移1字符，模式后移2字符；<br>其中第三种情况可以由前两种组合，所以可以省略<br>而当模式中的第二个字符不是“*”时：<br>1、如果字符串第一个字符和模式中的第一个字符相匹配，那么字符串和模式都后移一个字符，接着匹配剩余的。<br>2、如果字符串第一个字符和模式中的第一个字符相不匹配，直接返回false。</p>
<h3 id="代码-52"><a href="#代码-52" class="headerlink" title="代码"></a>代码</h3><pre><code class="python">class Solution:
    def match(self, s, pattern):
        if s == None or pattern == None:
            return False
        if s == &#39;&#39; and pattern == &#39;&#39;:
            return True
        if s != &#39;&#39; and pattern == &#39;&#39;:
            return False
        if len(pattern) &gt; 1 and pattern[1] == &#39;*&#39;:
            if s != &#39;&#39; and (pattern[0] == s[0] or pattern[0] == &#39;.&#39;):
                return self.match1(s[1:], pattern) \
                       or self.match1(s, pattern[2:]) \
                    # or self.match(s[1:], pattern[2:]) # 该情况可以由前两种情况组合，所以可以省略
            else:
                return self.match1(s, pattern[2:])
        if s != &#39;&#39; and (s[0] == pattern[0] or pattern[0] == &#39;.&#39;):
            return self.match1(s[1:], pattern[1:])
        return False
</code></pre>
<h2 id="表示数值的字符串"><a href="#表示数值的字符串" class="headerlink" title="表示数值的字符串"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/54_%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2.py" target="_blank" rel="external">表示数值的字符串</a></h2><h3 id="题目描述-53"><a href="#题目描述-53" class="headerlink" title="题目描述"></a>题目描述</h3><p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。<br>例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。<br>但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。</p>
<h3 id="最优题解-53"><a href="#最优题解-53" class="headerlink" title="最优题解"></a>最优题解</h3><p>数字的格式可以用A[.[B]][e|EC]或者.B[e|EC]表示，其中A和C都是整数（可以有正负号，也可以没有），<br>而B是一个无符号整数。考虑这么几种情况：<br>对于小数点’.’，前后A和B的出现形成或的关系：</p>
<ol>
<li>小数可以没有整数部分，例如.123等于0.123；</li>
<li>小数点后面可以没有数字，例如233.等于233.0；</li>
<li>当然小数点前面和后面可以有数字，例如233.666</li>
<li>但不能单独出现小数点’.’<br>对于指数符号e或E，前后形成与的关系：<br>当e或E前面没有数字时，整个字符串不能表示数字，例如.e1、e1；<br>当e或E后面没有整数时，整个字符串不能表示数字，例如12e、12e+5.4</li>
</ol>
<h3 id="代码-53"><a href="#代码-53" class="headerlink" title="代码"></a>代码</h3><pre><code class="python">class Solution:
    def isNumeric1(self, s):
        import re # 使用内置的re标准库快速匹配
        if s:
            return True if re.match(r&#39;^[+-]?(\d+|(\.\d+)|(\d+\.)|(\d+\.\d+))([eE][+-]?\d+)?$&#39;, s) else False
        return False

    def isNumeric2(self, s): # 自己造轮子
        def scanUnsignedInteger(s):
            beforeLength = len(s)
            while s and s[0] &gt;= &#39;0&#39; and s[0] &lt;= &#39;9&#39;:
                s.pop(0)
            return len(s) &lt; beforeLength

        def scanInteger(s):
            if s and (s[0] == &#39;+&#39; or s[0] == &#39;-&#39;):
                s.pop(0)
            return scanUnsignedInteger(s)

        if not s:
            return False
        s = list(s)
        numeric = scanInteger(s)
        if s and s[0] == &#39;.&#39;:
            s.pop(0)
            numeric = scanUnsignedInteger(s) or numeric

        if s and (s[0] == &#39;e&#39; or s[0] == &#39;E&#39;):
            s.pop(0)
            numeric = scanInteger(s) and numeric
        return numeric and s == []
</code></pre>
<h2 id="字符流中第一个不重复的字符"><a href="#字符流中第一个不重复的字符" class="headerlink" title="字符流中第一个不重复的字符"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/55_%E5%AD%97%E7%AC%A6%E6%B5%81%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E7%AC%A6.py" target="_blank" rel="external">字符流中第一个不重复的字符</a></h2><h3 id="题目描述-54"><a href="#题目描述-54" class="headerlink" title="题目描述"></a>题目描述</h3><p>请实现一个函数用来找出字符流中第一个只出现一次的字符。<br>例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。<br>当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。<br>如果当前字符流没有存在出现一次的字符，返回#字符。</p>
<h3 id="最优题解-54"><a href="#最优题解-54" class="headerlink" title="最优题解"></a>最优题解</h3><p>哈希表值表示该字符在字符流中首次出现的位置，另外用index来记录目前读取的字符流的位置<br>读取字符时在相应的哈希表位置上看一下是否&gt;=0(哈希表初始化为-1)，<br>如果是说明该字符之前出现过，则把值更新为-2，表示该字符重复出现；<br>否则说明是第一次出现，把值更新为该字符的出现的位置index<br>找出当前第一个出现一次的字符时只需扫描整个哈希表，找出最小的大于等于0的值（在字符流中首次出现的位置）对应字符返回即可</p>
<h3 id="代码-54"><a href="#代码-54" class="headerlink" title="代码"></a>代码</h3><pre><code class="python">class Solution:
    def __init__(self):
        self.hashList = [-1] * 256
        self.index = 0

    def Insert(self, char):
        asc = ord(char)
        if self.hashList[asc] == -1:
            self.hashList[asc] = self.index
        elif self.hashList[asc] &gt;= 0:
            self.hashList[asc] = -2
        self.index += 1

    def FirstAppearingOnce(self):
        ch = &#39;#&#39;
        minIndex = float(&quot;inf&quot;)
        for i in range(256):
            if 0 &lt;= self.hashList[i] &lt; minIndex:
                ch = chr(i)
                minIndex = self.hashList[i]
        return ch
</code></pre>
<h2 id="链表中环的入口结点"><a href="#链表中环的入口结点" class="headerlink" title="链表中环的入口结点"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/56_%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E7%BB%93%E7%82%B9.py" target="_blank" rel="external">链表中环的入口结点</a></h2><h3 id="题目描述-55"><a href="#题目描述-55" class="headerlink" title="题目描述"></a>题目描述</h3><p>一个链表中包含环，请找出该链表的环的入口结点。</p>
<h3 id="最优题解-55"><a href="#最优题解-55" class="headerlink" title="最优题解"></a>最优题解</h3><p>先判断是否含环，可以用快慢指针实现，慢指针一次走一步，快指针一次走两步，当两个指针相遇时说明链表含环。</p>
<p>然后把两个指针中的一个指向链表头结点，另一个保持在相遇点，接着两个指针以相同的速度（一次一步）遍历，直到二者再次相遇，该相遇点就是环的入口，理论证明见：<a href="https://github.com/Hk4Fun/algorithm_offer/blob/0d2880630af2dd75213f11c852b0a0e785efeadd/target_offer/15_4_%E5%90%AB%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E5%85%A5%E5%8F%A3%E7%82%B9.py" target="_blank" rel="external">Github</a></p>
<h3 id="代码-55"><a href="#代码-55" class="headerlink" title="代码"></a>代码</h3><pre><code class="python">class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None

    def EntryNodeOfLoop(self, head):
        fast = slow = head
        while fast.next and fast.next.next:
            fast = fast.next.next
            slow = slow.next
            if fast is slow: # 二者相遇，说明链表含环
                fast = head # fast 指向头结点
                while fast is not slow: # 二者还没相遇之前一直走下去
                    fast, slow = fast.next, slow.next  # 这里fast和slow的速度一样
                return fast
</code></pre>
<h2 id="删除链表中重复的结点"><a href="#删除链表中重复的结点" class="headerlink" title="删除链表中重复的结点"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/57_%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E7%BB%93%E7%82%B9.py" target="_blank" rel="external">删除链表中重复的结点</a></h2><h3 id="题目描述-56"><a href="#题目描述-56" class="headerlink" title="题目描述"></a>题目描述</h3><p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。<br>例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5</p>
<h3 id="最优题解-56"><a href="#最优题解-56" class="headerlink" title="最优题解"></a>最优题解</h3><p>双指针。<br>pre和cur，cur负责在前面‘探路’，遇到重复结点就一直往后删除，<br>确认是唯一结点就让pre后移，这样pre其实一直指向唯一结点的尾部。<br>注意头结点可能和后面的结点重复，所以头结点可能被删除<br>为了减少代码的理解复杂度，引入伪结点dummy</p>
<h3 id="代码-56"><a href="#代码-56" class="headerlink" title="代码"></a>代码</h3><pre><code class="python">class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None

class Solution:
    def deleteDuplication(self, pHead):
        if not pHead: return
        pre = dummy = ListNode(0) # 使用伪结点
        dummy.next = cur = pHead
        while cur:
            if cur.next and cur.next.val == cur.val: # 遇到相等的结点
                val = cur.val
                while cur and cur.val == val: # 连续删除重复结点
                    cur = pre.next = cur.next
            else:
                pre, cur = pre.next, cur.next
        return dummy.next # 伪结点的下一个结点就是链表头结点
</code></pre>
<h2 id="二叉树的下一个结点（中序）"><a href="#二叉树的下一个结点（中序）" class="headerlink" title="二叉树的下一个结点（中序）"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/58_1_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9%EF%BC%88%E4%B8%AD%E5%BA%8F%EF%BC%89.py" target="_blank" rel="external">二叉树的下一个结点（中序）</a></h2><h3 id="题目描述-57"><a href="#题目描述-57" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。<br>注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p>
<h3 id="最优题解-57"><a href="#最优题解-57" class="headerlink" title="最优题解"></a>最优题解</h3><p>该结点若有右子树就找到右子树的最左结点；<br>没有右子树则向上找到第一个当前结点是其父结点左孩子的结点的父结点；<br>退到了根节点仍没找到则返回None</p>
<h3 id="代码-57"><a href="#代码-57" class="headerlink" title="代码"></a>代码</h3><pre><code class="python">class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None
        self.parent = None

class Solution:
    def GetNext(self, pNode):
        if node is None: return
        if node.right:  # 若有右子树就找到右子树的最左结点
            cur = node.right
            while cur.left:
                cur = cur.left
            return cur
        # 没有右子树则向上找到第一个当前结点是其父结点左孩子的结点
        while node.next and node.next.left is not node:
            node = node.next
        return node.next  # 注意返回的是该结点的父结点，若node退到了根结点则返回的是None
</code></pre>
<h3 id="举一反三-12"><a href="#举一反三-12" class="headerlink" title="举一反三"></a>举一反三</h3><ul>
<li><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/58_2_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8A%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9%EF%BC%88%E4%B8%AD%E5%BA%8F%EF%BC%89.py" target="_blank" rel="external">二叉树的上一个结点（中序）</a></li>
<li><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/58_3_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9%EF%BC%88%E5%89%8D%E5%BA%8F%EF%BC%89.py" target="_blank" rel="external">二叉树的下一个结点（前序）</a></li>
<li><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/58_4_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8A%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9%EF%BC%88%E5%89%8D%E5%BA%8F%EF%BC%89.py" target="_blank" rel="external">二叉树的上一个结点（前序）</a></li>
<li><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/58_5_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9%EF%BC%88%E5%90%8E%E5%BA%8F%EF%BC%89.py" target="_blank" rel="external">二叉树的下一个结点（后序）</a></li>
<li><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/58_6_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8A%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9%EF%BC%88%E5%90%8E%E5%BA%8F%EF%BC%89.py" target="_blank" rel="external">二叉树的上一个结点（后序）</a></li>
<li><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/58_7_%E6%80%BB%E7%BB%931-6.py" target="_blank" rel="external">总结</a></li>
<li><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/58_8_%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%BB%93%E7%82%B9%E7%9A%84%E7%88%B6%E7%BB%93%E7%82%B9.py" target="_blank" rel="external">二叉树中结点的父结点</a></li>
</ul>
<h2 id="对称的二叉树"><a href="#对称的二叉树" class="headerlink" title="对称的二叉树"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/59_%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91.py" target="_blank" rel="external">对称的二叉树</a></h2><h3 id="题目描述-58"><a href="#题目描述-58" class="headerlink" title="题目描述"></a>题目描述</h3><p>请实现一个函数，用来判断一颗二叉树是不是对称的。<br>注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</p>
<h3 id="最优题解-58"><a href="#最优题解-58" class="headerlink" title="最优题解"></a>最优题解</h3><p>前序遍历，把当前结点的左右子树看成俩棵树，<br>只有当左树的左子树和右树的右子树相同<br>并且左树的右子树和右树的左子树相同才对称</p>
<h3 id="代码-58"><a href="#代码-58" class="headerlink" title="代码"></a>代码</h3><pre><code class="python">class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution:
    def isSymmetrical(self, pRoot):
        def sym(root1, root2):
            if root1 and root2 and root1.val == root2.val:
                return sym(root1.left, root2.right) and sym(root1.right, root2.left)
            return not root1 and not root2 # 两个都为None时返回True，一个为None另一个非None时返回False
        return sym(pRoot, pRoot)
</code></pre>
<h2 id="把二叉树打印成多行"><a href="#把二叉树打印成多行" class="headerlink" title="把二叉树打印成多行"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/60_%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%93%E5%8D%B0%E6%88%90%E5%A4%9A%E8%A1%8C.py" target="_blank" rel="external">把二叉树打印成多行</a></h2><h3 id="题目描述-59"><a href="#题目描述-59" class="headerlink" title="题目描述"></a>题目描述</h3><p>从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</p>
<h3 id="最优题解-59"><a href="#最优题解-59" class="headerlink" title="最优题解"></a>最优题解</h3><p>层次遍历，队列实现</p>
<h3 id="代码-59"><a href="#代码-59" class="headerlink" title="代码"></a>代码</h3><pre><code class="python">class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution:
    # 返回二维列表[[1,2],[4,5]]
    def Print(self, pRoot):
        if pRoot is None: return []
        level, res = [pRoot], []
        while level:
            next_level = []
            res.append([])
            for node in level:
                res[-1].append(node.val)
                if node.left:
                    next_level.append(node.left)
                if node.right:
                    next_level.append(node.right)
            level = next_level
        return res
</code></pre>
<h2 id="按之字型顺序打印二叉树"><a href="#按之字型顺序打印二叉树" class="headerlink" title="按之字型顺序打印二叉树"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/61_%E6%8C%89%E4%B9%8B%E5%AD%97%E5%9E%8B%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91.py" target="_blank" rel="external">按之字型顺序打印二叉树</a></h2><h3 id="题目描述-60"><a href="#题目描述-60" class="headerlink" title="题目描述"></a>题目描述</h3><p>请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，<br>第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。</p>
<h3 id="最优题解-60"><a href="#最优题解-60" class="headerlink" title="最优题解"></a>最优题解</h3><p>两个栈实现。奇数层打印时先保存左孩子再保存右孩子到另一个栈里，这样在打印偶数层时就会先打印右孩子再打印左孩子；同理，偶数层在打印时反过来先右后左保存子结点到奇数层</p>
<h3 id="代码-60"><a href="#代码-60" class="headerlink" title="代码"></a>代码</h3><pre><code class="python">class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution:
    def Print(self, pRoot):
        if not pRoot: return []
        cur, res = 0, []  # 0表示当前正在打印奇数层， 1表示当前正在打印偶数层
        stack = [[pRoot], []]  # 奇偶栈
        while any(stack):
            res.append([])
            while stack[cur]:
                node = stack[cur].pop()
                res[-1].append(node.val)
                if cur == 0:  # 如果当前正在打印奇数层
                    if node.left:
                        stack[~cur].append(node.left)  # 保存子结点于偶数层
                    if node.right:
                        stack[~cur].append(node.right)
                else:  # 如果当前正在打印偶数层
                    if node.right:
                        stack[~cur].append(node.right)  # 保存子结点于奇数层
                    if node.left:
                        stack[~cur].append(node.left)
            cur = ~cur  # 反转奇偶层
        return res
</code></pre>
<h2 id="二叉树的序列化和反序列化"><a href="#二叉树的序列化和反序列化" class="headerlink" title="二叉树的序列化和反序列化"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/62_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96.py" target="_blank" rel="external">二叉树的序列化和反序列化</a></h2><h3 id="题目描述-61"><a href="#题目描述-61" class="headerlink" title="题目描述"></a>题目描述</h3><p>请实现两个函数，分别用来序列化和反序列化二叉树。这里没有规定序列化的方式。</p>
<h3 id="最优题解-61"><a href="#最优题解-61" class="headerlink" title="最优题解"></a>最优题解</h3><p>序列化可以采用多种遍历方式，本来可以仿照第6题序列化成前序+中序或后序+中序，<br>但这要求结点值不能重复，所以不能使用双遍历的方式。采用单遍历就允许结点值重复，<br>可是单次遍历是无法确定一个二叉树的，所以可以<strong>在遍历到None时也加入遍历序列中</strong>。<br>这里的序列化字符串用‘#’表示None,为了防止12，3以及1，23产生歧义而分不清，使用逗号将每个结点的值分开。</p>
<h3 id="代码-61"><a href="#代码-61" class="headerlink" title="代码"></a>代码</h3><pre><code class="python">class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution:
    def Serialize(self, root):
        def serialize(root):
            level, res = [root], []
            while level:
                next_level = []
                for node in level:
                    res.append(str(node.val) if node else &#39;#&#39;)
                    if node: next_level += node.left, node.right
                level = next_level
            return &#39;,&#39;.join(res)

        def deserialize(s):
            s = s.split(&#39;,&#39;)
            if s[0] == &#39;#&#39;: return
            root = TreeNode(int(s[0]))
            queue = [root]
            for i in range(1, len(s), 2):  # s的长度一定为奇数
                node = queue.pop(0)
                if s[i] != &#39;#&#39;:  # 连接左孩子
                    left = TreeNode(int(s[i]))
                    node.left = left
                    queue.append(left)
                if s[i + 1] != &#39;#&#39;:  # 连接右孩子
                    right = TreeNode(int(s[i + 1]))
                    node.right = right
                    queue.append(right)
            return root
</code></pre>
<h2 id="二叉搜索树中的第k个结点"><a href="#二叉搜索树中的第k个结点" class="headerlink" title="二叉搜索树中的第k个结点"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/63_%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9.py" target="_blank" rel="external">二叉搜索树中的第k个结点</a></h2><h3 id="题目描述-62"><a href="#题目描述-62" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一棵二叉搜索树，请找出其中的第k大的结点。例如，</p>
<p><img src="https://ws1.sinaimg.cn/large/006giLD5ly1fwx66yx85wj302s03dmwx.jpg" alt="二叉搜索树"></p>
<p>按结点数值大小顺序第三个结点的值为4。</p>
<h3 id="最优题解-62"><a href="#最优题解-62" class="headerlink" title="最优题解"></a>最优题解</h3><p>二叉搜索树的中序遍历序列是递增排序的，所以中序遍历二叉树，递归实现，找到就返回</p>
<h3 id="代码-62"><a href="#代码-62" class="headerlink" title="代码"></a>代码</h3><pre><code class="python">class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution:
    # 返回对应节点TreeNode
    def __init__(self):
        self.k = 0

    def KthNode(self, pRoot, k):
        def inOrder(root):
            if root is None: return
            node = inOrder(root.left)
            if node: return node # 找到就直接返回
            self.k -= 1 # 没找到就继续在中间找
            if self.k == 0: return root # 找到就直接返回
            return inOrder(root.right) # 没找到就继续在右边找

        self.k = k
        return inOrder(pRoot)
</code></pre>
<h2 id="数据流的中位数"><a href="#数据流的中位数" class="headerlink" title="数据流的中位数"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/64_%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0.py" target="_blank" rel="external">数据流的中位数</a></h2><h3 id="题目描述-63"><a href="#题目描述-63" class="headerlink" title="题目描述"></a>题目描述</h3><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。<br>如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p>
<h3 id="最优题解-63"><a href="#最优题解-63" class="headerlink" title="最优题解"></a>最优题解</h3><p>构建大根堆和小根堆，则插入O(logn)，取中位数O(1)<br>如果用一个数组存储所有到来数据，然后在取中位数时排序返回，则插入O(1)，取中位数O(nlogn)<br>由此可见，动态构建大根堆和小根堆相当于把排序时间平分到每次插入操作中，这样在获取中位数时可以O(1)<br>有两个条件要满足：<br>1、保证数据平均分配到两个堆中，即两个堆中数据的数目之差不能超过1；<br>2、保证大根堆里所有数据都要小于小根堆中的数据</p>
<p>当数据总数为奇数时，新加入的元素，应当进入大根堆，<br>注意不是直接进入大根堆，而是经小根堆筛选后取小根堆中最大元素进入大根堆；<br>当数据总数为偶数时，新加入的元素，应当进入小根堆，<br>注意不是直接进入小根堆，而是经大根堆筛选后取大根堆中最大元素进入小根堆<br>取数时若总数个数为奇数则直接取大堆堆顶，偶数时取两堆堆顶平均值</p>
<p>这里构建堆用heapq，其构建的都是小根堆（优先队列），所以为了构建大根堆需要在存数取数时加上负号</p>
<h3 id="代码-63"><a href="#代码-63" class="headerlink" title="代码"></a>代码</h3><pre><code class="python">from heapq import heappush, heappushpop

class Solution:
    def __init__(self):
        self.count = 0
        self.maxheap = []
        self.minheap = []

    def Insert(self, num):
        import heapq
        self.count += 1
        if self.count &amp; 1: # 奇数时，新加入的元素应当进入大根堆
            heappush(self.maxheap, -heappushpop(self.minheap, num))
        else: # 偶数时，新加入的元素应当进入小根堆
            heappush(self.minheap, -heappushpop(self.maxheap, -num))

    def GetMedian(self):
        return -self.maxheap[0] if self.count &amp; 1 else (-self.maxheap[0] + self.minheap[0]) / 2.0
</code></pre>
<h2 id="滑动窗口的最大值"><a href="#滑动窗口的最大值" class="headerlink" title="滑动窗口的最大值"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/65_1_%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC.py" target="_blank" rel="external">滑动窗口的最大值</a></h2><h3 id="题目描述-64"><a href="#题目描述-64" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个数组和滑动窗口的大小k，找出所有滑动窗口里数值的最大值。<br>例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，<br>他们的最大值分别为{4,4,6,6,6,5}；<br>针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个：<br>{[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}，<br>{2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。</p>
<h3 id="最优题解-64"><a href="#最优题解-64" class="headerlink" title="最优题解"></a>最优题解</h3><p>时间复杂度O（n），空间复杂度O（n）</p>
<p>用一个双端队列，其中保存当前可能为最大值的数的下标，每当窗口滑动一次<br>1.新增加的值从队尾开始比较，把前面所有比他小的值从队尾取出，直到遇到比它大的数就停止：<br>  因为这些数已经不再可能成为后面滑动窗口的最大值了，有种‘长江后浪推前浪’的感觉，<br>  新来的数会淘汰掉前面比它小的数，而如果前面的数比它大则自己没有资格淘汰前面的数，<br>  更别说更前面的数。但该数还是有‘潜质’成为最大数的，因为可能由于前面的数被滑动窗口<br>  的移动而强行淘汰使得自己成为最大数，所以会进入队尾等待‘考核’。</p>
<p>2.判断当前最大值是否过期，过期则从队首取出：<br>  当一个数字的下标与当前正在处理的数字的下标之差大于等于滑动窗口大小时，<br>  该最大值过期，即已经从窗口中滑出，需要从队首删除。滑动窗口总是要往右移的，<br>  再大的数也会被淘汰。<br>每次通过以上两步操作使得队列第一个位置为当前窗口的最大值</p>
<h3 id="代码-64"><a href="#代码-64" class="headerlink" title="代码"></a>代码</h3><pre><code class="python">from collections import deque

class Solution:
    def maxInWindows(self, num, size):
        if not num or not size: return []
        queue, res = deque(), []
        for i in range(len(num)):
            # 新增加的值从队尾开始比较，把前面所有比它小的值从队尾取出，直到遇到比它大的数就停止
            while queue and num[queue[-1]] &lt;= num[i]:
                queue.pop()
            # 判断当前最大值是否过期，过期则从队首取出
            if queue and i - queue[0] &gt;= size:
                queue.popleft()
            queue.append(i) # 进入队列的是数的下标
            # 当处理数据下标（从0开始）等于size-1时开始写入窗口最大值，
            # 因为此时刚好来到第一个窗口的尾部，产生第一个最大值，之后窗口开始移动
            if i &gt;= size - 1:
                 # 每次通过以上两步操作使得队列第一个位置为当前窗口的最大值
                res.append(num[queue[0]])
        return res
</code></pre>
<h2 id="矩阵中的路径"><a href="#矩阵中的路径" class="headerlink" title="矩阵中的路径"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/66_%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84.py" target="_blank" rel="external">矩阵中的路径</a></h2><h3 id="题目描述-65"><a href="#题目描述-65" class="headerlink" title="题目描述"></a>题目描述</h3><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。<br>路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。<br>如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。<br>例如<br>[[a b c e],<br>[s f c s],<br>[a d e e]]<br>矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，<br>因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。</p>
<h3 id="最优题解-65"><a href="#最优题解-65" class="headerlink" title="最优题解"></a>最优题解</h3><p>回溯法，用一个状态数组保存之前访问过的字符位置，然后再分别按上，下，左，右分别递归</p>
<h3 id="代码-65"><a href="#代码-65" class="headerlink" title="代码"></a>代码</h3><pre><code class="python">class Solution:
    def hasPath(self, matrix, rows, cols, path):
        def hasPathCore(row, col, pathLength, visited):
            if len(path) == pathLength:  # 来到末尾，成功找到路径
                return True
            hasPath = False
            if 0 &lt;= row &lt; rows and 0 &lt;= col &lt; cols \
                    and matrix[row * cols + col] == path[pathLength] \
                    and not visited[row * cols + col]:
                pathLength += 1
                visited[row * cols + col] = True
                hasPath = hasPathCore(row, col - 1, pathLength, visited) or \
                          hasPathCore(row - 1, col, pathLength, visited) or \
                          hasPathCore(row, col + 1, pathLength, visited) or \
                          hasPathCore(row + 1, col, pathLength, visited)
                if not hasPath:  # 上下左右都没找到路径，则回退
                    pathLength -= 1
                    visited[row * cols + col] = False
            return hasPath
</code></pre>
<h2 id="机器人的运动范围"><a href="#机器人的运动范围" class="headerlink" title="机器人的运动范围"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/67_%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4.py" target="_blank" rel="external">机器人的运动范围</a></h2><h3 id="题目描述-66"><a href="#题目描述-66" class="headerlink" title="题目描述"></a>题目描述</h3><p>地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，<br>每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。<br>例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。<br>但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</p>
<h3 id="最优题解-66"><a href="#最优题解-66" class="headerlink" title="最优题解"></a>最优题解</h3><p>回溯法。<br>​       1.从(0,0)开始走，先判断四个方向是否满足条件，满足就把相应位置标记为True，<br>​       再递归，最终统计有几处标记为True<br>​       2.判断当前节点是否可达的标准为：<br>​       1）当前节点在矩阵内；<br>​       2）当前节点未被访问过；<br>​       3）当前节点满足题目要求。<br>​       注意，这里不是寻找路径，而是类似于扫雷，<br>​       走过的地方发现满足条件就算作能够到达，走不下去了也不必回退<br>​       注意这里若去遍历所有位置看是否满足条件是不行的，因为有可能出现单个‘孤岛’或者是连在一起的‘孤岛’，<br>​       即这些位置虽然满足条件，但四周并不满足条件，这样机器人是无法到达这些位置的</p>
<h3 id="代码-66"><a href="#代码-66" class="headerlink" title="代码"></a>代码</h3><pre><code class="python">class Solution:
    def movingCount(self, threshold, rows, cols):
        def canReach(row, col):
            sum = 0
            while row or col:
                sum += row % 10 + col % 10
                row //= 10
                col //= 10
            return sum &lt;= threshold

        def movingCountCore(row, col, visited):
            for i, j in [(row, col - 1), (row, col + 1), (row - 1, col), (row + 1, col)]:
                if 0 &lt;= i &lt; rows and 0 &lt;= j &lt; cols \
                        and canReach(i, j) \
                        and not visited[i * cols + j]:  # 先判断四个方向是否满足条件
                    visited[i * cols + j] = True
                    movingCountCore(i, j, visited)

        if threshold == None or threshold &lt; 0 or not cols or not rows:
            return 0
        visited = [False] * (rows * cols)
        visited[0] = True
        movingCountCore(0, 0, visited)  # 从（0，0）开始移动
        return sum(visited)
</code></pre>
<h2 id="补充-剪绳子"><a href="#补充-剪绳子" class="headerlink" title="补充_剪绳子"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/%E8%A1%A5%E5%85%8568_%E5%89%AA%E7%BB%B3%E5%AD%90.py" target="_blank" rel="external">补充_剪绳子</a></h2><h3 id="题目描述-67"><a href="#题目描述-67" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一根长度为n的绳子，请把绳子剪成m段，记每段绳子长度为k[0],k<a href="https://github.com/Hk4Fun/algorithm_offer/tree/master/target_offer" target="_blank" rel="external">1</a>…k[m-1],求k[0]k<a href="https://github.com/Hk4Fun/algorithm_offer/tree/master/target_offer" target="_blank" rel="external">1</a>…k[m-1]的最大值。<br>已知绳子长度n为整数，n&gt;1且m&gt;1(至少要剪一刀，不能不剪)，k[0],k<a href="https://github.com/Hk4Fun/algorithm_offer/tree/master/target_offer" target="_blank" rel="external">1</a>…k[m-1]均要求为整数。<br>例如，绳子长度为8时，把它剪成3-3-2，得到最大乘积18；绳子长度为3时，把它剪成2-1，得到最大乘积2。</p>
<h3 id="主要思路"><a href="#主要思路" class="headerlink" title="主要思路"></a>主要思路</h3><ul>
<li>思路1：动态规划（时间O(n^2)，空间O(n)）。</li>
</ul>
<p>定义函数f(n)为把长度为n的绳子剪成若干段后各段长度乘积的最大值。<br>则状态转移方程为：<code>f(n)= max(f(i)\*f(n-i))</code>，其中0 &lt; i &lt; n。考虑边界情况：<br>当n=2时，f(2)=1; 当n=3时，f(3)=2。递归实现会发生重复计算，所以这里自下而上计算<br>（从上往下分析问题，从下往上求解问题，用一维或二维数组作备忘录）</p>
<ul>
<li>思路2： 贪心（时间O(1)，空间O(1)）。</li>
</ul>
<p>当n&gt;=5时，尽可能多地剪长度为3的绳子；当剩下的绳子长度为4时，把绳子剪成两段长度为2的绳子<br>（需要数学证明该贪心策略可以取到最优解，不具有通用性，具体证明见第二版书P98）</p>
<h3 id="代码-67"><a href="#代码-67" class="headerlink" title="代码"></a>代码</h3><pre><code class="python">class Solution:
    def cuttingRope1(self, length):
        if length == None:
            return
        if length &lt; 2:
            return 0
        if length == 2:
            return 1
        if length == 3:
            return 2
        dp = [0] * (length + 1)
        dp[1], dp[2], dp[3] = 1, 2, 3  # 注意边界值的填写

        for i in range(4, length + 1):
            max = 0
            for j in range(1, (i &gt;&gt; 1) + 1):
                mul = dp[j] * dp[i - j]
                if mul &gt; max:
                    max = mul
                dp[i] = max
        return dp[length]


    def cuttingRope2(self, length):
        if not length:
            return
        if length &lt; 2:
            return 0
        if length == 2:
            return 1
        if length == 3:
            return 2

        numOf3 = length // 3
        if length - numOf3 * 3 == 1:
            numOf3 -= 1
        numOf2 = (length - numOf3 * 3) &gt;&gt; 1
        return (3 ** numOf3) * (2 ** numOf2)
</code></pre>
<h2 id="补充-数字序列中某一位的数字"><a href="#补充-数字序列中某一位的数字" class="headerlink" title="补充_数字序列中某一位的数字"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/%E8%A1%A5%E5%85%8569_%E6%95%B0%E5%AD%97%E5%BA%8F%E5%88%97%E4%B8%AD%E6%9F%90%E4%B8%80%E4%BD%8D%E7%9A%84%E6%95%B0%E5%AD%97.py" target="_blank" rel="external">补充_数字序列中某一位的数字</a></h2><h3 id="题目描述-68"><a href="#题目描述-68" class="headerlink" title="题目描述"></a>题目描述</h3><p>数字按照0123456789101112131415161718192021…的顺序排列。<br>第5位（从0开始计数）为5，第13位为1，第19位为4…… 求任意第n位对应的数字。</p>
<h3 id="最优题解-67"><a href="#最优题解-67" class="headerlink" title="最优题解"></a>最优题解</h3><p>找出规律跳过若干数字。例如：序列前十位是0~9。<br>接下来180位数字是90个10~99的两位数。接下来的2700位是900个100~999的三位数。即分组寻找，锁定范围</p>
<h3 id="代码-68"><a href="#代码-68" class="headerlink" title="代码"></a>代码</h3><pre><code class="python">class Solution:
    def digitAtIndex(self, index):
        if index == None or index &lt; 0: return
        digits = 1  # 表示位数
        while True:
            numbers = 10 if digits == 1 else 9 * (10 ** (digits - 1))  # digits位数字总共有多少个
            if index &lt; numbers * digits:  # 在范围内
                number = (0 if digits == 1 else 10 ** (digits - 1)) + index // digits  # 求出落在哪个数上
                for i in range(digits - index % digits - 1):  # 右移
                    number //= 10
                return number % 10
            index -= digits * numbers  # 还没在范围内则继续往后找
            digits += 1
</code></pre>
<h2 id="补充-把数字翻译成字符串"><a href="#补充-把数字翻译成字符串" class="headerlink" title="补充_把数字翻译成字符串"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/%E8%A1%A5%E5%85%8570_%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2.py" target="_blank" rel="external">补充_把数字翻译成字符串</a></h2><h3 id="题目描述-69"><a href="#题目描述-69" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个数字，按照如下规则翻译成字符串：0翻译成“a”，1翻译成“b”…25翻译成“z”。<br>一个数字有多种翻译可能，例如12258一共有5种，分别是bccfi，bwfi，bczi，mcfi，mzi。<br>实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p>
<h3 id="最优题解-68"><a href="#最优题解-68" class="headerlink" title="最优题解"></a>最优题解</h3><p>动态规划（时间O(n),空间O(n)）。定义函数f(i)表示从第i位数字开始的不同翻译的数目，则状态转移方程为：<br><code>f(i) = f(i+1)+g(i,i+1)f(i+2)</code>。当第i位和第i+1位两位数字拼接起来的数字在10~25的范围内时，<br>g(i,i+1)的值为1，否则为0。自底向上，在这里为从右向左翻译<br>注：f(n) = f(n-1) = 1<br>该方程类似于青蛙跳台阶，只不过多了g(i,i+1)的限制</p>
<h3 id="代码-69"><a href="#代码-69" class="headerlink" title="代码"></a>代码</h3><pre><code class="python">class Solution:
    def TranslationCount(self, number):
        if number == None or number &lt; 0:
            return
        numberStr = str(number)
        length = len(numberStr)
        dp = [1] * length
        for i in range(length - 1, -1, -1):
            if i &lt; length - 1:
                count = dp[i + 1]
            else:
                count = 1
            if i &lt; length - 1 and 10 &lt;= int(numberStr[i:i + 2]) &lt;= 25:
                if i &lt; length - 2:
                    count += dp[i + 2]
                else:
                    count += 1
            dp[i] = count
        return dp[0]
</code></pre>
<h2 id="补充-礼物的最大值"><a href="#补充-礼物的最大值" class="headerlink" title="补充_礼物的最大值"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/%E8%A1%A5%E5%85%8571_%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC.py" target="_blank" rel="external">补充_礼物的最大值</a></h2><h3 id="题目描述-70"><a href="#题目描述-70" class="headerlink" title="题目描述"></a>题目描述</h3><p>在一个m*n的棋盘的每一个格都放有一个礼物，每个礼物都有一定价值（大于0）。<br>从左上角开始拿礼物，每次向右或向下移动一格，直到右下角结束。<br>给定一个棋盘，求拿到礼物的最大价值。例如，对于如下棋盘：<br>1    10   3    8<br>12   2    9    6<br>5    7    4    11<br>3    7    16   5<br>礼物的最大价值为1+12+5+7+7+16+5=53。</p>
<h3 id="最优题解-69"><a href="#最优题解-69" class="headerlink" title="最优题解"></a>最优题解</h3><p>动态规划（时间O(m*n),空间O(n)）:<br>定义函数f(i,j)表示到达坐标为(i,j)的格子时能拿到的礼物总和的最大值。<br>根据题目要求，有两种可能的途径到达坐标为(i,j)的格子：通过格子(i,j-1)或(i-1,j)。<br>即来自左边格子或上边格子。故状态转移方程为：f(i,j) = max(f(i-1,j),f(i,j-1))+gift[i,j]<br>gift[i,j]表示坐标为(i,j)的格子里礼物的价值。<br>优化：由于礼物的最大价值只依赖坐标为(i-1,j)和(i,j-1)的两个格子，<br>因此第i-1行及更上面的格子礼物的最大价值实际上不必保存下来。所以可以用一个一维数组作备忘。<br>有两种遍历方式：行优先遍历，即自左向右，自上而下；列优先遍历，自上而下，自左向右。<br>这两种方式都保证了在求f(i,j)时已经求出了f(i-1,j)和f(i,j-1)。<br>注意边界情况：第一行没有来自上边的格子，第一列没有来自左边的格子</p>
<h3 id="代码-70"><a href="#代码-70" class="headerlink" title="代码"></a>代码</h3><pre><code class="python">class Solution:
    def getMaxValue(self, values):
        if not values:
            return 0
        cols = len(values[0])
        dp = [0] * cols
        for i in range(len(values)):
            for j in range(cols):
                dp[j] = max(dp[j] if i &gt; 0 else 0, dp[j - 1] if j &gt; 0 else 0) + values[i][j]
        return dp[cols - 1]
</code></pre>
<h2 id="补充-最长不含重复字符的字符串长度"><a href="#补充-最长不含重复字符的字符串长度" class="headerlink" title="补充_最长不含重复字符的字符串长度"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/%E8%A1%A5%E5%85%8572_%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%95%BF%E5%BA%A6.py" target="_blank" rel="external">补充_最长不含重复字符的字符串长度</a></h2><h3 id="题目描述-71"><a href="#题目描述-71" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个字符串（只包含a~z的字符），求其最长不含重复字符的子字符串的长度。<br>例如对于arabcacfr，最长不含重复字符的子字符串为acfr，长度为4。</p>
<h3 id="最优题解-70"><a href="#最优题解-70" class="headerlink" title="最优题解"></a>最优题解</h3><p>时间O（n），空间O（1）（字母种类有限，所以空间为常数）</p>
<p>用两个指针始终记录不重复字符串的头start和尾tail，tail一直往右边扫描<br>每当遇到重复的字符（需要一个哈希表记录每个字符曾经出现过的最右的索引），<br>设该重复字符之前出现的位置为i，如果 start &lt;= i &lt; tail，<br>则只需把头指针移到 i + 1 的位置即可，否则（i &lt; start）接着往右扫描<br>当然循环每一步都要更新当前字符出现的最新位置，并且更新最大长度<br>这里可以稍微优化一下：当出现重复字符并且 start &lt;= i &lt; tail 时，<br>我们令start = i + 1，则字符串长度一定减小了，可以不用更新字符串长度<br>换句话说，只有start不往右移时我们才去更新最大长度</p>
<h3 id="代码-71"><a href="#代码-71" class="headerlink" title="代码"></a>代码</h3><pre><code class="python">class Solution:
    def LSWD(self, s):
        maxLen = start = 0
        last = {}  # 记录每个字母最近出现的位置
        for i, v in enumerate(s):  # i一直往右遍历
            if v in last and start &lt;= last[v]:  # 之前出现过该字母并且最近出现的位置在start到i之间
                start = last[v] + 1  # 将start移到上次出现位置的右边
            else:  # 如果start被右移了就没必要更新maxLen了，因为肯定比原来的小
                maxLen = max(maxLen, i - start + 1)
            last[v] = i  # 新增或更新每个字母最近出现的位置
        return maxLen
</code></pre>
<h2 id="补充-股票的最大利润"><a href="#补充-股票的最大利润" class="headerlink" title="补充_股票的最大利润"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/%E8%A1%A5%E5%85%8573_%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6.py" target="_blank" rel="external">补充_股票的最大利润</a></h2><h3 id="题目描述-72"><a href="#题目描述-72" class="headerlink" title="题目描述"></a>题目描述</h3><p>假设把某股票的价格按照时间先后顺序存储在数组中，<br>请问买卖交易该股票可能获得的最大利润是多少？<br>例如一只股票在某些时间节点的价格为{9, 11, 8, 5, 7, 12, 16, 14}。<br>如果我们能在价格为5的时候买入并在价格为16时卖出，则能收获最大的利润11。</p>
<h3 id="最优题解-71"><a href="#最优题解-71" class="headerlink" title="最优题解"></a>最优题解</h3><p>（时间O(n), 空间O(1)）</p>
<p>首先明确一点：买入股票后才能卖出，因此直接用最大值减最小值是不行的，因为最大值可能出现在最小值前面。<br>如果把股票的买入价和卖出价两个数字组成数字对，那么利润就是这个数字对的差值（卖出-买入）。<br>因此，最大利润就是数组中所有数字对的最大差值<br>显然，在卖出价固定时，买入价越低获得的利润越大。<br>也就是说，如果在遍历到数组中第i个数时，只要能够记录下之前的i-1个数字的最小值，<br>就能算出当前价位卖出时可能得到的最大利润</p>
<p>因此算法由左至右遍历，总是获取当前的最小价格（包括当前值），<br>算出当前价格与当前最小价格的差价（利润）并保存最大利润<br>注意：当亏损时不买不卖，利润为0</p>
<h3 id="代码-72"><a href="#代码-72" class="headerlink" title="代码"></a>代码</h3><pre><code class="python">class Solution:
    def maxProfit(self, prices):
        # 设置两个变量分别记录最小价格和最大利润
        maxProfit, minPrice = 0, float(&#39;inf&#39;)  # 设maxProfit为0可以保证出现负利润时返回0
        for price in prices:
            minPrice = min(minPrice, price)  # 看一下目前有没有更低的价格来买入
            profit = price - minPrice  # 假如现在卖出能赚多少钱
            maxProfit = max(maxProfit, profit)  # 记录下最大利润，以便后面作参考比较
        return maxProfit
</code></pre>

      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/2019/01/31/剑指offer题解（Python实现）/">剑指offer题解（Python实现）</a></p>
        <p><span>文章作者:</span><a href="/" title="回到主页">Hk4Fun</a></p>
        <p><span>发布时间:</span>2019-01-31, 18:11:06</p>
        <p><span>最后更新:</span>2019-02-03, 13:05:19</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/2019/01/31/剑指offer题解（Python实现）/" title="剑指offer题解（Python实现）">https://hk4fun.github.io/2019/01/31/剑指offer题解（Python实现）/</a>
            <span class="copy-path" data-clipboard-text="原文: https://hk4fun.github.io/2019/01/31/剑指offer题解（Python实现）/　　作者: Hk4Fun" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target = "_blank">"署名-非商用-相同方式共享 4.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



    <nav id="article-nav">
        
        
            <div id="article-nav-older" class="article-nav-title">
                <a href="/2018/12/06/那些值得阅读的PEP/">
                    那些值得阅读的PEP
                </a>
            </div>
        
    </nav>

  
</article>

    <div id="toc" class="toc-article">
        <strong class="toc-title">文章目录</strong>
        
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#二维数组中的查找"><span class="toc-number">1.</span> <span class="toc-text"> 二维数组中的查找</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目描述"><span class="toc-number">1.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最优题解"><span class="toc-number">1.2.</span> <span class="toc-text">最优题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码"><span class="toc-number">1.3.</span> <span class="toc-text">代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#拓展题目"><span class="toc-number">1.4.</span> <span class="toc-text">拓展题目</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#替换空格"><span class="toc-number">2.</span> <span class="toc-text">替换空格</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目描述-1"><span class="toc-number">2.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最优题解-1"><span class="toc-number">2.2.</span> <span class="toc-text">最优题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码-1"><span class="toc-number">2.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#从尾到头打印链表"><span class="toc-number">3.</span> <span class="toc-text">从尾到头打印链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目描述-2"><span class="toc-number">3.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最优题解-2"><span class="toc-number">3.2.</span> <span class="toc-text">最优题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码-2"><span class="toc-number">3.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#重建二叉树"><span class="toc-number">4.</span> <span class="toc-text">重建二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目描述-3"><span class="toc-number">4.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最优题解-3"><span class="toc-number">4.2.</span> <span class="toc-text">最优题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码-3"><span class="toc-number">4.3.</span> <span class="toc-text">代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#举一反三"><span class="toc-number">4.4.</span> <span class="toc-text">举一反三</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#用两个栈实现队列"><span class="toc-number">5.</span> <span class="toc-text">用两个栈实现队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目描述-4"><span class="toc-number">5.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最优题解-4"><span class="toc-number">5.2.</span> <span class="toc-text">最优题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码-4"><span class="toc-number">5.3.</span> <span class="toc-text">代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#举一反三-1"><span class="toc-number">5.4.</span> <span class="toc-text">举一反三</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#旋转数组的最小数字"><span class="toc-number">6.</span> <span class="toc-text">旋转数组的最小数字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目描述-5"><span class="toc-number">6.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最优题解-5"><span class="toc-number">6.2.</span> <span class="toc-text">最优题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码-5"><span class="toc-number">6.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#斐波那契数列"><span class="toc-number">7.</span> <span class="toc-text">斐波那契数列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目描述-6"><span class="toc-number">7.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最优题解-6"><span class="toc-number">7.2.</span> <span class="toc-text">最优题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码-6"><span class="toc-number">7.3.</span> <span class="toc-text">代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#举一反三-2"><span class="toc-number">7.4.</span> <span class="toc-text">举一反三</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二进制中1的个数"><span class="toc-number">8.</span> <span class="toc-text">二进制中1的个数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目描述-7"><span class="toc-number">8.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最优题解-7"><span class="toc-number">8.2.</span> <span class="toc-text">最优题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码-7"><span class="toc-number">8.3.</span> <span class="toc-text">代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#举一反三-3"><span class="toc-number">8.4.</span> <span class="toc-text">举一反三</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数值的整数次方"><span class="toc-number">9.</span> <span class="toc-text">数值的整数次方</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目描述-8"><span class="toc-number">9.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最优题解-8"><span class="toc-number">9.2.</span> <span class="toc-text">最优题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码-8"><span class="toc-number">9.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#打印1到最大的n位数"><span class="toc-number">10.</span> <span class="toc-text">打印1到最大的n位数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目描述-9"><span class="toc-number">10.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最优题解-9"><span class="toc-number">10.2.</span> <span class="toc-text">最优题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码-9"><span class="toc-number">10.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#在O-1-时间删除链表节点"><span class="toc-number">11.</span> <span class="toc-text">在O(1)时间删除链表节点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目描述-10"><span class="toc-number">11.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最优题解-10"><span class="toc-number">11.2.</span> <span class="toc-text">最优题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码-10"><span class="toc-number">11.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使奇数位于偶数前面"><span class="toc-number">12.</span> <span class="toc-text">使奇数位于偶数前面</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目描述-11"><span class="toc-number">12.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最优题解-11"><span class="toc-number">12.2.</span> <span class="toc-text">最优题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码-11"><span class="toc-number">12.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#链表倒数第k个结点"><span class="toc-number">13.</span> <span class="toc-text">链表倒数第k个结点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目描述-12"><span class="toc-number">13.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最优题解-12"><span class="toc-number">13.2.</span> <span class="toc-text">最优题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码-12"><span class="toc-number">13.3.</span> <span class="toc-text">代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#举一反三-4"><span class="toc-number">13.4.</span> <span class="toc-text">举一反三</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#反转链表"><span class="toc-number">14.</span> <span class="toc-text">反转链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目描述-13"><span class="toc-number">14.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最优题解-13"><span class="toc-number">14.2.</span> <span class="toc-text">最优题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码-13"><span class="toc-number">14.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#合并两个排序的链表"><span class="toc-number">15.</span> <span class="toc-text">合并两个排序的链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目描述-14"><span class="toc-number">15.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最优题解-14"><span class="toc-number">15.2.</span> <span class="toc-text">最优题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码-14"><span class="toc-number">15.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#树的子结构"><span class="toc-number">16.</span> <span class="toc-text">树的子结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目描述-15"><span class="toc-number">16.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最优题解-15"><span class="toc-number">16.2.</span> <span class="toc-text">最优题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码-15"><span class="toc-number">16.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二叉树的镜像"><span class="toc-number">17.</span> <span class="toc-text">二叉树的镜像</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目描述-16"><span class="toc-number">17.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最优题解-16"><span class="toc-number">17.2.</span> <span class="toc-text">最优题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码-16"><span class="toc-number">17.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#顺时针打印矩阵"><span class="toc-number">18.</span> <span class="toc-text">顺时针打印矩阵</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目描述-17"><span class="toc-number">18.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最优题解-17"><span class="toc-number">18.2.</span> <span class="toc-text">最优题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码-17"><span class="toc-number">18.3.</span> <span class="toc-text">代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#举一反三-5"><span class="toc-number">18.4.</span> <span class="toc-text">举一反三</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#包含min函数的栈"><span class="toc-number">19.</span> <span class="toc-text">包含min函数的栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目描述-18"><span class="toc-number">19.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最优题解-18"><span class="toc-number">19.2.</span> <span class="toc-text">最优题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码-18"><span class="toc-number">19.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#栈的压入弹出序列"><span class="toc-number">20.</span> <span class="toc-text">栈的压入弹出序列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目描述-19"><span class="toc-number">20.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最优题解-19"><span class="toc-number">20.2.</span> <span class="toc-text">最优题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码-19"><span class="toc-number">20.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#从上往下打印二叉树"><span class="toc-number">21.</span> <span class="toc-text">从上往下打印二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目描述-20"><span class="toc-number">21.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最优题解-20"><span class="toc-number">21.2.</span> <span class="toc-text">最优题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码-20"><span class="toc-number">21.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二叉搜索树的后序遍历序列"><span class="toc-number">22.</span> <span class="toc-text">二叉搜索树的后序遍历序列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目描述-21"><span class="toc-number">22.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最优题解-21"><span class="toc-number">22.2.</span> <span class="toc-text">最优题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码-21"><span class="toc-number">22.3.</span> <span class="toc-text">代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#举一反三-6"><span class="toc-number">22.4.</span> <span class="toc-text">举一反三</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二叉树中和为某一值的路径"><span class="toc-number">23.</span> <span class="toc-text">二叉树中和为某一值的路径</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目描述-22"><span class="toc-number">23.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最优题解-22"><span class="toc-number">23.2.</span> <span class="toc-text">最优题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码-22"><span class="toc-number">23.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#复杂链表的复制"><span class="toc-number">24.</span> <span class="toc-text">复杂链表的复制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目描述-23"><span class="toc-number">24.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最优题解-23"><span class="toc-number">24.2.</span> <span class="toc-text">最优题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码-23"><span class="toc-number">24.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二叉搜索树与双向链表"><span class="toc-number">25.</span> <span class="toc-text">二叉搜索树与双向链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目描述-24"><span class="toc-number">25.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最优题解-24"><span class="toc-number">25.2.</span> <span class="toc-text">最优题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码-24"><span class="toc-number">25.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#字符串的排列"><span class="toc-number">26.</span> <span class="toc-text">字符串的排列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目描述-25"><span class="toc-number">26.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最优题解-25"><span class="toc-number">26.2.</span> <span class="toc-text">最优题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码-25"><span class="toc-number">26.3.</span> <span class="toc-text">代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#举一反三-7"><span class="toc-number">26.4.</span> <span class="toc-text">举一反三</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数组中出现次数超过一半的数字"><span class="toc-number">27.</span> <span class="toc-text">数组中出现次数超过一半的数字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目描述-26"><span class="toc-number">27.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最优题解-26"><span class="toc-number">27.2.</span> <span class="toc-text">最优题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码-26"><span class="toc-number">27.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#最小的K个数"><span class="toc-number">28.</span> <span class="toc-text">最小的K个数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目描述-27"><span class="toc-number">28.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最优题解-27"><span class="toc-number">28.2.</span> <span class="toc-text">最优题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码-27"><span class="toc-number">28.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#连续子数组的最大和"><span class="toc-number">29.</span> <span class="toc-text">连续子数组的最大和</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目描述-28"><span class="toc-number">29.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最优题解-28"><span class="toc-number">29.2.</span> <span class="toc-text">最优题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码-28"><span class="toc-number">29.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#从1到n中1出现的次数"><span class="toc-number">30.</span> <span class="toc-text">从1到n中1出现的次数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目描述-29"><span class="toc-number">30.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最优题解-29"><span class="toc-number">30.2.</span> <span class="toc-text">最优题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码-29"><span class="toc-number">30.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#把数组排成最小的数"><span class="toc-number">31.</span> <span class="toc-text">把数组排成最小的数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目描述-30"><span class="toc-number">31.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最优题解-30"><span class="toc-number">31.2.</span> <span class="toc-text">最优题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码-30"><span class="toc-number">31.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#丑数"><span class="toc-number">32.</span> <span class="toc-text">丑数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目描述-31"><span class="toc-number">32.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最优题解-31"><span class="toc-number">32.2.</span> <span class="toc-text">最优题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码-31"><span class="toc-number">32.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第一个只出现一次的字符"><span class="toc-number">33.</span> <span class="toc-text">第一个只出现一次的字符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目描述-32"><span class="toc-number">33.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最优题解-32"><span class="toc-number">33.2.</span> <span class="toc-text">最优题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码-32"><span class="toc-number">33.3.</span> <span class="toc-text">代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#举一反三-8"><span class="toc-number">33.4.</span> <span class="toc-text">举一反三</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数组中的逆序对"><span class="toc-number">34.</span> <span class="toc-text">数组中的逆序对</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目描述-33"><span class="toc-number">34.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最优题解-33"><span class="toc-number">34.2.</span> <span class="toc-text">最优题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码-33"><span class="toc-number">34.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#两个链表的第一个公共结点"><span class="toc-number">35.</span> <span class="toc-text">两个链表的第一个公共结点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目描述-34"><span class="toc-number">35.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最优题解-34"><span class="toc-number">35.2.</span> <span class="toc-text">最优题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码-34"><span class="toc-number">35.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数字在排序数组中出现的次数"><span class="toc-number">36.</span> <span class="toc-text">数字在排序数组中出现的次数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目描述-35"><span class="toc-number">36.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最优题解-35"><span class="toc-number">36.2.</span> <span class="toc-text">最优题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码-35"><span class="toc-number">36.3.</span> <span class="toc-text">代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#举一反三-9"><span class="toc-number">36.4.</span> <span class="toc-text">举一反三</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二叉树的深度"><span class="toc-number">37.</span> <span class="toc-text">二叉树的深度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目描述-36"><span class="toc-number">37.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最优题解-36"><span class="toc-number">37.2.</span> <span class="toc-text">最优题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码-36"><span class="toc-number">37.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#判断平衡二叉树"><span class="toc-number">38.</span> <span class="toc-text">判断平衡二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目描述-37"><span class="toc-number">38.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最优题解-37"><span class="toc-number">38.2.</span> <span class="toc-text">最优题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码-37"><span class="toc-number">38.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数组中只出现一次的两个数字"><span class="toc-number">39.</span> <span class="toc-text">数组中只出现一次的两个数字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目描述-38"><span class="toc-number">39.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最优题解-38"><span class="toc-number">39.2.</span> <span class="toc-text">最优题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码-38"><span class="toc-number">39.3.</span> <span class="toc-text">代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#举一反三-10"><span class="toc-number">39.4.</span> <span class="toc-text">举一反三</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#和为s的两个数字"><span class="toc-number">40.</span> <span class="toc-text">和为s的两个数字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目描述-39"><span class="toc-number">40.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最优题解-39"><span class="toc-number">40.2.</span> <span class="toc-text">最优题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码-39"><span class="toc-number">40.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#和为s的连续正整数序列"><span class="toc-number">41.</span> <span class="toc-text">和为s的连续正整数序列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目描述-40"><span class="toc-number">41.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最优题解-40"><span class="toc-number">41.2.</span> <span class="toc-text">最优题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码-40"><span class="toc-number">41.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#翻转单词顺序"><span class="toc-number">42.</span> <span class="toc-text">翻转单词顺序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目描述-41"><span class="toc-number">42.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最优题解-41"><span class="toc-number">42.2.</span> <span class="toc-text">最优题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码-41"><span class="toc-number">42.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#左旋转字符串"><span class="toc-number">43.</span> <span class="toc-text">左旋转字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目描述-42"><span class="toc-number">43.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最优题解-42"><span class="toc-number">43.2.</span> <span class="toc-text">最优题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码-42"><span class="toc-number">43.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#n个骰子的点数"><span class="toc-number">44.</span> <span class="toc-text">n个骰子的点数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目描述-43"><span class="toc-number">44.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最优题解-43"><span class="toc-number">44.2.</span> <span class="toc-text">最优题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码-43"><span class="toc-number">44.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#扑克牌的顺子"><span class="toc-number">45.</span> <span class="toc-text">扑克牌的顺子</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目描述-44"><span class="toc-number">45.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最优题解-44"><span class="toc-number">45.2.</span> <span class="toc-text">最优题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码-44"><span class="toc-number">45.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#圆圈中最后剩下的数字（约瑟夫环问题）"><span class="toc-number">46.</span> <span class="toc-text">圆圈中最后剩下的数字（约瑟夫环问题）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目描述-45"><span class="toc-number">46.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最优题解-45"><span class="toc-number">46.2.</span> <span class="toc-text">最优题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码-45"><span class="toc-number">46.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#求前n项和（各种限制）"><span class="toc-number">47.</span> <span class="toc-text">求前n项和（各种限制）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目描述-46"><span class="toc-number">47.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最优题解-46"><span class="toc-number">47.2.</span> <span class="toc-text">最优题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码-46"><span class="toc-number">47.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#不用加减乘除做加法"><span class="toc-number">48.</span> <span class="toc-text">不用加减乘除做加法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目描述-47"><span class="toc-number">48.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最优题解-47"><span class="toc-number">48.2.</span> <span class="toc-text">最优题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码-47"><span class="toc-number">48.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#把字符串转换成整数"><span class="toc-number">49.</span> <span class="toc-text">把字符串转换成整数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目描述-48"><span class="toc-number">49.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最优题解-48"><span class="toc-number">49.2.</span> <span class="toc-text">最优题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码-48"><span class="toc-number">49.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二叉树的最低公共祖先"><span class="toc-number">50.</span> <span class="toc-text">二叉树的最低公共祖先</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目描述-49"><span class="toc-number">50.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最优题解-49"><span class="toc-number">50.2.</span> <span class="toc-text">最优题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码-49"><span class="toc-number">50.3.</span> <span class="toc-text">代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#举一反三-11"><span class="toc-number">50.4.</span> <span class="toc-text">举一反三</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数组中重复的数字"><span class="toc-number">51.</span> <span class="toc-text">数组中重复的数字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目描述-50"><span class="toc-number">51.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最优题解-50"><span class="toc-number">51.2.</span> <span class="toc-text">最优题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码-50"><span class="toc-number">51.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#构建乘积数组"><span class="toc-number">52.</span> <span class="toc-text">构建乘积数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目描述-51"><span class="toc-number">52.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最优题解-51"><span class="toc-number">52.2.</span> <span class="toc-text">最优题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码-51"><span class="toc-number">52.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#正则表达式匹配"><span class="toc-number">53.</span> <span class="toc-text">正则表达式匹配</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目描述-52"><span class="toc-number">53.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最优题解-52"><span class="toc-number">53.2.</span> <span class="toc-text">最优题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码-52"><span class="toc-number">53.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#表示数值的字符串"><span class="toc-number">54.</span> <span class="toc-text">表示数值的字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目描述-53"><span class="toc-number">54.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最优题解-53"><span class="toc-number">54.2.</span> <span class="toc-text">最优题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码-53"><span class="toc-number">54.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#字符流中第一个不重复的字符"><span class="toc-number">55.</span> <span class="toc-text">字符流中第一个不重复的字符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目描述-54"><span class="toc-number">55.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最优题解-54"><span class="toc-number">55.2.</span> <span class="toc-text">最优题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码-54"><span class="toc-number">55.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#链表中环的入口结点"><span class="toc-number">56.</span> <span class="toc-text">链表中环的入口结点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目描述-55"><span class="toc-number">56.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最优题解-55"><span class="toc-number">56.2.</span> <span class="toc-text">最优题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码-55"><span class="toc-number">56.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#删除链表中重复的结点"><span class="toc-number">57.</span> <span class="toc-text">删除链表中重复的结点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目描述-56"><span class="toc-number">57.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最优题解-56"><span class="toc-number">57.2.</span> <span class="toc-text">最优题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码-56"><span class="toc-number">57.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二叉树的下一个结点（中序）"><span class="toc-number">58.</span> <span class="toc-text">二叉树的下一个结点（中序）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目描述-57"><span class="toc-number">58.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最优题解-57"><span class="toc-number">58.2.</span> <span class="toc-text">最优题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码-57"><span class="toc-number">58.3.</span> <span class="toc-text">代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#举一反三-12"><span class="toc-number">58.4.</span> <span class="toc-text">举一反三</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对称的二叉树"><span class="toc-number">59.</span> <span class="toc-text">对称的二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目描述-58"><span class="toc-number">59.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最优题解-58"><span class="toc-number">59.2.</span> <span class="toc-text">最优题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码-58"><span class="toc-number">59.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#把二叉树打印成多行"><span class="toc-number">60.</span> <span class="toc-text">把二叉树打印成多行</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目描述-59"><span class="toc-number">60.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最优题解-59"><span class="toc-number">60.2.</span> <span class="toc-text">最优题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码-59"><span class="toc-number">60.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#按之字型顺序打印二叉树"><span class="toc-number">61.</span> <span class="toc-text">按之字型顺序打印二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目描述-60"><span class="toc-number">61.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最优题解-60"><span class="toc-number">61.2.</span> <span class="toc-text">最优题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码-60"><span class="toc-number">61.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二叉树的序列化和反序列化"><span class="toc-number">62.</span> <span class="toc-text">二叉树的序列化和反序列化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目描述-61"><span class="toc-number">62.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最优题解-61"><span class="toc-number">62.2.</span> <span class="toc-text">最优题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码-61"><span class="toc-number">62.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二叉搜索树中的第k个结点"><span class="toc-number">63.</span> <span class="toc-text">二叉搜索树中的第k个结点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目描述-62"><span class="toc-number">63.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最优题解-62"><span class="toc-number">63.2.</span> <span class="toc-text">最优题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码-62"><span class="toc-number">63.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据流的中位数"><span class="toc-number">64.</span> <span class="toc-text">数据流的中位数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目描述-63"><span class="toc-number">64.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最优题解-63"><span class="toc-number">64.2.</span> <span class="toc-text">最优题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码-63"><span class="toc-number">64.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#滑动窗口的最大值"><span class="toc-number">65.</span> <span class="toc-text">滑动窗口的最大值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目描述-64"><span class="toc-number">65.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最优题解-64"><span class="toc-number">65.2.</span> <span class="toc-text">最优题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码-64"><span class="toc-number">65.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#矩阵中的路径"><span class="toc-number">66.</span> <span class="toc-text">矩阵中的路径</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目描述-65"><span class="toc-number">66.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最优题解-65"><span class="toc-number">66.2.</span> <span class="toc-text">最优题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码-65"><span class="toc-number">66.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#机器人的运动范围"><span class="toc-number">67.</span> <span class="toc-text">机器人的运动范围</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目描述-66"><span class="toc-number">67.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最优题解-66"><span class="toc-number">67.2.</span> <span class="toc-text">最优题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码-66"><span class="toc-number">67.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#补充-剪绳子"><span class="toc-number">68.</span> <span class="toc-text">补充_剪绳子</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目描述-67"><span class="toc-number">68.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#主要思路"><span class="toc-number">68.2.</span> <span class="toc-text">主要思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码-67"><span class="toc-number">68.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#补充-数字序列中某一位的数字"><span class="toc-number">69.</span> <span class="toc-text">补充_数字序列中某一位的数字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目描述-68"><span class="toc-number">69.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最优题解-67"><span class="toc-number">69.2.</span> <span class="toc-text">最优题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码-68"><span class="toc-number">69.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#补充-把数字翻译成字符串"><span class="toc-number">70.</span> <span class="toc-text">补充_把数字翻译成字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目描述-69"><span class="toc-number">70.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最优题解-68"><span class="toc-number">70.2.</span> <span class="toc-text">最优题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码-69"><span class="toc-number">70.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#补充-礼物的最大值"><span class="toc-number">71.</span> <span class="toc-text">补充_礼物的最大值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目描述-70"><span class="toc-number">71.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最优题解-69"><span class="toc-number">71.2.</span> <span class="toc-text">最优题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码-70"><span class="toc-number">71.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#补充-最长不含重复字符的字符串长度"><span class="toc-number">72.</span> <span class="toc-text">补充_最长不含重复字符的字符串长度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目描述-71"><span class="toc-number">72.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最优题解-70"><span class="toc-number">72.2.</span> <span class="toc-text">最优题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码-71"><span class="toc-number">72.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#补充-股票的最大利润"><span class="toc-number">73.</span> <span class="toc-text">补充_股票的最大利润</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#题目描述-72"><span class="toc-number">73.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最优题解-71"><span class="toc-number">73.2.</span> <span class="toc-text">最优题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码-72"><span class="toc-number">73.3.</span> <span class="toc-text">代码</span></a></li></ol></li></ol>
        
    </div>
    <style>
        .left-col .switch-btn,
        .left-col .switch-area {
            display: none;
        }
        .toc-level-3 i,
        .toc-level-3 ol {
            display: none !important;
        }
    </style>

    <input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">

    <script>
        yiliaConfig.toc = ["隐藏目录", "显示目录", !!"false"];
    </script>



    
<div class="share">
    

    
        <div class="addthis_sharing_toolbox"></div>
    
</div>







    
    <!-- 来必力City版安装代码 -->
<div id="lv-container" data-id="city" data-uid="MTAyMC8zMTA4Ni83NjM0" style="margin-left:30px;margin-right:30px">
<script type="text/javascript">
   (function(d, s) {
       var j, e = d.getElementsByTagName(s)[0];

       if (typeof LivereTower === 'function') { return; }

       j = d.createElement(s);
       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
       j.async = true;

       e.parentNode.insertBefore(j, e);
   })(document, 'script');
</script>
<noscript>为正常使用来必力评论功能请激活JavaScript</noscript>
</div>
<!-- City版安装代码已完成 -->
    




    <div class="scroll" id="post-nav-button">
        
            <a href="/" title="回到主页"><i class="fa fa-home"></i></a>
        

        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>

        
            <a href="/2018/12/06/那些值得阅读的PEP/" title="下一篇: 那些值得阅读的PEP">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>

    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/01/31/剑指offer题解（Python实现）/">剑指offer题解（Python实现）</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/06/那些值得阅读的PEP/">那些值得阅读的PEP</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/23/Python中子类关系的传递性/">Python中子类关系的传递性</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/21/不要在列表（集合、字典）推导式或生成器表达式中使用-yield/">不要在列表（集合、字典）推导式或生成器表达式中使用 yield</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/09/使用vs2017搭建CPython3.6和CPython2.7源码调试环境/">使用vs2017搭建CPython3.6和CPython2.7源码调试环境</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/08/Python循环导入问题/">Python循环导入问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/07/Python字符串驻留机制/">Python字符串驻留机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/15/设计模式之单例模式/">设计模式之单例模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/15/魔法方法之-new-与-init/">魔法方法之 __new__() 与 __init__()</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/05/Python-中-type-与-object-的关系/">Python 中 type 与 object 的关系</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/31/为什么Python的corotine这么特殊/">为什么Python的coroutine这么特殊</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/09/廖雪峰web实战总结/">廖雪峰web实战总结</a></li></ul>




    <script>
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2017-2019 Hk4Fun
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" title="本站到访数"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit"  title="本页阅读量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
            
            
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

    <script>
        var originTitle = document.title;
        var titleTime;
        document.addEventListener("visibilitychange", function() {
            if (document.hidden) {
                document.title = "(つェ⊂) 我藏好了哦~ " + originTitle;
                clearTimeout(titleTime);
            }
            else {
                document.title = "(*´∇｀*) 被你发现啦~ " + originTitle;
                titleTime = setTimeout(function() {
                    document.title = originTitle;
                }, 2000);
            }
        })
    </script>

<script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
<!--prettify代码高亮脚本引入-->
<script src="/plugins/prettify/prettify.js"></script>
<script type="text/javascript">
$(window).load(function(){
$('pre').addClass('prettyprint linenums').attr('style', 'overflow:auto;');
 prettyPrint();
})
</script>
  </div>
</body>
</html>