<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[剑指offer题解（python实现）]]></title>
      <url>/2018/07/19/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3%EF%BC%88python%E5%AE%9E%E7%8E%B0%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>每个题目标题链接到 <a href="https://github.com/Hk4Fun/algorithm_offer/tree/master/target_offer" target="_blank" rel="external">github</a>，可以查看其他的解题思路、测试用例以及拓展题目，这里只贴上书中题目的最优解法和代码。另外，这里参考的是剑指offer第一版的题目顺序，补充部分添加的是剑指offer第二版多出来的几道题目。</p>
<a id="more"></a>
<h2 id="二维数组中的查找"><a href="#二维数组中的查找" class="headerlink" title=" 二维数组中的查找"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/3_1_%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE.py" target="_blank" rel="external"> 二维数组中的查找</a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。<br>请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<h3 id="最优题解"><a href="#最优题解" class="headerlink" title="最优题解"></a>最优题解</h3><p>时间（O（m+n）），空间（O（1））</p>
<p>从右上角或左下角开始查找，这里选择右上角<br>如果当前元素大于target, 剔除target所在列（col左移-1）<br>如果当前元素小于target, 剔除target所在行（row下移+1）<br>否则等于，结束查找<br>每一次查找都在数组的查找范围中剔除一行或一列，每一步都缩小了查找的范围<br>直到找到要查找的数字，或者查找范围为空</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Find</span><span class="params">(self, target, array)</span>:</span></div><div class="line">        i , j = <span class="number">0</span>, len(array[<span class="number">0</span>]) - <span class="number">1</span></div><div class="line">        <span class="keyword">while</span> i &lt; len(array) <span class="keyword">and</span> j &gt;= <span class="number">0</span>:</div><div class="line">            <span class="keyword">if</span> array[i][j] &gt; target:</div><div class="line">                j -= <span class="number">1</span></div><div class="line">            <span class="keyword">elif</span> array[i][j] &lt; target:</div><div class="line">                i += <span class="number">1</span></div><div class="line">            <span class="keyword">else</span>: </div><div class="line">                <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">False</span></div></pre></td></tr></table></figure>
<h3 id="拓展题目"><a href="#拓展题目" class="headerlink" title="拓展题目"></a>拓展题目</h3><ul>
<li><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/3_2_%E6%8E%92%E5%BA%8F%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E4%BB%8E%E5%B0%8F%E5%88%B0%E5%A4%A7%E7%AC%ACk%E4%B8%AA%E6%95%B0.py" target="_blank" rel="external">排序矩阵中从小到大第k个数</a></li>
</ul>
<h2 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/4_%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC.py" target="_blank" rel="external">替换空格</a></h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>请实现一个函数，将一个字符串中的空格替换成“%20”。<br>例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>
<h3 id="最优题解-1"><a href="#最优题解-1" class="headerlink" title="最优题解"></a>最优题解</h3><p>使用内置方法replace最佳，想要自己造轮子见 <a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/4_%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC.py" target="_blank" rel="external">github链接</a></p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">replaceSpace</span><span class="params">(<span class="keyword">self</span>, s)</span></span><span class="symbol">:</span></div><div class="line">        <span class="keyword">return</span> s.replace(<span class="string">' '</span>, <span class="string">'%20'</span>)</div></pre></td></tr></table></figure>
<h2 id="从尾到头打印链表"><a href="#从尾到头打印链表" class="headerlink" title="从尾到头打印链表"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/5_%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8.py" target="_blank" rel="external">从尾到头打印链表</a></h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个链表，从尾到头打印链表每个节点的值（不能改变原链表结构）</p>
<h3 id="最优题解-2"><a href="#最优题解-2" class="headerlink" title="最优题解"></a>最优题解</h3><p>时间（O（n）），空间（O（n））</p>
<p>使用栈，从头到尾扫描，按顺序放入栈中，最后一个个弹出即从尾到头</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, x)</span></span><span class="symbol">:</span></div><div class="line">        <span class="keyword">self</span>.val = x</div><div class="line">        <span class="keyword">self</span>.<span class="keyword">next</span> = None</div><div class="line">		</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="comment"># 返回从尾部到头部的列表值序列</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ListReverse</span><span class="params">(<span class="keyword">self</span>, listNode)</span></span><span class="symbol">:</span></div><div class="line">        res = []</div><div class="line">        <span class="keyword">while</span> <span class="symbol">listNode:</span></div><div class="line">            res.insert(<span class="number">0</span>, listNode.val)</div><div class="line">            listNode = listNode.<span class="keyword">next</span></div><div class="line">        <span class="keyword">return</span> res</div></pre></td></tr></table></figure>
<h2 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/6_1_%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E5%89%8D%E5%BA%8F%E4%B8%AD%E5%BA%8F%EF%BC%89.py" target="_blank" rel="external">重建二叉树</a></h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。<br>假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p>
<h3 id="最优题解-3"><a href="#最优题解-3" class="headerlink" title="最优题解"></a>最优题解</h3><p>前序的第一个元素是根结点的值，在中序中找到该值，<br>中序中该值的左边的元素是根结点的左子树，右边是右子树，然后递归的处理左边和右边</p>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, x)</span></span><span class="symbol">:</span></div><div class="line">        <span class="keyword">self</span>.val = x</div><div class="line">        <span class="keyword">self</span>.left = None</div><div class="line">        <span class="keyword">self</span>.right = None</div><div class="line">		</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="comment"># 返回构造的TreeNode根节点</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reConstruct</span><span class="params">(<span class="keyword">self</span>, pre, tin)</span></span><span class="symbol">:</span></div><div class="line">        <span class="comment"># write code here</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pre <span class="keyword">or</span> <span class="keyword">not</span> <span class="symbol">tin:</span> <span class="keyword">return</span></div><div class="line">        idx = tin.index(pre[<span class="number">0</span>])</div><div class="line">        root = TreeNode(pre[<span class="number">0</span>])</div><div class="line">        root.left = <span class="keyword">self</span>.reConstruct(pre[<span class="number">1</span><span class="symbol">:idx+</span><span class="number">1</span>], tin[<span class="symbol">:idx</span>])</div><div class="line">        root.right = <span class="keyword">self</span>.reConstruct(pre[idx+<span class="number">1</span><span class="symbol">:</span>], tin[idx+<span class="number">1</span><span class="symbol">:</span>])</div><div class="line">        <span class="keyword">return</span> root</div></pre></td></tr></table></figure>
<h3 id="举一反三"><a href="#举一反三" class="headerlink" title="举一反三"></a>举一反三</h3><ul>
<li><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/6_2_%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E4%B8%AD%E5%BA%8F%E5%90%8E%E5%BA%8F%EF%BC%89.py" target="_blank" rel="external">重建二叉树（中序后序）</a></li>
</ul>
<h2 id="用两个栈实现队列"><a href="#用两个栈实现队列" class="headerlink" title="用两个栈实现队列"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/7_1_%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97.py" target="_blank" rel="external">用两个栈实现队列</a></h2><h3 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h3><p>用两个栈来实现一个队列，完成队列的入队和出队操作</p>
<h3 id="最优题解-4"><a href="#最优题解-4" class="headerlink" title="最优题解"></a>最优题解</h3><p>stack1用来入队，stack2用来出队<br>出队时若stack2有数据直接弹出，无数据就要把stack1中的全部弹出并压入stack2，然后stack2继续出队<br>入队时不管stack1有没有数据，直接压入</p>
<h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></div><div class="line">        <span class="keyword">self</span>.stack1 = []</div><div class="line">        <span class="keyword">self</span>.stack2 = []</div><div class="line">		</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">In</span><span class="params">(<span class="keyword">self</span>, x)</span></span>:  <span class="comment"># 入队时不管stack1有没有数据，直接压入</span></div><div class="line">        <span class="keyword">self</span>.stack1.append(x)</div><div class="line">		</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Out</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">self</span>.stack1 <span class="keyword">and</span> <span class="keyword">not</span> <span class="keyword">self</span>.<span class="symbol">stack2:</span></div><div class="line">            <span class="keyword">return</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">self</span>.<span class="symbol">stack2:</span>  <span class="comment"># stack2无数据就要把stack1中的全部弹出并压入stack2</span></div><div class="line">            <span class="keyword">while</span> <span class="keyword">self</span>.<span class="symbol">stack1:</span></div><div class="line">                <span class="keyword">self</span>.stack2.append(<span class="keyword">self</span>.stack1.pop())</div><div class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.stack2.pop()  <span class="comment"># stack2继续出队</span></div></pre></td></tr></table></figure>
<h3 id="举一反三-1"><a href="#举一反三-1" class="headerlink" title="举一反三"></a>举一反三</h3><ul>
<li><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/7_2_%E7%94%A8%E4%B8%A4%E4%B8%AA%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88.py" target="_blank" rel="external">用两个队列实现栈</a></li>
</ul>
<h2 id="旋转数组的最小数字"><a href="#旋转数组的最小数字" class="headerlink" title="旋转数组的最小数字"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/8_%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97.py" target="_blank" rel="external">旋转数组的最小数字</a></h2><h3 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h3><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。<br>输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。<br>例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。</p>
<h3 id="最优题解-5"><a href="#最优题解-5" class="headerlink" title="最优题解"></a>最优题解</h3><p>部分排序，则可用二分查找，注意在等于的时候让high-1，顺序查找，退化成O(n)（注意到[1,0,1,1,1]和[1,1,1,0,1]的区别，此时无法判断最小值在哪边，故只能用顺序查找）：</p>
<ul>
<li>array[mid] &gt; array[high]</li>
</ul>
<p>出现这种情况的array类似[3,4,5,6,0,1,2]，此时最小数字一定在mid的右边<br>low = mid + 1</p>
<ul>
<li>array[mid] == array[high]</li>
</ul>
<p>出现这种情况的array类似 [1,0,1,1,1] 或者[1,1,1,0,1]，此时最小数字不好判断在mid左边还是右边,这时只好一个一个试<br>high = high - 1</p>
<ul>
<li>array[mid] &lt; array[high]</li>
</ul>
<p>出现这种情况的array类似[2,2,3,4,5,6,6]，此时最小数字一定就是array[mid]或者在mid的左边，因为右边必然都是递增的<br>若 mid = 0 ,说明low与high之间未发生旋转，最小数字就是array[mid]，或者array[mid-1]&gt;array[mid]，则最小数字也是array[mid]<br>否则mid不为零且array[mid-1]&lt;=array[mid]，最小数字在mid的左边，high = mid - 1</p>
<h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minNumber</span><span class="params">(<span class="keyword">self</span>, rotateArray)</span></span><span class="symbol">:</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="symbol">rotateArray:</span> <span class="keyword">return</span> <span class="number">0</span></div><div class="line">        l, r = <span class="number">0</span>, len(rotateArray) - <span class="number">1</span></div><div class="line">        <span class="keyword">while</span> l &lt;= <span class="symbol">r:</span></div><div class="line">            m = l + ((r - l) <span class="meta">&gt;&gt; </span><span class="number">1</span>)</div><div class="line">            <span class="keyword">if</span> rotateArray[m] &gt; rotateArray[-<span class="number">1</span>]<span class="symbol">:</span></div><div class="line">                l = m + <span class="number">1</span></div><div class="line">            elif rotateArray[m] &lt; rotateArray[-<span class="number">1</span>]<span class="symbol">:</span></div><div class="line">                <span class="keyword">if</span> m == <span class="number">0</span> <span class="keyword">or</span> rotateArray[m - <span class="number">1</span>] &gt; rotateArray[m]<span class="symbol">:</span></div><div class="line">                    <span class="keyword">return</span> rotateArray[m]</div><div class="line">                <span class="symbol">else:</span></div><div class="line">                    r = m - <span class="number">1</span></div><div class="line">            <span class="symbol">else:</span></div><div class="line">                r -= <span class="number">1</span></div></pre></td></tr></table></figure>
<h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/9_1_%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97.py" target="_blank" rel="external">斐波那契数列</a></h2><h3 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个整数n，输出斐波那契数列的第n项f(n)（n从0开始，f(0)=0，f(1)=1）</p>
<h3 id="最优题解-6"><a href="#最优题解-6" class="headerlink" title="最优题解"></a>最优题解</h3><p>a, b = b, a + b</p>
<h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">self</span>, n)</span></span><span class="symbol">:</span></div><div class="line">        a, b = <span class="number">0</span>, <span class="number">1</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n)<span class="symbol">:</span></div><div class="line">            a, b = b, a + b</div><div class="line">        <span class="keyword">return</span> a</div></pre></td></tr></table></figure>
<h3 id="举一反三-2"><a href="#举一反三-2" class="headerlink" title="举一反三"></a>举一反三</h3><ul>
<li><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/9_2_%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6.py" target="_blank" rel="external">青蛙跳台阶</a></li>
<li><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/9_3_%E5%8F%98%E6%80%81%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6.py" target="_blank" rel="external">变态青蛙跳台阶</a></li>
<li><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/9_4_%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%96.py" target="_blank" rel="external">矩形覆盖</a></li>
</ul>
<h2 id="二进制中1的个数"><a href="#二进制中1的个数" class="headerlink" title="二进制中1的个数"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/10_1_%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0.py" target="_blank" rel="external">二进制中1的个数</a></h2><h3 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p>
<h3 id="最优题解-7"><a href="#最优题解-7" class="headerlink" title="最优题解"></a>最优题解</h3><p>利用一个位运算技巧：一个整数减1后总是把它二进制表示的最右边的1变为0<br>这里有两种情况：最右边的1在最末位和不在最末位<br>但无论怎样，减一后的数与原数相与就一定可以把最右的1变为0<br>有一点要注意：由于c/c++/java中int位数限定32位，所以n最后一定被全部变为0，循环退出；<br>但python就有区别了，python的整数位数不止32位，所以在负数情况下1的位数会多出很多，所以应先&amp;0xffffffff，保留后面32位，前面全部变成0</p>
<h3 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">self</span>, n)</span></span><span class="symbol">:</span></div><div class="line">        n &amp;= <span class="number">0xffffffff</span></div><div class="line">        count = <span class="number">0</span></div><div class="line">        <span class="keyword">while</span> <span class="symbol">n:</span></div><div class="line">            n &amp;= n - <span class="number">1</span></div><div class="line">            count += <span class="number">1</span></div><div class="line">        <span class="keyword">return</span> count <span class="keyword">if</span> n &gt;= <span class="number">0</span> <span class="keyword">else</span> count + <span class="number">1</span></div></pre></td></tr></table></figure>
<h3 id="举一反三-3"><a href="#举一反三-3" class="headerlink" title="举一反三"></a>举一反三</h3><ul>
<li><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/10_2_2%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9.py" target="_blank" rel="external">2的整数次方</a></li>
<li><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/10_3_%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB.py" target="_blank" rel="external">汉明距离</a></li>
</ul>
<h2 id="数值的整数次方"><a href="#数值的整数次方" class="headerlink" title="数值的整数次方"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/11_%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9.py" target="_blank" rel="external">数值的整数次方</a></h2><h3 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方</p>
<h3 id="最优题解-8"><a href="#最优题解-8" class="headerlink" title="最优题解"></a>最优题解</h3><p>注意点：</p>
<ol>
<li>base = 0 且 exponent &lt; 0 时发生除零错误；</li>
<li>exponent &lt; 0 时要作倒数；</li>
<li>0^0=1</li>
<li>判断 base 是否等于 0 时不能直接 == ，因为base为浮点数，有误差。如果两个小数的差的绝对值很小，比如小于0.0000001，就可以认为它们相等；</li>
<li>乘方可以考虑用快速幂（递归实现）</li>
</ol>
<h3 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Power</span><span class="params">(<span class="keyword">self</span>, base, exponent)</span></span><span class="symbol">:</span></div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">is_equal</span><span class="params">(num1, num2)</span></span><span class="symbol">:</span></div><div class="line">            <span class="keyword">return</span> abs(num1 - num2) &lt; <span class="number">0</span>.<span class="number">0000001</span></div><div class="line">			</div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">PowerWithUnsignedExponent</span><span class="params">(base, exponent)</span></span><span class="symbol">:</span></div><div class="line">            <span class="keyword">if</span> exponent == <span class="number">0</span><span class="symbol">:</span></div><div class="line">                <span class="keyword">return</span> <span class="number">1</span></div><div class="line">            <span class="keyword">if</span> exponent == <span class="number">1</span><span class="symbol">:</span></div><div class="line">                <span class="keyword">return</span> base</div><div class="line">            result = PowerWithUnsignedExponent(base, exponent <span class="meta">&gt;&gt; </span><span class="number">1</span>)  <span class="comment"># 除2用位运算</span></div><div class="line">            result *= result</div><div class="line">            <span class="keyword">if</span> exponent &amp; <span class="number">1</span> == <span class="number">1</span>:  <span class="comment"># 判奇偶模2用位运算</span></div><div class="line">                result *= base</div><div class="line">            <span class="keyword">return</span> result</div><div class="line">			</div><div class="line">        <span class="keyword">if</span> is_equal(base, <span class="number">0</span>.<span class="number">0</span>) <span class="keyword">and</span> exponent &lt; <span class="number">0</span><span class="symbol">:</span></div><div class="line">            <span class="keyword">return</span></div><div class="line">        result = PowerWithUnsignedExponent(base, abs(exponent))</div><div class="line">        <span class="keyword">if</span> exponent &lt; <span class="number">0</span><span class="symbol">:</span></div><div class="line">            <span class="keyword">return</span> <span class="number">1.0</span> / result</div><div class="line">        <span class="keyword">return</span> result</div></pre></td></tr></table></figure>
<h2 id="打印1到最大的n位数"><a href="#打印1到最大的n位数" class="headerlink" title="打印1到最大的n位数"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/12_%E6%89%93%E5%8D%B01%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0.py" target="_blank" rel="external">打印1到最大的n位数</a></h2><h3 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入数字n, 按顺序打印从1最大的n位十进制数，比如输入3, 则打印出1、2、3、到最大的3位数即999<br>（这里不打印，而是返回一个list）</p>
<h3 id="最优题解-9"><a href="#最优题解-9" class="headerlink" title="最优题解"></a>最优题解</h3><p>由于没有位数限制，所以要考虑大数问题，用字符串或数组表示大数<br>需要注意的问题是字符串或者数组的最高位对于数字上的最低位<br>在字符串表达的数字上模拟加法，然后将字符串表达的数值打印出来</p>
<h3 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Print1ToMaxOfNDigits</span><span class="params">(self, n)</span>:</span></div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">RmStartZero</span><span class="params">(number)</span>:</span>  <span class="comment"># 去掉前面多余的0</span></div><div class="line">            <span class="keyword">if</span> int(<span class="string">''</span>.join(number)) == <span class="number">0</span>:  <span class="comment"># 全0直接返回</span></div><div class="line">                <span class="keyword">return</span> number</div><div class="line">            num = number[:]  <span class="comment"># 拷贝，因为pop操作会修改number的长度</span></div><div class="line">            <span class="keyword">while</span> <span class="keyword">not</span> int(num[<span class="number">0</span>]):</div><div class="line">                num.pop(<span class="number">0</span>)</div><div class="line">            <span class="keyword">return</span> num</div><div class="line">			</div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">Increment</span><span class="params">(number)</span>:</span></div><div class="line">            isOverflow = <span class="keyword">False</span></div><div class="line">            nTakeOver = <span class="number">0</span></div><div class="line">            nLength = len(number)</div><div class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(nLength - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</div><div class="line">                nSum = int(number[i]) + nTakeOver</div><div class="line">                <span class="keyword">if</span> i == nLength - <span class="number">1</span>:</div><div class="line">                    nSum += <span class="number">1</span></div><div class="line">                <span class="keyword">if</span> nSum &gt;= <span class="number">10</span>:</div><div class="line">                    <span class="keyword">if</span> i == <span class="number">0</span>:</div><div class="line">                        isOverflow = <span class="keyword">True</span></div><div class="line">                    <span class="keyword">else</span>:</div><div class="line">                        nSum -= <span class="number">10</span></div><div class="line">                        nTakeOver = <span class="number">1</span></div><div class="line">                        number[i] = str(nSum)</div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    number[i] = str(nSum)</div><div class="line">                    <span class="keyword">break</span></div><div class="line">            <span class="keyword">return</span> isOverflow</div><div class="line">			</div><div class="line">        <span class="keyword">if</span> n &lt;= <span class="number">0</span>: <span class="keyword">return</span></div><div class="line">        res = []</div><div class="line">        number = [<span class="string">'0'</span>] * n</div><div class="line">        <span class="keyword">while</span> <span class="keyword">not</span> Increment(number):</div><div class="line">            res.append(<span class="string">''</span>.join(RmStartZero(number)))</div><div class="line">        <span class="keyword">return</span> res</div></pre></td></tr></table></figure>
<h2 id="在O-1-时间删除链表节点"><a href="#在O-1-时间删除链表节点" class="headerlink" title="在O(1)时间删除链表节点"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/13_%E5%9C%A8O%281%29%E6%97%B6%E9%97%B4%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E8%8A%82%E7%82%B9.py" target="_blank" rel="external">在O(1)时间删除链表节点</a></h2><h3 id="题目描述-10"><a href="#题目描述-10" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定单向链表的头指针和一个结点指针,定义一个函数在O(1)时间删除该结点</p>
<h3 id="最优题解-10"><a href="#最优题解-10" class="headerlink" title="最优题解"></a>最优题解</h3><p>不必顺序查找到结点i的前一个节点再删除，这样是O(n)，<br>要删除结点i，可以先把i的下一个结点j的内容复制到i，然后把i的指针指向j的下一个结点，<br>最后再删除结点j，其效果刚好是把结点i给删除了<br>即：当我们想删除一个结点时，并不一定要删除这个结点本身，<br>可以先把下一个结点的内容复制出来覆盖被删除结点的内容，然后把下一个结点删除<br>考虑两种特殊情况：<br>1、如果要删除的是尾结点，它没有下一个结点，此时只能从头开始顺序遍历得到该节点的前序结点，并完成删除<br>2、如果链表中只有一个结点，即要删除的节点是头结点（它连前序结点都没有），需要单独处理（删除后设为NULL）</p>
<h3 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x=None)</span>:</span></div><div class="line">        self.val = x</div><div class="line">        self.next = <span class="keyword">None</span></div><div class="line">		</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(self)</span>:</span></div><div class="line">        self.val = <span class="keyword">None</span></div><div class="line">        self.next = <span class="keyword">None</span></div><div class="line">		</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">DeleteNode</span><span class="params">(self, ListHead, ToBeDeleted)</span>:</span></div><div class="line">        <span class="comment"># 返回删除后链表的头结点</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> ListHead <span class="keyword">or</span> <span class="keyword">not</span> ToBeDeleted:   <span class="keyword">return</span> <span class="comment"># 头结点和要删除结点都为空返回None</span></div><div class="line">        <span class="keyword">if</span> ToBeDeleted.next != <span class="keyword">None</span>:  <span class="comment"># 要删除的结点不是尾结点</span></div><div class="line">            Next = ToBeDeleted.next</div><div class="line">            ToBeDeleted.val = Next.val</div><div class="line">            ToBeDeleted.next = Next.next</div><div class="line">            Next.delete()</div><div class="line">        <span class="keyword">elif</span> ListHead == ToBeDeleted:  <span class="comment"># 要删除的结点是头结点</span></div><div class="line">            ListHead.delete()</div><div class="line">            ToBeDeleted.delete()</div><div class="line">        <span class="keyword">else</span>:  <span class="comment"># 要删除的结点是尾结点</span></div><div class="line">            Node = ListHead</div><div class="line">            <span class="keyword">while</span> Node.next != ToBeDeleted:</div><div class="line">                Node = Node.next</div><div class="line">            Node.next = <span class="keyword">None</span></div><div class="line">            ToBeDeleted.delete()</div><div class="line">        <span class="keyword">return</span> ListHead</div></pre></td></tr></table></figure>
<h2 id="使奇数位于偶数前面"><a href="#使奇数位于偶数前面" class="headerlink" title="使奇数位于偶数前面"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/14_%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2.py" target="_blank" rel="external">使奇数位于偶数前面</a></h2><h3 id="题目描述-11"><a href="#题目描述-11" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，<br>使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，<br>并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p>
<h3 id="最优题解-11"><a href="#最优题解-11" class="headerlink" title="最优题解"></a>最优题解</h3><p>时间（O（n）），空间（O（n））</p>
<p>首先统计奇数的个数i，然后新建一个等长数组，遍历原数组。<br>设置两个指针， 奇数从0开始复制，偶数从i开始（奇数末尾）。<br>稳定排序，时间复杂度降下来了，但空间复杂度提高了。</p>
<h3 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reOrderArray</span><span class="params">(self, array)</span>:</span></div><div class="line">        odd = <span class="number">0</span></div><div class="line">        even = sum(i &amp; <span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> array)</div><div class="line">        res = [<span class="number">0</span>] * len(array)</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> array:</div><div class="line">            <span class="keyword">if</span> i &amp; <span class="number">1</span>:</div><div class="line">                res[odd] = i</div><div class="line">                odd += <span class="number">1</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                res[even] = i</div><div class="line">                even += <span class="number">1</span></div><div class="line">        <span class="keyword">return</span> res</div></pre></td></tr></table></figure>
<h2 id="链表倒数第k个结点"><a href="#链表倒数第k个结点" class="headerlink" title="链表倒数第k个结点"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/15_1_%E9%93%BE%E8%A1%A8%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9.py" target="_blank" rel="external">链表倒数第k个结点</a></h2><h3 id="题目描述-12"><a href="#题目描述-12" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个单向链表，输出该链表中倒数第k个结点。</p>
<h3 id="最优题解-12"><a href="#最优题解-12" class="headerlink" title="最优题解"></a>最优题解</h3><p>双指针。<br>定义两个指针，第一个先从头开始走k-1步，第二个保持不动；<br>从第k步开始，第二个指针也开始从头遍历。<br>由于两个指针的距离保持在k-1，<br>所以当第一个指针来到链表尾结点时第二个指针正好来到倒数第k个结点: n-(k-1)</p>
<h3 id="代码-12"><a href="#代码-12" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindKthToTail</span><span class="params">(self, head, k)</span>:</span></div><div class="line">        fast = head</div><div class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> k:</div><div class="line">            fast = fast.next</div><div class="line">            k -= <span class="number">1</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> fast <span class="keyword">and</span> k: <span class="keyword">return</span> <span class="comment"># k 大于链表长度</span></div><div class="line">        slow = head</div><div class="line">        <span class="keyword">while</span> fast:</div><div class="line">            fast = fast.next</div><div class="line">            slow = slow.next</div><div class="line">        <span class="keyword">return</span> slow</div></pre></td></tr></table></figure>
<h3 id="举一反三-4"><a href="#举一反三-4" class="headerlink" title="举一反三"></a>举一反三</h3><ul>
<li><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/15_2_%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%97%B4%E7%BB%93%E7%82%B9.py" target="_blank" rel="external">链表中间结点</a></li>
<li><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/15_3_%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E5%90%AB%E7%8E%AF.py" target="_blank" rel="external">判断链表是否含环</a></li>
<li><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/15_4_%E5%90%AB%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E5%85%A5%E5%8F%A3%E7%82%B9.py" target="_blank" rel="external">含环链表的入口点</a></li>
<li><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/15_5_%E5%90%AB%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E9%95%BF%E5%BA%A6%E5%92%8C%E7%8E%AF%E7%9A%84%E9%95%BF%E5%BA%A6.py" target="_blank" rel="external">含环链表的长度和环的长度</a></li>
<li><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/15_6_%E6%97%A0%E7%8E%AF%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E7%9B%B8%E4%BA%A4.py" target="_blank" rel="external">无环单向链表的相交</a></li>
</ul>
<h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/16_%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8.py" target="_blank" rel="external">反转链表</a></h2><h3 id="题目描述-13"><a href="#题目描述-13" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个链表的头结点，反转该链表并输出反转后链表的头结点</p>
<h3 id="最优题解-13"><a href="#最优题解-13" class="headerlink" title="最优题解"></a>最优题解</h3><p>定义三个指针，分别指向当前遍历到的结点、它的前一个结点以及后一个结点<br>指向后一个结点的指针是为了防止链表断裂，因为需要把当前结点的下一个指针指向前一个结点</p>
<h3 id="代码-13"><a href="#代码-13" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></div><div class="line">        self.val = x</div><div class="line">        self.next = <span class="keyword">None</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="comment"># 返回ListNode</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ReverseList</span><span class="params">(self, pHead)</span>:</span></div><div class="line">        <span class="comment"># write code here</span></div><div class="line">        pre, cur = <span class="keyword">None</span>, pHead</div><div class="line">        <span class="keyword">while</span> cur:</div><div class="line">            cur.next, cur, pre = pre, cur.next, cur</div><div class="line">            <span class="comment"># 上面的一行相当于下面四行</span></div><div class="line">            <span class="comment"># next = cur.next  # 先保存下一个结点防止断裂</span></div><div class="line">            <span class="comment"># cur.next = pre</span></div><div class="line">            <span class="comment"># pre = cur</span></div><div class="line">            <span class="comment"># cur = next</span></div><div class="line">        <span class="keyword">return</span> pre</div></pre></td></tr></table></figure>
<h2 id="合并两个排序的链表"><a href="#合并两个排序的链表" class="headerlink" title="合并两个排序的链表"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/17_%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8.py" target="_blank" rel="external">合并两个排序的链表</a></h2><h3 id="题目描述-14"><a href="#题目描述-14" class="headerlink" title="题目描述"></a>题目描述</h3><p>合并两个单调递增的链表，使得合并后的链表仍然单调递增</p>
<h3 id="最优题解-14"><a href="#最优题解-14" class="headerlink" title="最优题解"></a>最优题解</h3><p>使用一个尾指针，每次比较把较小的结点连接到尾结点后面，记得最后将剩余的链表链接到尾结点后面</p>
<h3 id="代码-14"><a href="#代码-14" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="comment"># 返回合并后的链表头结点</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Merge</span><span class="params">(self, pHead1, pHead2)</span>:</span></div><div class="line">        tail = dummy = ListNode(<span class="number">0</span>) </div><div class="line">        cur1, cur2 = pHead1, pHead2</div><div class="line">        <span class="keyword">while</span> cur1 <span class="keyword">and</span> cur2:</div><div class="line">            <span class="keyword">if</span> cur1.val &lt;= cur2.val:</div><div class="line">                tail.next = cur1</div><div class="line">                cur1 = cur1.next</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                tail.next = cur2</div><div class="line">                cur2 = cur2.next</div><div class="line">            tail = tail.next</div><div class="line">        tail.next = cur1 <span class="keyword">or</span> cur2 <span class="comment"># 最后将剩余的链表链接到尾结点后面</span></div><div class="line">        <span class="keyword">return</span> dummy.next <span class="comment"># 伪结点的下一个结点才是真正的头结点</span></div></pre></td></tr></table></figure>
<h2 id="树的子结构"><a href="#树的子结构" class="headerlink" title="树的子结构"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/18_%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84.py" target="_blank" rel="external">树的子结构</a></h2><h3 id="题目描述-15"><a href="#题目描述-15" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入两棵二叉树A，B，判断B是不是A的子结构（空树不是任意一个树的子结构）</p>
<h3 id="最优题解-15"><a href="#最优题解-15" class="headerlink" title="最优题解"></a>最优题解</h3><p>先递归遍历（先序遍历）树A，找到相同的根结点子树，<br>再用递归分别判断该子树的左右子树是否与B一样，递归结束的条件是来到B的叶结点</p>
<h3 id="代码-15"><a href="#代码-15" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></div><div class="line">        self.val = x</div><div class="line">        self.left = <span class="keyword">None</span></div><div class="line">        self.right = <span class="keyword">None</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="comment"># pRoot1是A的根节点，pRoot2是B的根节点</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">HasSubtree</span><span class="params">(self, pRoot1, pRoot2)</span>:</span></div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">check</span><span class="params">(root1, root2)</span>:</span></div><div class="line">            <span class="comment"># 用于递归判断树的每个节点是否相同</span></div><div class="line">            <span class="comment"># 需要注意的地方是: 前两个if语句不可以颠倒顺序</span></div><div class="line">            <span class="comment"># 如果颠倒顺序, 会先判断pRoot1是否为None,</span></div><div class="line">            <span class="comment"># 其实这个时候pRoot2的结点已经遍历完成确定相等了,</span></div><div class="line">            <span class="comment"># 但是返回了False, 判断错误</span></div><div class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root2:</div><div class="line">                <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root1:</div><div class="line">                <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">            <span class="keyword">if</span> root1.val != root2.val:</div><div class="line">                <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">            <span class="keyword">return</span> check(root1.left, root2.left) <span class="keyword">and</span> check(root1.right, root2.right)</div><div class="line">			</div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot1 <span class="keyword">or</span> <span class="keyword">not</span> pRoot2: <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">        <span class="keyword">if</span> check(pRoot1, pRoot2):</div><div class="line">            <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">        <span class="keyword">return</span> self.HasSubtree(pRoot1.left, pRoot2) <span class="keyword">or</span> self.HasSubtree(pRoot1.right, pRoot2)</div></pre></td></tr></table></figure>
<h2 id="二叉树的镜像"><a href="#二叉树的镜像" class="headerlink" title="二叉树的镜像"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/19_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F.py" target="_blank" rel="external">二叉树的镜像</a></h2><h3 id="题目描述-16"><a href="#题目描述-16" class="headerlink" title="题目描述"></a>题目描述</h3><p>将给定的二叉树变换为原二叉树的镜像。</p>
<h3 id="最优题解-16"><a href="#最优题解-16" class="headerlink" title="最优题解"></a>最优题解</h3><p>递归实现，前序遍历二叉树的每个结点，<br>如果遍历到的结点有子结点，就交换它的两个子结点，<br>当交换完所有的非叶子结点的左右子结点之后，就得到了树的镜像</p>
<h3 id="代码-16"><a href="#代码-16" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></div><div class="line">        self.val = x</div><div class="line">        self.left = <span class="keyword">None</span></div><div class="line">        self.right = <span class="keyword">None</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="comment"># 返回镜像树的根节点</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Mirror</span><span class="params">(self, root)</span>:</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></div><div class="line">        root.left, root.right = root.right, root.left</div><div class="line">        self.Mirror(root.left)</div><div class="line">        self.Mirror(root.right)</div><div class="line">		<span class="keyword">return</span> root</div></pre></td></tr></table></figure>
<h2 id="顺时针打印矩阵"><a href="#顺时针打印矩阵" class="headerlink" title="顺时针打印矩阵"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/20_%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5.py" target="_blank" rel="external">顺时针打印矩阵</a></h2><h3 id="题目描述-17"><a href="#题目描述-17" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，<br>例如，如果输入如下矩阵：<br>[[ 1,  2,  3,  4],<br> [ 5,  6,  7,  8],<br> [ 9, 10, 11, 12],<br> [13, 14, 15, 16]]<br>则依次打印出数字 1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</p>
<h3 id="最优题解-17"><a href="#最优题解-17" class="headerlink" title="最优题解"></a>最优题解</h3><p>时间O（n*m）, 空间（1）</p>
<p>由外向内一圈一圈打印，每一圈从左上角开始顺时针打印<br>左上角的坐标总是x=y，标记为（start,start）,<br>由于每打印一圈，行列都减少2，所以圈数=(min(行，列)+1)//2<br>每一圈的打印分四个步骤，且这四个步骤的执行是有条件的，因为里面那一圈并不完整：</p>
<p><img src="http://ox186n2j0.bkt.clouddn.com/1532004575597.jpg" alt="（注意四个步骤的交界处，避免漏或重）"></p>
<ol>
<li>从左到右打印一行，条件：当前打印圈的行数&gt;=1且列数&gt;=1（这个条件可以忽略，因为至少要执行第一步）</li>
<li>从上到下打印一列，条件：当前打印圈的行数&gt;=2且列数&gt;=1</li>
<li>从右到左打印一行，条件：当前打印圈的行数&gt;=2且列数&gt;=2</li>
<li>从下到上打印一列，条件：当前打印圈的行数&gt;=3且列数&gt;=2</li>
</ol>
<h3 id="代码-17"><a href="#代码-17" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="comment"># matrix类型为二维列表，需要返回列表</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">PrintMatrix1</span><span class="params">(self, matrix)</span>:</span></div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">PrintMatrixInCircle</span><span class="params">(matrix, result, cols, rows, start)</span>:</span></div><div class="line">            endX = cols + start - <span class="number">1</span></div><div class="line">            endY = rows + start - <span class="number">1</span></div><div class="line">			</div><div class="line">            <span class="comment"># 从左到右打印一行</span></div><div class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(start, endX + <span class="number">1</span>):</div><div class="line">                result.append(matrix[start][i])</div><div class="line">				</div><div class="line">            <span class="comment"># 从上到下打印一列</span></div><div class="line">            <span class="keyword">if</span> cols &gt;= <span class="number">1</span> <span class="keyword">and</span> rows &gt;= <span class="number">2</span>:</div><div class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(start + <span class="number">1</span>, endY + <span class="number">1</span>):</div><div class="line">                    result.append(matrix[i][endX])</div><div class="line">					</div><div class="line">            <span class="comment"># 从右到左打印一行</span></div><div class="line">            <span class="keyword">if</span> cols &gt;= <span class="number">2</span> <span class="keyword">and</span> rows &gt;= <span class="number">2</span>:</div><div class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(endX - <span class="number">1</span>, start - <span class="number">1</span>, <span class="number">-1</span>):</div><div class="line">                    result.append(matrix[endY][i])</div><div class="line">					</div><div class="line">            <span class="comment"># 从下到上打印一列</span></div><div class="line">            <span class="keyword">if</span> cols &gt;= <span class="number">2</span> <span class="keyword">and</span> rows &gt;= <span class="number">3</span>:</div><div class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(endY - <span class="number">1</span>, start, <span class="number">-1</span>):</div><div class="line">                    result.append(matrix[i][start])</div><div class="line">					</div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix: <span class="keyword">return</span></div><div class="line">        rows, cols = len(matrix), len(matrix[<span class="number">0</span>])</div><div class="line">        result = []</div><div class="line">        <span class="keyword">for</span> start <span class="keyword">in</span> range((min(rows, cols) + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>):</div><div class="line">            PrintMatrixInCircle(matrix, result, cols - (start &lt;&lt; <span class="number">1</span>), rows - (start &lt;&lt; <span class="number">1</span>), start)</div><div class="line">        <span class="keyword">return</span> result</div></pre></td></tr></table></figure>
<h2 id="包含min函数的栈"><a href="#包含min函数的栈" class="headerlink" title="包含min函数的栈"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/21_%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88.py" target="_blank" rel="external">包含min函数的栈</a></h2><h3 id="题目描述-18"><a href="#题目描述-18" class="headerlink" title="题目描述"></a>题目描述</h3><p>定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的min函数。<br>在该栈中，调用min、push及pop的时间复杂度都是O(1)</p>
<h3 id="最优题解-18"><a href="#最优题解-18" class="headerlink" title="最优题解"></a>最优题解</h3><p>设置一个辅助栈，每次入栈时把最小元素<br>（之前的最小值（辅助栈栈顶）和新压入栈的元素两者的较小值）保存在辅助栈中<br>出栈时辅助栈一起出栈，这样就可以保证辅助栈的栈顶是最小值</p>
<h3 id="代码-18"><a href="#代码-18" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.stack = []</div><div class="line">        self.minstack = []</div><div class="line">		</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, node)</span>:</span></div><div class="line">        self.stack.append(node)</div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.minstack <span class="keyword">or</span> node &lt;= self.min():</div><div class="line">            self.minstack.append(node)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            self.minstack.append(self.min())</div><div class="line">			</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.stack: <span class="keyword">return</span></div><div class="line">        self.minstack.pop()</div><div class="line">        <span class="keyword">return</span> self.stack.pop()</div><div class="line">		</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.stack <span class="keyword">if</span> self.stack <span class="keyword">else</span> <span class="keyword">None</span></div><div class="line">		</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">min</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.minstack[<span class="number">-1</span>] <span class="keyword">if</span> self.minstack <span class="keyword">else</span> <span class="keyword">None</span></div></pre></td></tr></table></figure>
<h2 id="栈的压入弹出序列"><a href="#栈的压入弹出序列" class="headerlink" title="栈的压入弹出序列"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/22_%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97.py" target="_blank" rel="external">栈的压入弹出序列</a></h2><h3 id="题目描述-19"><a href="#题目描述-19" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。<br>假设压入栈的所有数字均不相等。<br>例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，<br>但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p>
<h3 id="最优题解-19"><a href="#最优题解-19" class="headerlink" title="最优题解"></a>最优题解</h3><p>设置一个辅助栈，用来装压栈序列，不断压入压栈序列的数，每压入一次，<br>就看一下当前栈顶元素是否为当前弹出数，是的话弹出并遍历下一个弹出数，<br>继续检查，直到辅助栈空或者当前栈顶元素不为弹出序列第一个，<br>就继续压入压栈序列的数，直到压完所有的数，最终检查辅助栈是否为空，空则说明该序列为弹出序列<br>即：如果下一个弹出的数字刚好是栈顶数字，那么直接弹出。如果下一个弹出的数字不在栈顶，<br>就把压栈序列中还没入栈的数字压入辅助栈，直到把下一个需要弹出的数字压入栈顶为止。<br>如果所有的数字都压入栈了仍然没有找到下一个弹出的数字，那么该序列就不可能是一个弹出序列</p>
<h3 id="代码-19"><a href="#代码-19" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">IsPopOrder</span><span class="params">(self, pushV, popV)</span>:</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pushV <span class="keyword">or</span> <span class="keyword">not</span> popV <span class="keyword">or</span> len(pushV) != len(popV):</div><div class="line">            <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">        stack = []</div><div class="line">        i = <span class="number">0</span></div><div class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> pushV:</div><div class="line">            stack.append(num)</div><div class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> stack[<span class="number">-1</span>] == popV[i]:</div><div class="line">                i += <span class="number">1</span></div><div class="line">                stack.pop()</div><div class="line">        <span class="keyword">return</span> i == len(popV)</div></pre></td></tr></table></figure>
<h2 id="从上往下打印二叉树"><a href="#从上往下打印二叉树" class="headerlink" title="从上往下打印二叉树"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/23_%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91.py" target="_blank" rel="external">从上往下打印二叉树</a></h2><h3 id="题目描述-20"><a href="#题目描述-20" class="headerlink" title="题目描述"></a>题目描述</h3><p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p>
<h3 id="最优题解-20"><a href="#最优题解-20" class="headerlink" title="最优题解"></a>最优题解</h3><p>相当于宽度优先搜索（BFS），用队列来实现：<br>每次从头部取出一个结点时，如果该结点有子结点，<br>就把该结点的子结点从左到右依次放入队列末尾，<br>重复前面的步骤，直到队列为空</p>
<h3 id="代码-20"><a href="#代码-20" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></div><div class="line">        self.val = x</div><div class="line">        self.left = <span class="keyword">None</span></div><div class="line">        self.right = <span class="keyword">None</span></div><div class="line">		</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="comment"># 返回从上到下每个节点值列表，例：[1,2,3]</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">PrintFromTopToBottom</span><span class="params">(self, root)</span>:</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</div><div class="line">        res = []</div><div class="line">        queue = [root]</div><div class="line">        <span class="keyword">while</span> queue:</div><div class="line">            cur = queue.pop(<span class="number">0</span>)</div><div class="line">            res.append(cur.val)</div><div class="line">            <span class="keyword">if</span> cur.left:</div><div class="line">                queue.append(cur.left)</div><div class="line">            <span class="keyword">if</span> cur.right:</div><div class="line">                queue.append(cur.right)</div><div class="line">        <span class="keyword">return</span> res</div></pre></td></tr></table></figure>
<h2 id="二叉搜索树的后序遍历序列"><a href="#二叉搜索树的后序遍历序列" class="headerlink" title="二叉搜索树的后序遍历序列"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/24_2_%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97.py" target="_blank" rel="external">二叉搜索树的后序遍历序列</a></h2><h3 id="题目描述-21"><a href="#题目描述-21" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个整数数组，判断该数组是不是某二叉搜索树的前序遍历的结果。<br>假设输入的数组的任意两个数字都互不相同。</p>
<h3 id="最优题解-21"><a href="#最优题解-21" class="headerlink" title="最优题解"></a>最优题解</h3><p>二叉搜索树对于每一个非叶子节点, 均有结点左子节点&lt;当前节点&lt;结点右子节点<br>前序序列的第一个值为二叉搜索树根节点的值，后面含有左子树和右子树结点<br>根据二叉搜索树的特性，根节点后面的序列分为两个区域，左边为左子树区，<br>值都比根节点小，右边为右子树区，值都比根节点大，<br>不满足该特性的序列就不是某二叉搜索树的前序遍历的结果，<br>注意左子树区域和右子树区域分别又是一棵二叉搜索树，因此递归检查这两个区域</p>
<h3 id="代码-21"><a href="#代码-21" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">VerifySquenceOfBST</span><span class="params">(self, sequence)</span>:</span></div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">verify</span><span class="params">(seq)</span>:</span></div><div class="line">            <span class="keyword">if</span> <span class="keyword">not</span> seq: <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">            root = seq[<span class="number">-1</span>]</div><div class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(seq)):</div><div class="line">                <span class="keyword">if</span> seq[i] &gt; root: <span class="keyword">break</span></div><div class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i, len(seq)):</div><div class="line">                <span class="keyword">if</span> seq[j] &lt; root: <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">            <span class="keyword">return</span> verify(seq[:i]) <span class="keyword">and</span> verify(seq[i:<span class="number">-1</span>])</div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> sequence: <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">        <span class="keyword">return</span> verify(sequence)</div></pre></td></tr></table></figure>
<h3 id="举一反三-5"><a href="#举一反三-5" class="headerlink" title="举一反三"></a>举一反三</h3><p><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/24_1_%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97.py" target="_blank" rel="external">二叉搜索树的前序遍历序列</a></p>
<h2 id="二叉树中和为某一值的路径"><a href="#二叉树中和为某一值的路径" class="headerlink" title="二叉树中和为某一值的路径"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/25_%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84.py" target="_blank" rel="external">二叉树中和为某一值的路径</a></h2><h3 id="题目描述-22"><a href="#题目描述-22" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一颗二叉树和一个整数，输出二叉树中结点值的和为输入整数的所有路径。<br>路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。</p>
<h3 id="最优题解-22"><a href="#最优题解-22" class="headerlink" title="最优题解"></a>最优题解</h3><p>前序遍历，每来到一个结点就检查当前和是否为期望和，所以需要把当前和作为参数传递。</p>
<h3 id="代码-22"><a href="#代码-22" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></div><div class="line">        self.val = x</div><div class="line">        self.left = <span class="keyword">None</span></div><div class="line">        self.right = <span class="keyword">None</span></div><div class="line">		</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="comment"># 返回二维列表，内部每个列表表示找到的路径</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindPath</span><span class="params">(self, root, expectNumber)</span>:</span></div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(root, cursum)</span>:</span></div><div class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> </div><div class="line">            path.append(root.val)</div><div class="line">            cursum += root.val</div><div class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right <span class="keyword">and</span> cursum == expectNumber:</div><div class="line">                res.append(path[:]) </div><div class="line">            find(root.left, cursum)</div><div class="line">            find(root.right, cursum)</div><div class="line">            path.pop() <span class="comment"># 结点返回时记得把当前结点从路径中删除</span></div><div class="line">            </div><div class="line">        res, path = [], []</div><div class="line">        find(root, <span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span> res</div></pre></td></tr></table></figure>
<h2 id="复杂链表的复制"><a href="#复杂链表的复制" class="headerlink" title="复杂链表的复制"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/26_%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6.py" target="_blank" rel="external">复杂链表的复制</a></h2><h3 id="题目描述-23"><a href="#题目描述-23" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个复杂链表（每个节点中有节点值，以及两个指针，<br>next指向下一个节点，random指向任意一个节点），<br>返回结果为复制后复杂链表的head。</p>
<h3 id="最优题解-23"><a href="#最优题解-23" class="headerlink" title="最优题解"></a>最优题解</h3><p>时间复杂度O(n)，空间复杂度O(1)</p>
<p>第一步，复制原链表的结点N并创建新结点N’，再把N’链接到N的后面；</p>
<p>第二步，设置每个N’的random。如果原链表上的结点N的random指向S，则它对应的复制结点N’的random指向S的下一个结点S’</p>
<p>第三步，把这个长链表拆分成两个链表，奇数位置上的结点组成原链表，偶数位置上的结点组成复制链表</p>
<h3 id="代码-23"><a href="#代码-23" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></div><div class="line">        self.label = x</div><div class="line">        self.next = <span class="keyword">None</span></div><div class="line">        self.random = <span class="keyword">None</span></div><div class="line">		</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Clone</span><span class="params">(self, pHead)</span>:</span></div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">clone</span><span class="params">(pHead)</span>:</span></div><div class="line">            cur = pHead</div><div class="line">            <span class="keyword">while</span> cur:</div><div class="line">                clonenode = RandomListNode(cur.label)</div><div class="line">                clonenode.next = cur.next</div><div class="line">                cur.next = clonenode</div><div class="line">                cur = clonenode.next</div><div class="line">        </div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">connect</span><span class="params">(pHead)</span>:</span></div><div class="line">            cur = pHead</div><div class="line">            clone = pHead.next</div><div class="line">            <span class="keyword">while</span> cur:</div><div class="line">                clone.random = cur.random.next <span class="keyword">if</span> cur.random <span class="keyword">else</span> <span class="keyword">None</span></div><div class="line">                cur = clone.next</div><div class="line">                clone = cur.next <span class="keyword">if</span> cur <span class="keyword">else</span> <span class="keyword">None</span></div><div class="line">        </div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">reconnect</span><span class="params">(pHead)</span>:</span></div><div class="line">            cur = pHead</div><div class="line">            cloneHead = clone = pHead.next</div><div class="line">            <span class="keyword">while</span> cur:</div><div class="line">                cur.next = clone.next</div><div class="line">                cur = cur.next</div><div class="line">                clone.next = cur.next <span class="keyword">if</span> cur <span class="keyword">else</span> <span class="keyword">None</span></div><div class="line">                clone = clone.next</div><div class="line">            <span class="keyword">return</span> cloneHead</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pHead: <span class="keyword">return</span> </div><div class="line">        clone(pHead)</div><div class="line">        connect(pHead)</div><div class="line">        <span class="keyword">return</span> reconnect(pHead)</div></pre></td></tr></table></figure>
<h2 id="二叉搜索树与双向链表"><a href="#二叉搜索树与双向链表" class="headerlink" title="二叉搜索树与双向链表"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/27_%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.py" target="_blank" rel="external">二叉搜索树与双向链表</a></h2><h3 id="题目描述-24"><a href="#题目描述-24" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。<br>要求不能创建任何新的结点，只能调整树中结点指针的指向。</p>
<h3 id="最优题解-24"><a href="#最优题解-24" class="headerlink" title="最优题解"></a>最优题解</h3><p>二叉搜索树与双向链表的每个结点均含有两个指针，数据结构类似，可以实现相互转换</p>
<p><img src="http://ox186n2j0.bkt.clouddn.com/1532009666811.jpg" alt="转换示意图"></p>
<p>中序遍历，同时设置一个指针指向当前双向链表的最后一个结点，<br>每个被遍历到的结点都与当前双向链表的最后一个结点互相连接，<br>同时更新该指针为当前被遍历到的结点</p>
<h3 id="代码-24"><a href="#代码-24" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></div><div class="line">        self.val = x</div><div class="line">        self.left = <span class="keyword">None</span></div><div class="line">        self.right = <span class="keyword">None</span></div><div class="line">		</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.last = <span class="keyword">None</span></div><div class="line">		</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Convert</span><span class="params">(self, pRootOfTree)</span>:</span></div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">convert</span><span class="params">(root)</span>:</span></div><div class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> </div><div class="line">            convert(root.left)</div><div class="line">            self.last.right = root</div><div class="line">            root.left = self.last</div><div class="line">            self.last = root</div><div class="line">            convert(root.right)</div><div class="line">			</div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRootOfTree: <span class="keyword">return</span></div><div class="line">        dummy = self.last = TreeNode(<span class="number">0</span>)</div><div class="line">        convert(pRootOfTree)</div><div class="line">        head = dummy.right</div><div class="line">        head.left = <span class="keyword">None</span></div><div class="line">        <span class="keyword">return</span> head</div></pre></td></tr></table></figure>
<h2 id="字符串的排列"><a href="#字符串的排列" class="headerlink" title="字符串的排列"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/28_1_%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97.py" target="_blank" rel="external">字符串的排列</a></h2><h3 id="题目描述-25"><a href="#题目描述-25" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个字符串,按字典序打印出该字符串中字符的所有排列。<br>例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。<br>输入描述:<br>输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。</p>
<h3 id="最优题解-25"><a href="#最优题解-25" class="headerlink" title="最优题解"></a>最优题解</h3><p>递归，从头到尾逐个字符抽出来，剩下字符的进行排列<br>最后再把抽出来的那个字符与排列好的字符串拼在一起返回即可<br>只剩下一个字符时直接返回该字符</p>
<h3 id="代码-25"><a href="#代码-25" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Permutation</span><span class="params">(self, ss)</span>:</span></div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">permutation</span><span class="params">(ss)</span>:</span></div><div class="line">            <span class="keyword">if</span> len(ss) == <span class="number">1</span>: <span class="keyword">return</span> [ss]</div><div class="line">            res = []</div><div class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(ss)):</div><div class="line">                <span class="keyword">for</span> s <span class="keyword">in</span> permutation(ss[:i] + ss[i + <span class="number">1</span>:]):</div><div class="line">                    res.append(ss[i] + s)</div><div class="line">            <span class="keyword">return</span> res</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> ss: <span class="keyword">return</span> []</div><div class="line">        <span class="keyword">return</span> sorted(list(set(permutation(ss))))</div></pre></td></tr></table></figure>
<h3 id="举一反三-6"><a href="#举一反三-6" class="headerlink" title="举一反三"></a>举一反三</h3><ul>
<li><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/28_2_%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E7%BB%84%E5%90%88.py" target="_blank" rel="external">字符串的组合</a></li>
<li><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/28_3_%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98.py" target="_blank" rel="external">八皇后问题</a></li>
</ul>
<h2 id="数组中出现次数超过一半的数字"><a href="#数组中出现次数超过一半的数字" class="headerlink" title="数组中出现次数超过一半的数字"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/29_%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97.py" target="_blank" rel="external">数组中出现次数超过一半的数字</a></h2><h3 id="题目描述-26"><a href="#题目描述-26" class="headerlink" title="题目描述"></a>题目描述</h3><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。<br>例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。<br>由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</p>
<h3 id="最优题解-26"><a href="#最优题解-26" class="headerlink" title="最优题解"></a>最优题解</h3><p>时间O（n），空间O（1）</p>
<p>采用阵地攻守的思想：<br>先让第一个数作为守阵地的士兵，HP=1；<br>遇到相同元素，相当于支援兵，补血，HP+1;<br>遇到不相同元素，相当于敌人，掉血，HP-1；<br>当HP削减为0时，以下一个数作为守阵地的士兵；<br>继续下去，到最后还留在阵地上的士兵，有可能是最强士兵（士兵个数超过一半）。<br>为防止该士兵坐收渔翁之利，需再加一次循环，检查该士兵个数是否真的超过一半。</p>
<h3 id="代码-26"><a href="#代码-26" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">MoreThanHalfNum</span><span class="params">(self, numbers)</span>:</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> numbers: <span class="keyword">return</span> <span class="number">0</span></div><div class="line">        master = numbers[<span class="number">0</span>]</div><div class="line">        hp = <span class="number">1</span></div><div class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> numbers[<span class="number">1</span>:]:</div><div class="line">            <span class="keyword">if</span> hp == <span class="number">0</span>:</div><div class="line">                master = num</div><div class="line">                hp = <span class="number">1</span></div><div class="line">            <span class="keyword">elif</span> num == master: </div><div class="line">                hp += <span class="number">1</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                hp -= <span class="number">1</span></div><div class="line">        isHalf = sum(<span class="number">1</span> <span class="keyword">for</span> num <span class="keyword">in</span> numbers <span class="keyword">if</span> num == master) &gt; len(numbers) &gt;&gt; <span class="number">1</span></div><div class="line">        <span class="keyword">return</span> master <span class="keyword">if</span> isHalf <span class="keyword">else</span> <span class="number">0</span></div></pre></td></tr></table></figure>
<h2 id="最小的K个数"><a href="#最小的K个数" class="headerlink" title="最小的K个数"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/30_%E6%9C%80%E5%B0%8F%E7%9A%84K%E4%B8%AA%E6%95%B0.py" target="_blank" rel="external">最小的K个数</a></h2><h3 id="题目描述-27"><a href="#题目描述-27" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4</p>
<h3 id="最优题解-27"><a href="#最优题解-27" class="headerlink" title="最优题解"></a>最优题解</h3><p>时间O(nlogk)，空间O(1)</p>
<p>基于Partition的算法, 只有当我们可以修改输入的数组时可用。<br>利用Partition找到第(k-1)小的数(从0开始)，则数组左边的k个数字就是最小的k个数字（这k个数字不一定是排序的）</p>
<h3 id="代码-27"><a href="#代码-27" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetLeastNumbers</span><span class="params">(self, tinput, k)</span>:</span></div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(tinput, l, r)</span>:</span></div><div class="line">            last = l - <span class="number">1</span>  <span class="comment"># 分界线</span></div><div class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(l, r):</div><div class="line">                <span class="keyword">if</span> tinput[i] &lt; tinput[r]:</div><div class="line">                    last += <span class="number">1</span></div><div class="line">                    tinput[last], tinput[i] = tinput[i], tinput[last]</div><div class="line">            last += <span class="number">1</span></div><div class="line">            tinput[last], tinput[r] = tinput[r], tinput[last]</div><div class="line">            <span class="keyword">return</span> last</div><div class="line">			</div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> tinput <span class="keyword">or</span> len(tinput) &lt; k <span class="keyword">or</span> k == <span class="number">0</span>: <span class="keyword">return</span> []</div><div class="line">        l, r = <span class="number">0</span>, len(tinput) - <span class="number">1</span></div><div class="line">        <span class="keyword">while</span> l &lt;= r:</div><div class="line">            index = partition(tinput, l, r)</div><div class="line">            <span class="keyword">if</span> index &lt; k - <span class="number">1</span>:</div><div class="line">                l = index + <span class="number">1</span></div><div class="line">            <span class="keyword">elif</span> index &gt; k - <span class="number">1</span>:</div><div class="line">                r = index - <span class="number">1</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                <span class="keyword">return</span> sorted(tinput[:k])</div></pre></td></tr></table></figure>
<h2 id="连续子数组的最大和"><a href="#连续子数组的最大和" class="headerlink" title="连续子数组的最大和"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/31_%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C.py" target="_blank" rel="external">连续子数组的最大和</a></h2><h3 id="题目描述-28"><a href="#题目描述-28" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个整型数组，数组中一个或连续的多个整数组成一个子数组。<br>求所有子数组的和的最大值，要求时间复杂度为O(n)</p>
<h3 id="最优题解-28"><a href="#最优题解-28" class="headerlink" title="最优题解"></a>最优题解</h3><p>动态规划。<br>设 f(i) 为以第 i 个数结尾的连续子数组的最大和，则状态转移方程为：<br><code>f(i) = max(f(i-1)+array[i], array[i])</code><br>最后结果为max(f(i))<br>优化：f(i)只与f(i-1)有关，即只与前一状态有关，所以空间上可以由O(n)降为O(1)</p>
<p>该状态转移方程的意义是：<br>如果以第 i-1 个数字结尾的子数组中所有数字的和加上当前第 i 个数字比当前第 i 个数字本身还要小，<br>那么就舍弃前面的累加而直接选择第 i 个数字本身作为最大值<br>最后求所有以第 i 个数结尾的连续子数组最大和的最大值</p>
<h3 id="代码-28"><a href="#代码-28" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(self, array)</span>:</span></div><div class="line">        curSum = maxSum = array[<span class="number">0</span>]</div><div class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> array[<span class="number">1</span>:]:</div><div class="line">            curSum = max(num, curSum + num)</div><div class="line">            maxSum = max(maxSum, curSum)</div><div class="line">        <span class="keyword">return</span> maxSum</div></pre></td></tr></table></figure>
<h2 id="从1到n中1出现的次数"><a href="#从1到n中1出现的次数" class="headerlink" title="从1到n中1出现的次数"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/32_%E4%BB%8E1%E5%88%B0n%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0.py" target="_blank" rel="external">从1到n中1出现的次数</a></h2><h3 id="题目描述-29"><a href="#题目描述-29" class="headerlink" title="题目描述"></a>题目描述</h3><p>原题：输入一个整数n，求从1到n这n个整数的十进制表示中1出现的次数<br>扩展：改成X出现的次数，X∈[1,9]</p>
<h3 id="最优题解-29"><a href="#最优题解-29" class="headerlink" title="最优题解"></a>最优题解</h3><p>链接：<a href="https://www.nowcoder.net/questionTerminal/bd7f978302044eee894445e244c7eee6" target="_blank" rel="external">https://www.nowcoder.net/questionTerminal/bd7f978302044eee894445e244c7eee6</a><br>来源：牛客网<br>参考博文：<a href="http://www.cnblogs.com/nailperry/p/4752987.html" target="_blank" rel="external">http://www.cnblogs.com/nailperry/p/4752987.html</a> ，主要就是从数字出发找规律。</p>
<p>一、1的数目</p>
<p>编程之美上给出的规律：</p>
<ol>
<li>如果第i位（自右至左，从1开始标号）上的数字为0，则第i位可能出现1的次数由更高位决定<br>（若没有高位，视高位为0），等于更高位数字*当前位数的权重10^(i-1)。</li>
<li>如果第i位上的数字为1，则第i位上可能出现1的次数不仅受更高位影响，还受低位影响<br>（若没有低位，视低位为0），等于更高位数字*当前位数的权重10^(i-1)+（低位数字+1）。</li>
<li>如果第i位上的数字大于1，则第i位上可能出现1的次数仅由更高位决定（若没有高位，视高位为0），<br>等于（更高位数字+1）*当前位数的权重10^(i-1)。</li>
</ol>
<p>二、X的数目</p>
<p>这里的X∈[1,9]，因为X=0不符合下列规律，需要单独计算。<br>首先要知道以下的规律：<br>从 1 至 10，在它们的个位数中，任意的 X 都出现了 1 次。<br>从 1 至 100，在它们的十位数中，任意的 X 都出现了 10 次。<br>从 1 至 1000，在它们的百位数中，任意的 X 都出现了 100 次。<br>依此类推，从1至10^i，在它们的左数第二位（右数第i位）中，任意的X都出现了10^(i-1)次。<br>这个规律很容易验证，这里不再多做说明。</p>
<p>接下来以 n=2593, X=5 为例来解释如何得到数学公式。从 1 至 2593 中，数字 5 总计出现了 813 次，<br>其中有 259 次出现在个位，260 次出现在十位，294 次出现在百位，0 次出现在千位。<br>现在依次分析这些数据，首先是个位。从 1 至 2590 中，包含了 259 个 10，因此任意的 X 都出现了 259 次。<br>最后剩余的三个数 2591, 2592 和 2593，因为它们最大的个位数字 3 &lt; X，因此不会包含任何 5。<br>（也可以这么看，3 &lt; X，则个位上可能出现的X的次数仅由更高位决定，等于更高位数字（259） * 10 ^ (1 - 1) = 259）。<br>然后是十位。从 1 至 2500 中，包含了 25 个 100，因此任意的 X 都出现了  25 * 10 = 250  次。<br>剩下的数字是从 2501 至 2593，它们最大的十位数字 9 &gt; X，因此会包含全部 10 个 5。<br>最后总计 250 + 10 = 260。（也可以这么看，9 &gt; X，则十位上可能出现的X的次数仅由更高位决定，<br>等于更高位数字(25 + 1) * 10 ^ (2 -  1) = 260）。<br>接下来是百位。从 1 至 2000 中，包含了 2 个 1000，因此任意的 X 都出现了  2 * 100 = 200  次。<br>剩下的数字是从 2001 至 2593，它们最大的百位数字 5 == X，这时情况就略微复杂，<br>它们的百位肯定是包含 5 的，但不会包含全部 100 个。如果把百位是 5 的数字列出来，<br>是从 2500 至 2593，数字的个数与百位和十位数字相关，是 93 + 1 = 94。最后总计 200 + 94 = 294。<br>（也可以这么看，5==X，则百位上可能出现X的次数不仅受更高位影响，还受低位影响，<br>等于更高位数字（2） * 10 ^ (3 - 1) + (93 + 1) = 294）。<br>最后是千位。现在已经没有更高位，因此直接看最大的千位数字 2 &lt; X，所以不会包含任何 5。<br>（也可以这么看，2 &lt; X，则千位上可能出现的X的次数仅由更高位决定，等于更高位数字(0) * 10 ^ (4 - 1) = 0）。<br>到此为止，已经计算出全部数字 5 的出现次数。<br>总结一下以上的算法，可以看到，当计算右数第 i 位包含的 X 的个数时：<br>取第i位左边（所有高位）的数字，乘以  10 ^ (i - 1) ，得到基础值  a 。<br>取第i位数字，计算修正值：<br>如果小于 X，则结果为  a 。<br>如果大于 X，则结果为  a + 10 ^ (i - 1) 。<br>如果等于 X，则取第 i 位右边（所有低位）数字，设为  b ，最后结果为  a + b + 1 。<br>相应的代码非常简单，效率也非常高，时间复杂度只有  O( lg n) 。</p>
<h3 id="代码-29"><a href="#代码-29" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">NumberOf1Between1AndN</span><span class="params">(self, n)</span>:</span></div><div class="line">        count, weight = <span class="number">0</span>, <span class="number">1</span></div><div class="line">        <span class="keyword">while</span> weight &lt;= n:</div><div class="line">            low = n % weight</div><div class="line">            high = n // weight</div><div class="line">            cur = high % <span class="number">10</span></div><div class="line">            base = (high // <span class="number">10</span>) * weight</div><div class="line">            <span class="keyword">if</span> cur &lt; <span class="number">1</span>:</div><div class="line">                count += base</div><div class="line">            <span class="keyword">elif</span> cur &gt; <span class="number">1</span>:</div><div class="line">                count += base + weight</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                count += base + low + <span class="number">1</span></div><div class="line">            weight *= <span class="number">10</span></div><div class="line">        <span class="keyword">return</span> count</div></pre></td></tr></table></figure>
<h2 id="把数组排成最小的数"><a href="#把数组排成最小的数" class="headerlink" title="把数组排成最小的数"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/33_%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0.py" target="_blank" rel="external">把数组排成最小的数</a></h2><h3 id="题目描述-30"><a href="#题目描述-30" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。<br>例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p>
<h3 id="最优题解-30"><a href="#最优题解-30" class="headerlink" title="最优题解"></a>最优题解</h3><p>最直接的做法就是把数组中所有数字进行全排列，然后把每个排列拼接起来，最后求出拼起来的数字的最小值，<br>易知算法复杂度高达O(n!)，所以不推荐。这里定义一个新的比较规则：<br>对于两个数字m,n，可以拼接成mn和nm。若mn &lt; nm，则定义m &lt; n；若mn &gt; nm，则定义m &gt; n；若mn = nm，则定义m = n<br>将数组中的数按照上述比较规则从小到大进行排序，最后将排序的数组进行拼接即为数组所能拼成的最小数<br>证明见书第一版P179~180</p>
<h3 id="代码-30"><a href="#代码-30" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">PrintMinNumber</span><span class="params">(self, numbers)</span>:</span></div><div class="line">        <span class="keyword">from</span> functools <span class="keyword">import</span> cmp_to_key</div><div class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(sorted([str(num) <span class="keyword">for</span> num <span class="keyword">in</span> numbers], key = cmp_to_key(<span class="keyword">lambda</span> x, y: int(x + y) - int(y + x))))</div></pre></td></tr></table></figure>
<h2 id="丑数"><a href="#丑数" class="headerlink" title="丑数"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/34_%E4%B8%91%E6%95%B0.py" target="_blank" rel="external">丑数</a></h2><h3 id="题目描述-31"><a href="#题目描述-31" class="headerlink" title="题目描述"></a>题目描述</h3><p>把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。<br>习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</p>
<h3 id="最优题解-31"><a href="#最优题解-31" class="headerlink" title="最优题解"></a>最优题解</h3><p>创建数组保存已经找到的丑数并排好序，关键在于如何生成下一个丑数<br>数组中最后一个丑数最大，记为M。设置index2，标记该位置的数乘以2大于M，<br>同理设置index3、index5，这样每次只需求<code>min(A[index2] * 2,A[index3] * 3,A[index5] * 5)</code><br>就可求出下一个丑数，然后更新三个标记。<br>这样关键就在于如何更新这三个标记，<br>仔细推敲可以发现其实只需让那些指向的数乘相应因子等于当前M的标记往后移一位即可，<br>因为 <code>M = min(A[index2] * 2,A[index3] * 3,A[index5] * 5)</code>，则至少有个标记是要往后移的，<br>且移一位即可，后面那个数乘以相应的因子一定大于M。<br>那么其他指向的数乘相应因子不等于当前M的标记为什么没有必要移动呢？<br>还是因为 <code>M = min(A[index2] * 2,A[index3] * 3,A[index5] * 5)</code>， 既然M是其中最小的，<br>那么其他的标记所指向的数乘以相应因子一定就比M大了，没有必要更新<br>这样就可以把三个并列的while简化成三个并列的if</p>
<p>这里谈谈为什么要使用这三个index，且为什么这样做可以保证按顺序产生下一个丑数。<br>按照正常的理解，后面的丑数都是由前面已经产生的某个丑数乘2或乘3或乘5得到，<br>为了按照顺序，必须把前面每个丑数乘2或乘3或乘5得到的值中取大于当前最后一个丑数的最小值。<br>那么问题来了，有必要把每个丑数都乘这三个因子然后取最小值？<br>我们发现每个丑数都要经历乘2乘3乘5的过程，但却没有必要在同一次竞争下一个丑数中乘，<br>所以我们反过来，标记上那些需要乘2或乘3或乘5的数，使得index2指向的数就要乘2，<br>因为它在下一次竞争中可能会胜利，index3和index5同理。为了满足以上规则，<br>我们让这三个标记从左向右各自独立遍历，这样也就让每个数都会经历乘2或乘3或乘5的过程，<br>且如果标记的数乘以相应因子后竞争胜利了，那么该标记就要往后挪1位，<br>因为新的丑数是该标记因子乘以它指向的数竞争胜利而生成的，<br>所以该数乘以该因子已经没有参与下一次竞争的机会了，相应的因子标记就该往后挪，<br>使得下一个数参与新的竞争。而其他竞争失败的标记不用动，因为它们还有竞争胜利的机会，<br>毕竟每次胜利的是那个乘积最小的。</p>
<h3 id="代码-31"><a href="#代码-31" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetUglyNumber</span><span class="params">(self, index)</span>:</span></div><div class="line">        <span class="comment"># write code here</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> index: <span class="keyword">return</span> <span class="number">0</span></div><div class="line">        idx2 = idx3 = idx5 = <span class="number">0</span></div><div class="line">        uglynums = [<span class="number">1</span>]</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, index):</div><div class="line">            uglynums.append(min(uglynums[idx2]*<span class="number">2</span>, uglynums[idx3]*<span class="number">3</span>, uglynums[idx5]*<span class="number">5</span>))</div><div class="line">            <span class="comment"># 可能会有多个标记竞争胜利，即丑数恰好是前面标记所在值的公倍数</span></div><div class="line">            <span class="comment"># 因此必须是并列的if，不能if...elif...else</span></div><div class="line">            <span class="keyword">if</span> uglynums[<span class="number">-1</span>] == uglynums[idx2]*<span class="number">2</span>: idx2 += <span class="number">1</span></div><div class="line">            <span class="keyword">if</span> uglynums[<span class="number">-1</span>] == uglynums[idx3]*<span class="number">3</span>: idx3 += <span class="number">1</span></div><div class="line">            <span class="keyword">if</span> uglynums[<span class="number">-1</span>] == uglynums[idx5]*<span class="number">5</span>: idx5 += <span class="number">1</span></div><div class="line">        <span class="keyword">return</span> uglynums[<span class="number">-1</span>]</div></pre></td></tr></table></figure>
<h2 id="第一个只出现一次的字符"><a href="#第一个只出现一次的字符" class="headerlink" title="第一个只出现一次的字符"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/35_1_%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6.py" target="_blank" rel="external">第一个只出现一次的字符</a></h2><h3 id="题目描述-32"><a href="#题目描述-32" class="headerlink" title="题目描述"></a>题目描述</h3><p>在一个字符串(1&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置,不存在就返回-1</p>
<h3 id="最优题解-32"><a href="#最优题解-32" class="headerlink" title="最优题解"></a>最优题解</h3><p>时间复杂度O(n)，空间复杂度O(1)（不会超过256个键值对）</p>
<p>利用python的字典建立哈希表，键记录字母，值记录字母出现的次数。<br>第一次遍历建立哈希表，第二次遍历找到第一个值为1的键（字母）。</p>
<h3 id="代码-32"><a href="#代码-32" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FirstNotRepeatingChar1</span><span class="params">(self, s)</span>:</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s: <span class="keyword">return</span> <span class="number">-1</span></div><div class="line">        hashTable = &#123;&#125;</div><div class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> s:</div><div class="line">            <span class="keyword">if</span> char <span class="keyword">not</span> <span class="keyword">in</span> hashTable.keys():</div><div class="line">                hashTable[char] = <span class="number">1</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                hashTable[char] += <span class="number">1</span></div><div class="line">        <span class="keyword">for</span> i, v <span class="keyword">in</span> hashTable.items():</div><div class="line">            <span class="keyword">if</span> v == <span class="number">1</span>: <span class="keyword">return</span> s.index(i)</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span></div></pre></td></tr></table></figure>
<h3 id="举一反三-7"><a href="#举一反三-7" class="headerlink" title="举一反三"></a>举一反三</h3><ul>
<li><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/35_2_%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6.py" target="_blank" rel="external">字符串中删除字符</a></li>
<li><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/35_3_%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E7%AC%A6.py" target="_blank" rel="external">删除重复的字符</a></li>
<li><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/35_4_%E5%8F%98%E4%BD%8D%E8%AF%8D.py" target="_blank" rel="external">变位词</a></li>
</ul>
<h2 id="数组中的逆序对"><a href="#数组中的逆序对" class="headerlink" title="数组中的逆序对"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/36_%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9.py" target="_blank" rel="external">数组中的逆序对</a></h2><h3 id="题目描述-33"><a href="#题目描述-33" class="headerlink" title="题目描述"></a>题目描述</h3><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。<br>输入一个数组, 求出这个数组中逆序对的总数</p>
<h3 id="最优题解-33"><a href="#最优题解-33" class="headerlink" title="最优题解"></a>最优题解</h3><p>时间复杂度O(nlogn)，空间复杂度O(n)</p>
<p>先把原数组进行从小到大排序，得到一个排好序的数组。然后遍历排序数组，<br>找到每个数在原数组的索引，该索引就是这个数的在原数组中相对排好序的数组的偏移，<br>那么偏移多少就有多少由于该数的偏移造成的逆序对。<br>记得每找一次索引就要把该数（比如a）从原数组中移除，保证接下原数组每个数的偏移是正确的，<br>因为对于排序数组接下来的数（比如b），a对于b并不是逆序对，<br>而如果原数组中a出现在b之前就会多算一次，因此需要在原数组中移除该数。<br>注意，排好序的数组一直在往后遍历，相当于排好序的数组也一直在更新，<br>类似一个递归的过程，只不过用循环来完成。</p>
<h3 id="代码-33"><a href="#代码-33" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">InversePairs</span><span class="params">(self, data)</span>:</span></div><div class="line">			count = <span class="number">0</span></div><div class="line">			copy = sorted(data[:])</div><div class="line">			<span class="keyword">for</span> num <span class="keyword">in</span> copy:</div><div class="line">				count += data.index(num)</div><div class="line">				data.remove(num)  <span class="comment"># 记得从原数组中删除已经找过的数</span></div><div class="line">			<span class="keyword">return</span> count</div></pre></td></tr></table></figure>
<h2 id="两个链表的第一个公共结点"><a href="#两个链表的第一个公共结点" class="headerlink" title="两个链表的第一个公共结点"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/37_%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E7%BB%93%E7%82%B9.py" target="_blank" rel="external">两个链表的第一个公共结点</a></h2><h3 id="题目描述-34"><a href="#题目描述-34" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入两个单向无环链表，找出它们的第一个公共结点。</p>
<h3 id="最优题解-34"><a href="#最优题解-34" class="headerlink" title="最优题解"></a>最优题解</h3><p>时间复杂度O(m+n)，空间复杂度O(1)。</p>
<p>两个链表指针（p1,p2）都从头开始一起遍历，<br>但是p1来到末尾时指向另一个链表的头结点（不是指向原链表的头结点），p2也一样。<br>这样第一次遍历时，短的链表指针（假如为p1）来到长链表（假如为l2）的头结点，<br>此时p2还在l2上，且p2距离末尾（l2-l1）。p2来到l1头结点时，p1在l2上距离末尾（l2-(l2-l1)）<br>此时p1的位置正好就是思路3中长指针先出发来到二者长度差的位置，下面一起遍历一定能够相遇，<br>即使没有公共结点，也会在None处一起返回（相当于相遇），相当于转化成思路3<br>整个过程最坏情况下p1、p2各遍历两个链表一次，所以时间复杂度O(m+n)，空间复杂度O(1)。<br>注意这个思路和思路4只是在指针来到末尾时指回哪里有区别，其他一致，但复杂度降低了   </p>
<h3 id="代码-34"><a href="#代码-34" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></div><div class="line">        self.val = x</div><div class="line">        self.next = <span class="keyword">None</span></div><div class="line">		</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindFirstCommonNode</span><span class="params">(self, pHead1, pHead2)</span>:</span></div><div class="line">        cur1, cur2 = pHead1, pHead2</div><div class="line">        <span class="keyword">while</span> cur1 <span class="keyword">is</span> <span class="keyword">not</span> cur2:</div><div class="line">            cur1 = cur1.next <span class="keyword">if</span> cur1 <span class="keyword">else</span> pHead2</div><div class="line">            cur2 = cur2.next <span class="keyword">if</span> cur2 <span class="keyword">else</span> pHead1</div><div class="line">        <span class="keyword">return</span> cur1</div></pre></td></tr></table></figure>
<h2 id="数字在排序数组中出现的次数"><a href="#数字在排序数组中出现的次数" class="headerlink" title="数字在排序数组中出现的次数"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/38_1_%E6%95%B0%E5%AD%97%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0.py" target="_blank" rel="external">数字在排序数组中出现的次数</a></h2><h3 id="题目描述-35"><a href="#题目描述-35" class="headerlink" title="题目描述"></a>题目描述</h3><p>统计一个数字在排序数组中出现的次数</p>
<h3 id="最优题解-35"><a href="#最优题解-35" class="headerlink" title="最优题解"></a>最优题解</h3><p>既然是排好序的，那么自然想到二分法了。总体思路是找到第一个k的位置，再找到最后一个k的位置，相减加一。<br>先查找第一个k的位置：<br>如果中间的数字比k大，那么k只可能出现在数组的前半段，下一轮就只在数组的前半段查找就可以了。<br>如果中间的数字比k小，那么k只可能出现在数组的后半段，下一轮就只在数组的后半段查找就可以了。<br>关键是如果中间的数字等于k呢？我们先判断该数字是不是第一个k。<br>如果中间数字前面不是k，则该中间数字刚好就是第一个k；<br>如果中间数字前面也是k，则第一个k肯定在数组前半段，下一轮我们仍然需要在数组前半段查找。O(logn)</p>
<h3 id="代码-35"><a href="#代码-35" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetNumberOfK</span><span class="params">(self, data, k)</span>:</span></div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">firstK</span><span class="params">(data, k)</span>:</span></div><div class="line">            l , r = <span class="number">0</span> , len(data) - <span class="number">1</span></div><div class="line">            <span class="keyword">while</span> l &lt;= r:</div><div class="line">                m = l + ((r - l) &gt;&gt; <span class="number">1</span>)</div><div class="line">                <span class="keyword">if</span> data[m] &lt; k:</div><div class="line">                    l = m + <span class="number">1</span></div><div class="line">                <span class="keyword">elif</span> data[m] &gt; k:</div><div class="line">                    r = m - <span class="number">1</span></div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    <span class="keyword">if</span> m == <span class="number">0</span> <span class="keyword">or</span> data[m - <span class="number">1</span>] &lt; k:</div><div class="line">                        <span class="keyword">return</span> m</div><div class="line">                    <span class="keyword">else</span>:</div><div class="line">                        r = m - <span class="number">1</span></div><div class="line">            <span class="keyword">return</span> <span class="number">-1</span></div><div class="line">        </div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">lastK</span><span class="params">(data, k)</span>:</span></div><div class="line">            l , r = <span class="number">0</span> , len(data) - <span class="number">1</span></div><div class="line">            <span class="keyword">while</span> l &lt;= r:</div><div class="line">                m = l + ((r - l) &gt;&gt; <span class="number">1</span>)</div><div class="line">                <span class="keyword">if</span> data[m] &lt; k:</div><div class="line">                    l = m + <span class="number">1</span></div><div class="line">                <span class="keyword">elif</span> data[m] &gt; k:</div><div class="line">                    r = m - <span class="number">1</span></div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    <span class="keyword">if</span> m == len(data) - <span class="number">1</span> <span class="keyword">or</span> data[m + <span class="number">1</span>] &gt; k:</div><div class="line">                        <span class="keyword">return</span> m</div><div class="line">                    <span class="keyword">else</span>:</div><div class="line">                        l = m + <span class="number">1</span></div><div class="line">            <span class="keyword">return</span> <span class="number">-1</span></div><div class="line">			</div><div class="line">        first, last = firstK(data, k), lastK(data, k)</div><div class="line">        <span class="keyword">return</span> last - first + <span class="number">1</span> <span class="keyword">if</span> first != <span class="number">-1</span> <span class="keyword">else</span> <span class="number">0</span></div></pre></td></tr></table></figure>
<h3 id="举一反三-8"><a href="#举一反三-8" class="headerlink" title="举一反三"></a>举一反三</h3><ul>
<li><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/38_2_%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97.py" target="_blank" rel="external">缺失的数字</a></li>
<li><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/38_3_%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%80%BC%E5%92%8C%E4%B8%8B%E6%A0%87%E7%9B%B8%E7%AD%89%E7%9A%84%E5%85%83%E7%B4%A0.py" target="_blank" rel="external">数组中数值和下标相等的元素</a></li>
</ul>
<h2 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/39_1_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6.py" target="_blank" rel="external">二叉树的深度</a></h2><h3 id="题目描述-36"><a href="#题目描述-36" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一棵二叉树，求该树的深度。<br>从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p>
<h3 id="最优题解-36"><a href="#最优题解-36" class="headerlink" title="最优题解"></a>最优题解</h3><p>递归实现，树的深度=max(左子树深度，右子树深度)+1</p>
<h3 id="代码-36"><a href="#代码-36" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></div><div class="line">        self.val = x</div><div class="line">        self.left = <span class="keyword">None</span></div><div class="line">        self.right = <span class="keyword">None</span></div><div class="line">		</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">TreeDepth1</span><span class="params">(self, pRoot)</span>:</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot: <span class="keyword">return</span> <span class="number">0</span></div><div class="line">        <span class="keyword">return</span> max(self.TreeDepth1(pRoot.left), self.TreeDepth1(pRoot.right)) + <span class="number">1</span></div></pre></td></tr></table></figure>
<h2 id="判断平衡二叉树"><a href="#判断平衡二叉树" class="headerlink" title="判断平衡二叉树"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/39_2_%E5%88%A4%E6%96%AD%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.py" target="_blank" rel="external">判断平衡二叉树</a></h2><h3 id="题目描述-37"><a href="#题目描述-37" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一棵二叉树，判断该二叉树是否是平衡二叉树。<br>注：平衡二叉树任意结点的左右子树深度相差不超过1，空树算平衡二叉树</p>
<h3 id="最优题解-37"><a href="#最优题解-37" class="headerlink" title="最优题解"></a>最优题解</h3><p>根据后序遍历的特点，当遍历到某一结点时该结点的左右子树已经遍历结束。<br>因此在遍历每个结点的时候记录以它为根节点的树的深度，这样在遍历到某个结点时<br>既知道了左右子树的深度，也知道左右子树是否为平衡二叉树(递归)，即一边计算深度一边判断是否平衡。<br>书上用变量left和right来单独表示左右子树的深度，函数返回的是true或者false，<br>其实不用这两个变量，我们直接把树的深度返回即可，这样根节点可直接拿到左右子树的深度，<br>因为我们注意到深度总是大于等于0的，所以我们只需定义当子树不平衡时返回-1即可，<br>这样根节点也就可以通过左右子树返回的深度是否大于等于0来间接判断左右子树是否平衡</p>
<h3 id="代码-37"><a href="#代码-37" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></div><div class="line">        self.val = x</div><div class="line">        self.left = <span class="keyword">None</span></div><div class="line">        self.right = <span class="keyword">None</span></div><div class="line">		</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">IsBalanced_Solution</span><span class="params">(self, pRoot)</span>:</span></div><div class="line">        <span class="comment"># write code here</span></div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">IsBalanced</span><span class="params">(root)</span>:</span></div><div class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="number">0</span></div><div class="line">            left, right = IsBalanced(root.left), IsBalanced(root.right)</div><div class="line">            <span class="keyword">if</span> left == <span class="number">-1</span> <span class="keyword">or</span> right == <span class="number">-1</span> <span class="keyword">or</span> abs(left - right) &gt; <span class="number">1</span>: <span class="keyword">return</span> <span class="number">-1</span></div><div class="line">            <span class="keyword">return</span> <span class="number">1</span> + max(left, right)</div><div class="line">        <span class="keyword">return</span> IsBalanced(pRoot) &gt;= <span class="number">0</span></div></pre></td></tr></table></figure>
<h2 id="数组中只出现一次的两个数字"><a href="#数组中只出现一次的两个数字" class="headerlink" title="数组中只出现一次的两个数字"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/40_1_%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97%EF%BC%88%E5%85%B6%E4%BB%96%E5%87%BA%E7%8E%B02%E6%AC%A1%EF%BC%89.py" target="_blank" rel="external">数组中只出现一次的两个数字</a></h2><h3 id="题目描述-38"><a href="#题目描述-38" class="headerlink" title="题目描述"></a>题目描述</h3><p>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</p>
<h3 id="最优题解-38"><a href="#最优题解-38" class="headerlink" title="最优题解"></a>最优题解</h3><p>时间复杂度O(n)，空间复杂度O(1)</p>
<p>既然其他的数字都出现了两次，那么可以把数组中所有数异或，则两次的相互抵消，一次的相互异或，<br>即最终的异或结果相当于两个出现一次的数相异或。如果只有一个数字是出现一次的，<br>那么异或结果就是那个数了，但这里有两个，于是我们想着把它俩给分开，使得各自在一个数组里，<br>且每个数组除了那个出现一次的数以外其他数都是出现两次，这样两个数组分别异或就可以找出这两个数了。<br>关键是如何把它俩分开且数组里其他数都是成双成对？我们仍然把整个数组相异或，<br>得到的结果一定不为0（因为这两个数一定不一样），那么二进制中一定有一个位置为1。<br>那么我们可以以最右边的1为标准，把整个数组中该位为1的数划分为一组，为0的划分为一组。这样做一举两得：<br>一来把那两个出现一次的数分开了，<br>二来把成对的数放在了同一个数组里了（因为相同的数其二进制位一致）。</p>
<h3 id="代码-38"><a href="#代码-38" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="comment"># 返回[a,b] 其中ab是出现一次的两个数字</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindNumsAppearOnce</span><span class="params">(self, array)</span>:</span></div><div class="line">        sum = <span class="number">0</span></div><div class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> array:</div><div class="line">            sum ^= num</div><div class="line">        last1 = sum &amp; -sum</div><div class="line">        left = right = <span class="number">0</span></div><div class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> array:</div><div class="line">            <span class="keyword">if</span> num &amp; last1:</div><div class="line">                left ^= num</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                right ^= num </div><div class="line">        <span class="keyword">return</span> [left, right]</div></pre></td></tr></table></figure>
<h3 id="举一反三-9"><a href="#举一反三-9" class="headerlink" title="举一反三"></a>举一反三</h3><p><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/40_2_%E6%95%B0%E7%BB%84%E4%B8%AD%E5%94%AF%E4%B8%80%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97%EF%BC%88%E5%85%B6%E4%BB%96%E5%87%BA%E7%8E%B03%E6%AC%A1%EF%BC%89.py" target="_blank" rel="external">数组中唯一只出现一次的数字（其他出现3次）</a></p>
<h2 id="和为s的两个数字"><a href="#和为s的两个数字" class="headerlink" title="和为s的两个数字"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/41_1_%E5%92%8C%E4%B8%BAs%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97.py" target="_blank" rel="external">和为s的两个数字</a></h2><h3 id="题目描述-39"><a href="#题目描述-39" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，<br>如果有多对数字的和等于S，输出乘积最小的两个数。<br>对应每个测试案例，输出两个数，小的先输出。</p>
<h3 id="最优题解-39"><a href="#最优题解-39" class="headerlink" title="最优题解"></a>最优题解</h3><p>双指针，左右夹逼。<br>设置两个指针分别指向第一个和最后一个数，如果它们的和等于s，我们就找到了这两个数；<br>如果小于s，由于数组已经排好序，所以只需让较小数的指针往后移；如果大于s，<br>则让较大数的指针往前移。最终找到的第一对就是乘积最大的</p>
<h3 id="代码-39"><a href="#代码-39" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindNumbersWithSum3</span><span class="params">(self, array, sum)</span>:</span></div><div class="line">        <span class="keyword">if</span> array:</div><div class="line">            start = <span class="number">0</span></div><div class="line">            end = len(array) - <span class="number">1</span></div><div class="line">            <span class="keyword">while</span> start &lt; end:  <span class="comment"># 当 start==end 时，指向同一个数，则不再是不同位置的两个数，结束循环</span></div><div class="line">                <span class="keyword">if</span> array[start] + array[end] &lt; sum:</div><div class="line">                    start += <span class="number">1</span></div><div class="line">                <span class="keyword">elif</span> array[start] + array[end] &gt; sum:</div><div class="line">                    end -= <span class="number">1</span></div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    <span class="keyword">return</span> [array[start], array[end]]</div><div class="line">        <span class="keyword">return</span> []</div></pre></td></tr></table></figure>
<h2 id="和为s的连续正整数序列"><a href="#和为s的连续正整数序列" class="headerlink" title="和为s的连续正整数序列"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/41_2_%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B4%E6%95%B0%E5%BA%8F%E5%88%97.py" target="_blank" rel="external">和为s的连续正整数序列</a></h2><h3 id="题目描述-40"><a href="#题目描述-40" class="headerlink" title="题目描述"></a>题目描述</h3><p>找出所有和为S的连续正整数序列(至少含有两个数)。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序</p>
<h3 id="最优题解-40"><a href="#最优题解-40" class="headerlink" title="最优题解"></a>最优题解</h3><p>双指针问题</p>
<p>用两个数small和big分别表示序列的最小值和最大值。首先把small初始化为1，big初始化为2。<br>如果从small到big的序列的和大于s，可以从序列中去掉较小值，也就是增大small的值。<br>如果从small到big的序列的和小于s，可以增大big，让序列包含更多的数字。<br>因为序列至少要有两个连续的数字，所以small的上限是(s-1)/2，big的上限是(s-1)/2+1</p>
<h3 id="代码-40"><a href="#代码-40" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindContinuousSequence</span><span class="params">(self, sum)</span>:</span></div><div class="line">        <span class="keyword">if</span> sum &lt; <span class="number">3</span>:</div><div class="line">            <span class="keyword">return</span> []</div><div class="line">        small = <span class="number">1</span></div><div class="line">        big = <span class="number">2</span></div><div class="line">        curSum = <span class="number">3</span></div><div class="line">        small_top = (sum - <span class="number">1</span>) &gt;&gt; <span class="number">1</span></div><div class="line">        big_top = small_top + <span class="number">1</span></div><div class="line">        result = []</div><div class="line">        <span class="keyword">while</span> big &lt;= big_top:</div><div class="line">            <span class="keyword">while</span> curSum &gt; sum <span class="keyword">and</span> small &lt;= small_top:</div><div class="line">                curSum -= small</div><div class="line">                small += <span class="number">1</span>  <span class="comment"># 先减再右移</span></div><div class="line">            <span class="keyword">if</span> curSum == sum:</div><div class="line">                result.append(list(range(small, big + <span class="number">1</span>)))</div><div class="line">            big += <span class="number">1</span>  <span class="comment"># 如果curSum &lt; sum，那么big后移；如果找到了一个序列，那么big也后移继续寻找下一个序列</span></div><div class="line">            curSum += big  <span class="comment"># 先右移再加</span></div><div class="line">        <span class="keyword">return</span> result</div></pre></td></tr></table></figure>
<h2 id="翻转单词顺序"><a href="#翻转单词顺序" class="headerlink" title="翻转单词顺序"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/42_1_%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F.py" target="_blank" rel="external">翻转单词顺序</a></h2><h3 id="题目描述-41"><a href="#题目描述-41" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个英文句子, 翻转句子中单词的顺序,但单词内字符的顺序不变<br>为简单起见, 标点符号和前面的单词属于同一个单词</p>
<h3 id="最优题解-41"><a href="#最优题解-41" class="headerlink" title="最优题解"></a>最优题解</h3><p>两次翻转，第一次整体翻转，第二次每个单词再翻转（也可以先每个单词翻转然后整体翻转）</p>
<h3 id="代码-41"><a href="#代码-41" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ReverseSentence</span><span class="params">(self, s)</span>:</span></div><div class="line">        <span class="keyword">return</span> <span class="string">' '</span>.join(w[::<span class="number">-1</span>] <span class="keyword">for</span> w <span class="keyword">in</span> s[::<span class="number">-1</span>].split(<span class="string">' '</span>))</div></pre></td></tr></table></figure>
<h2 id="左旋转字符串"><a href="#左旋转字符串" class="headerlink" title="左旋转字符串"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/42_2_%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88%E5%BE%AA%E7%8E%AF%E5%B7%A6%E7%A7%BB%EF%BC%89.py" target="_blank" rel="external">左旋转字符串</a></h2><h3 id="题目描述-42"><a href="#题目描述-42" class="headerlink" title="题目描述"></a>题目描述</h3><p>汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。<br>对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。<br>例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。</p>
<h3 id="最优题解-42"><a href="#最优题解-42" class="headerlink" title="最优题解"></a>最优题解</h3><p>先分片后拼接</p>
<h3 id="代码-42"><a href="#代码-42" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">LeftRotateString</span><span class="params">(self, s, n)</span>:</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s: <span class="keyword">return</span> <span class="string">''</span></div><div class="line">        <span class="keyword">return</span> s[n%len(s):] + s[:n%len(s)]</div></pre></td></tr></table></figure>
<h2 id="n个骰子的点数"><a href="#n个骰子的点数" class="headerlink" title="n个骰子的点数"></a><a href="n%E4%B8%AA%E9%AA%B0%E5%AD%90%E7%9A%84%E7%82%B9%E6%95%B0">n个骰子的点数</a></h2><h3 id="题目描述-43"><a href="#题目描述-43" class="headerlink" title="题目描述"></a>题目描述</h3><p>把n个骰子扔在地上, 所有骰子朝上一面的点数和为s。<br>输入n, 打印出s的所有可能的值出现的次数（原题要求输出概率，为了方便这里只需输出次数）</p>
<h3 id="最优题解-43"><a href="#最优题解-43" class="headerlink" title="最优题解"></a>最优题解</h3><p>设n个骰子投掷点数和为s的出现次数是F(n, s)，<br>则F(n, s)等于(n-1)个骰子投掷的点数和为s-1、s-2、s-3、s-4、s-5、s-6时的次数的总和：<br>即 F(n, s) = F(n - 1, s - 1) + F(n - 1, s - 2) + F(n - 1, s - 3)  + F(n - 1, s - 4) + F(n - 1, s - 5) + F(n - 1, s - 6)。<br>所有的和出现次数总和为6^n，概率为F(n, s)/6^n。(n &lt;= s &lt;= 6n)</p>
<h3 id="代码-43"><a href="#代码-43" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">DicesProbability2</span><span class="params">(self, n)</span>:</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> n <span class="keyword">or</span> n &lt; <span class="number">1</span>:</div><div class="line">            <span class="keyword">return</span></div><div class="line">        maxVal = <span class="number">6</span></div><div class="line">        count = [[<span class="number">0</span>] * (maxVal * n + <span class="number">1</span>), []]  <span class="comment"># 构造两个数组来存放每一个和出现的次数，下标表示和，里面的值代表次数</span></div><div class="line">        flag = <span class="number">0</span>  <span class="comment"># 用flag来反复利用这两个数组</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, maxVal + <span class="number">1</span>):  <span class="comment"># 一开始只有一个骰子，当然次数都为1</span></div><div class="line">            count[flag][i] = <span class="number">1</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n + <span class="number">1</span>):  <span class="comment"># 逐渐加入其他骰子</span></div><div class="line">            <span class="comment"># 一开始另一个数组要初始化为0，因为每加入一个骰子就会使前面的和次数成为0</span></div><div class="line">            <span class="comment"># 比如，先是1个骰子时和为1的次数为1，当加入第二个骰子时，和为1是不可能出现的</span></div><div class="line">            <span class="comment"># 换句话说，就是和的范围是动态变化的，且一直往右移</span></div><div class="line">            count[<span class="number">1</span> - flag] = [<span class="number">0</span>] * (maxVal * n + <span class="number">1</span>)</div><div class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i, maxVal * i + <span class="number">1</span>):  <span class="comment"># i &lt;= s &lt;= 6*i</span></div><div class="line">                k = <span class="number">1</span></div><div class="line">                <span class="keyword">while</span> k &lt;= j <span class="keyword">and</span> k &lt;= maxVal:</div><div class="line">                    <span class="comment"># F(n, s) = F(n - 1, s - 1) + F(n - 1, s - 2) + F(n - 1, s - 3) + F(n - 1, s - 4) + F(n - 1, s - 5) + F(n - 1, s - 6)</span></div><div class="line">                    count[<span class="number">1</span> - flag][j] += count[flag][j - k]</div><div class="line">                    k += <span class="number">1</span></div><div class="line">            flag = <span class="number">1</span> - flag  <span class="comment"># 将flag更新，flag永远指向求和好的数组</span></div><div class="line">        <span class="keyword">return</span> [(i, count[flag][i]) <span class="keyword">for</span> i <span class="keyword">in</span> range(n, maxVal * n + <span class="number">1</span>)]</div></pre></td></tr></table></figure>
<h2 id="扑克牌的顺子"><a href="#扑克牌的顺子" class="headerlink" title="扑克牌的顺子"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/44_%E6%89%91%E5%85%8B%E7%89%8C%E7%9A%84%E9%A1%BA%E5%AD%90.py" target="_blank" rel="external">扑克牌的顺子</a></h2><h3 id="题目描述-44"><a href="#题目描述-44" class="headerlink" title="题目描述"></a>题目描述</h3><p>从扑克牌中随机抽取5张牌，判断是不是顺子，即这5张牌是不是连续的。2~10为数字本身，A为1，J~K为11~13，<br>而大小王可以看成任意数字。为方便起见这里把大小王看成0，且规定含有对子时不为顺子。<br>注意：这里大小王的个数不限，且输入参数的AJQK和大小王已经转换成相应数字</p>
<h3 id="最优题解-44"><a href="#最优题解-44" class="headerlink" title="最优题解"></a>最优题解</h3><p>时间O(n)，空间n(1)</p>
<ol>
<li>除0外没有重复的数(用位图来记录每个出现过的数字)，</li>
<li>max - min &lt; 5 （由于max和min动态变化，但最终max-min=4）</li>
</ol>
<h3 id="代码-44"><a href="#代码-44" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">IsContinuous1</span><span class="params">(self, numbers)</span>:</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> numbers <span class="keyword">or</span> len(numbers) != <span class="number">5</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">        <span class="comment"># 把A、J、Q、K转化一下</span></div><div class="line">        <span class="comment"># transDict = &#123;'A': 1, 'J': 11, 'Q': 12, 'K': 13&#125;</span></div><div class="line">        <span class="comment"># for i in range(len(numbers)):</span></div><div class="line">        <span class="comment">#     if numbers[i] in transDict.keys():</span></div><div class="line">        <span class="comment">#         numbers[i] = transDict[numbers[i]]</span></div><div class="line">        min = <span class="number">14</span></div><div class="line">        max = <span class="number">-1</span></div><div class="line">        flag = <span class="number">0</span>  <span class="comment"># 用位图来记录每个出现过的数字</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(numbers)):</div><div class="line">            number = numbers[i]</div><div class="line">            <span class="keyword">if</span> number &lt; <span class="number">0</span> <span class="keyword">or</span> number &gt; <span class="number">13</span>: <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">            <span class="keyword">if</span> number == <span class="number">0</span>: <span class="keyword">continue</span></div><div class="line">            <span class="keyword">if</span> ((flag &gt;&gt; number) &amp; <span class="number">1</span>) == <span class="number">1</span>: <span class="keyword">return</span> <span class="keyword">False</span>  <span class="comment"># 如果出现过，那么再次出现就是对子了</span></div><div class="line">            flag |= (<span class="number">1</span> &lt;&lt; number)  <span class="comment"># 记录出现过的数字</span></div><div class="line">            <span class="keyword">if</span> number &gt; max: max = number</div><div class="line">            <span class="keyword">if</span> number &lt; min: min = number</div><div class="line">            <span class="keyword">if</span> max - min &gt;= <span class="number">5</span>: <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">True</span></div></pre></td></tr></table></figure>
<h2 id="圆圈中最后剩下的数字（约瑟夫环问题）"><a href="#圆圈中最后剩下的数字（约瑟夫环问题）" class="headerlink" title="圆圈中最后剩下的数字（约瑟夫环问题）"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/45_%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97%EF%BC%88%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E9%97%AE%E9%A2%98%EF%BC%89.py" target="_blank" rel="external">圆圈中最后剩下的数字（约瑟夫环问题）</a></h2><h3 id="题目描述-45"><a href="#题目描述-45" class="headerlink" title="题目描述"></a>题目描述</h3><p>0, 1, 2, n-1这n个数字排成一个圆环, 从数字0开始每次从这个圆圈里删除第m个数字<br>求这个圆圈中最后剩下的一个数字。</p>
<h3 id="最优题解-45"><a href="#最优题解-45" class="headerlink" title="最优题解"></a>最优题解</h3><p>时间O(n)，空间O(1)</p>
<p>推导递归公式。定义f(n,m)表示每次在n个数字0，1，…，n-1中每次删除第m个数字最后剩下的数字，则有递归公式：</p>
<p>f(n,m) = [f(n-1,m)+m]%n  if n&gt;1；0  if n=1</p>
<p>具体推导过程直接看书P230~231</p>
<h3 id="代码-45"><a href="#代码-45" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="comment"># 循环实现</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">LastRemaining2</span><span class="params">(self, n, m)</span>:</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> n <span class="keyword">or</span> <span class="keyword">not</span> m:</div><div class="line">            <span class="keyword">return</span> <span class="number">-1</span></div><div class="line">        last = <span class="number">0</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n + <span class="number">1</span>):</div><div class="line">            last = (last + m) % i</div><div class="line">        <span class="keyword">return</span> last</div></pre></td></tr></table></figure>
<h2 id="求前n项和（各种限制）"><a href="#求前n项和（各种限制）" class="headerlink" title="求前n项和（各种限制）"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/46_%E6%B1%82%E5%89%8Dn%E9%A1%B9%E5%92%8C%EF%BC%88%E5%90%84%E7%A7%8D%E9%99%90%E5%88%B6%EF%BC%89.py" target="_blank" rel="external">求前n项和（各种限制）</a></h2><h3 id="题目描述-46"><a href="#题目描述-46" class="headerlink" title="题目描述"></a>题目描述</h3><p>求1+2+3+…+n，<br>要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p>
<h3 id="最优题解-46"><a href="#最优题解-46" class="headerlink" title="最优题解"></a>最优题解</h3><p>利用and运算的短路原则退出递归</p>
<h3 id="代码-46"><a href="#代码-46" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Sum1</span><span class="params">(self, n)</span>:</span></div><div class="line">        <span class="keyword">return</span> n <span class="keyword">and</span> (n + self.Sum1(n - <span class="number">1</span>))</div></pre></td></tr></table></figure>
<h2 id="不用加减乘除做加法"><a href="#不用加减乘除做加法" class="headerlink" title="不用加减乘除做加法"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/47_%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95.py" target="_blank" rel="external">不用加减乘除做加法</a></h2><h3 id="题目描述-47"><a href="#题目描述-47" class="headerlink" title="题目描述"></a>题目描述</h3><p>写一个函数，求两个整数之和，要求在函数体内不得使用+、-、 *  、/四则运算符号</p>
<h3 id="最优题解-47"><a href="#最优题解-47" class="headerlink" title="最优题解"></a>最优题解</h3><p>位运算，<br>1.两个数异或：相当于每一位相加，而不考虑进位；<br>2.两个数相与，并左移一位：相当于求得进位；<br>3.将上述两步的结果相加：相当于重复执行上述两步，直到不产生进位<br>由于python的整型是无限位数的，所以有可能导致不断进位，所以需要截取后32位，即&amp;0xffffffff<br>但这样就会导致和为负数时由于截取使得结果为正数，所以需要检查一下如果结果的最高位为1，<br>说明结果为负数，需要将最高位左边所有的0变为1，这样就可以变为负数，然后按照补码转换成正确的数值<br>(无需进行补码转换，机器内部自动转换)。也就是说需要保持右边32位不变而左边所有位取反，<br>所以可以先把右边32位局部取反，然后整体取反。局部取反可以^0xffffffff，而整体取反直接~</p>
<h3 id="代码-47"><a href="#代码-47" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Add</span><span class="params">(self, num1, num2)</span>:</span></div><div class="line">        mask = <span class="number">0xffffffff</span></div><div class="line">        <span class="keyword">while</span> num2:</div><div class="line">            num1, num2 = (num1 ^ num2) &amp; mask, ((num1 &amp; num2) &lt;&lt; <span class="number">1</span>) &amp; mask</div><div class="line">        <span class="keyword">return</span> num1 <span class="keyword">if</span> num1 &gt;&gt; <span class="number">31</span> == <span class="number">0</span> <span class="keyword">else</span> ~(num1 ^ mask)</div></pre></td></tr></table></figure>
<h2 id="把字符串转换成整数"><a href="#把字符串转换成整数" class="headerlink" title="把字符串转换成整数"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/49_%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E6%95%B0.py" target="_blank" rel="external">把字符串转换成整数</a></h2><h3 id="题目描述-48"><a href="#题目描述-48" class="headerlink" title="题目描述"></a>题目描述</h3><p>将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0</p>
<h3 id="最优题解-48"><a href="#最优题解-48" class="headerlink" title="最优题解"></a>最优题解</h3><p>考虑这么几点：<br>1、有无正负号<br>2、只有正负号<br>3、多个正负号开头<br>4、空串或None<br>5、非法字符<br>由于python整型无限长，所以不考虑正负溢出<br>（一般对于32位整型来讲，最大正整数是0x7fffffff，最小负整数是0x80000000）</p>
<h3 id="代码-48"><a href="#代码-48" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">StrToInt</span><span class="params">(self, s)</span>:</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span></div><div class="line">        start = <span class="number">0</span>  <span class="comment"># 标记开始转换的位置</span></div><div class="line">        minus = <span class="keyword">False</span>  <span class="comment"># 标记正负</span></div><div class="line">        <span class="keyword">if</span> s[<span class="number">0</span>] == <span class="string">'-'</span>:</div><div class="line">            start = <span class="number">1</span></div><div class="line">            minus = <span class="keyword">True</span></div><div class="line">        <span class="keyword">elif</span> s[<span class="number">0</span>] == <span class="string">'+'</span>:</div><div class="line">            start = <span class="number">1</span></div><div class="line">        sum = <span class="number">0</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(start, len(s)):</div><div class="line">            <span class="keyword">if</span> s[i] &lt; <span class="string">'0'</span> <span class="keyword">or</span> s[i] &gt; <span class="string">'9'</span>:  <span class="comment"># 含有非法字符返回0</span></div><div class="line">                <span class="keyword">return</span> <span class="number">0</span></div><div class="line">            sum = sum * <span class="number">10</span> + ord(s[i]) - ord(<span class="string">'0'</span>)</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span> * sum <span class="keyword">if</span> minus <span class="keyword">else</span> sum</div></pre></td></tr></table></figure>
<h2 id="二叉搜索树的最低公共祖先"><a href="#二叉搜索树的最低公共祖先" class="headerlink" title="二叉搜索树的最低公共祖先"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/50_1_%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E4%BD%8E%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.py" target="_blank" rel="external">二叉搜索树的最低公共祖先</a></h2><h3 id="题目描述-49"><a href="#题目描述-49" class="headerlink" title="题目描述"></a>题目描述</h3><p>找出二叉搜索树中两个结点的最低公共祖先</p>
<h3 id="最优题解-49"><a href="#最优题解-49" class="headerlink" title="最优题解"></a>最优题解</h3><p>二分法：从根节点开始，如果当前结点的值比两个结点都大，那么最低公共祖先在当前结点的左子树中；<br>如果当前结点的值比两个结点都小，那么最低公共祖先在当前结点的右子树中；<br>这样从上到下找到的第一个在两个输入结点的值之间的结点就是最低公共祖先</p>
<h3 id="代码-49"><a href="#代码-49" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></div><div class="line">        self.val = x</div><div class="line">        self.left = <span class="keyword">None</span></div><div class="line">        self.right = <span class="keyword">None</span></div><div class="line">		</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findParent</span><span class="params">(self, root, pNode1, pNode2)</span>:</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root <span class="keyword">or</span> <span class="keyword">not</span> pNode1 <span class="keyword">or</span> <span class="keyword">not</span> pNode2:</div><div class="line">            <span class="keyword">return</span></div><div class="line">        val1, val2 = pNode1.val, pNode2.val</div><div class="line">        <span class="keyword">while</span> root:</div><div class="line">            <span class="keyword">if</span> (val1 - root.val) * (val2 - root.val) &lt;= <span class="number">0</span>:</div><div class="line">                <span class="keyword">return</span> root</div><div class="line">            <span class="keyword">elif</span> val1 &gt; root.val <span class="keyword">and</span> val2 &gt; root.val:</div><div class="line">                root = root.right</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                root = root.left</div></pre></td></tr></table></figure>
<h2 id="满二叉树的最低公共祖先"><a href="#满二叉树的最低公共祖先" class="headerlink" title="满二叉树的最低公共祖先"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/50_2_%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E4%BD%8E%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.py" target="_blank" rel="external">满二叉树的最低公共祖先</a></h2><h3 id="题目描述-50"><a href="#题目描述-50" class="headerlink" title="题目描述"></a>题目描述</h3><p>找出满二叉树中两个结点的最低公共祖先（没有指向父节点的指针）</p>
<h3 id="最优题解-50"><a href="#最优题解-50" class="headerlink" title="最优题解"></a>最优题解</h3><p>层序遍历满二叉树，给每个结点编号，从1开始。<br>根据满二叉树的特点，假设子树的结点编号为k，则其左孩子编号为2k，<br>右孩子编号为2k+1。用二进制表示就是k左移以及k左移+1。<br>也就是在父结点的二进制表示的后面添1或添0。<br>所以两个结点的最低公共祖先就是它们编号二进制表示的最长前缀所对应编号的结点</p>
<h3 id="代码-50"><a href="#代码-50" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></div><div class="line">        self.val = x</div><div class="line">        self.left = <span class="keyword">None</span></div><div class="line">        self.right = <span class="keyword">None</span></div><div class="line">		</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findParent</span><span class="params">(self, root, pNode1, pNode2)</span>:</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root <span class="keyword">or</span> <span class="keyword">not</span> pNode1 <span class="keyword">or</span> <span class="keyword">not</span> pNode2:</div><div class="line">            <span class="keyword">return</span></div><div class="line">        <span class="comment"># 层序遍历给两个结点编号</span></div><div class="line">        queue = [(root, <span class="number">1</span>)]</div><div class="line">        num = <span class="number">1</span></div><div class="line">        <span class="keyword">while</span> queue:</div><div class="line">            cur = queue.pop(<span class="number">0</span>)</div><div class="line">            <span class="keyword">if</span> cur[<span class="number">0</span>] <span class="keyword">is</span> pNode1:</div><div class="line">                num1 = cur[<span class="number">1</span>]</div><div class="line">            <span class="keyword">if</span> cur[<span class="number">0</span>] <span class="keyword">is</span> pNode2:  <span class="comment"># 考虑到两个结点可能为同一结点，不能用elif</span></div><div class="line">                num2 = cur[<span class="number">1</span>]</div><div class="line">            <span class="keyword">if</span> cur[<span class="number">0</span>].left:</div><div class="line">                num += <span class="number">1</span></div><div class="line">                queue.append((cur[<span class="number">0</span>].left, num))</div><div class="line">            <span class="keyword">if</span> cur[<span class="number">0</span>].right:</div><div class="line">                num += <span class="number">1</span></div><div class="line">                queue.append((cur[<span class="number">0</span>].right, num))</div><div class="line">        <span class="comment"># 寻找最长前缀，为父节点编号</span></div><div class="line">        <span class="keyword">while</span> num1 != num2:</div><div class="line">            <span class="keyword">if</span> num1 &gt; num2:</div><div class="line">                num1 &gt;&gt;= <span class="number">1</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                num2 &gt;&gt;= <span class="number">1</span></div><div class="line">        parentNum = num1</div><div class="line">        <span class="comment"># 层序遍历，根据编号找到父结点返回</span></div><div class="line">        <span class="keyword">if</span> parentNum == <span class="number">1</span>:</div><div class="line">            <span class="keyword">return</span> root</div><div class="line">        queue = [root]</div><div class="line">        parentNum -= <span class="number">1</span></div><div class="line">        <span class="keyword">while</span> queue:</div><div class="line">            cur = queue.pop(<span class="number">0</span>)</div><div class="line">            <span class="keyword">if</span> cur.left:</div><div class="line">                queue.append(cur.left)</div><div class="line">                parentNum -= <span class="number">1</span></div><div class="line">                <span class="keyword">if</span> parentNum == <span class="number">0</span>:</div><div class="line">                    <span class="keyword">return</span> cur.left</div><div class="line">            <span class="keyword">if</span> cur.right:</div><div class="line">                queue.append(cur.right)</div><div class="line">                parentNum -= <span class="number">1</span></div><div class="line">                <span class="keyword">if</span> parentNum == <span class="number">0</span>:</div><div class="line">                    <span class="keyword">return</span> cur.right</div></pre></td></tr></table></figure>
<h2 id="二叉树的最低公共祖先"><a href="#二叉树的最低公共祖先" class="headerlink" title="二叉树的最低公共祖先"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/50_3_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E4%BD%8E%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.py" target="_blank" rel="external">二叉树的最低公共祖先</a></h2><h3 id="题目描述-51"><a href="#题目描述-51" class="headerlink" title="题目描述"></a>题目描述</h3><p>找出二叉树中两个结点的最低公共祖先（没有指向父节点的指针）</p>
<h3 id="最优题解-51"><a href="#最优题解-51" class="headerlink" title="最优题解"></a>最优题解</h3><ul>
<li>结束递归</li>
</ul>
<p>如果遇到了目标节点就返回那个目标节点，表示找到了该结点；<br>如果是None就返回None，表示没有找到。</p>
<ul>
<li>继续递归</li>
</ul>
<p>既不是None也不是目标节点，说明要接着递归往下左右子树遍历，<br>收集下面传上来的有关子树中出现目标节点的信息</p>
<ul>
<li>处理递归返回的信息</li>
</ul>
<p>如果左子树、右子树都有找到，说明自己就是最小公共祖先了，返回本身；<br>只有一边找到，则说明自己不是最小公共祖先，而是在最小公共祖先的上面，<br>且间接说明这个传上来的结点就是最小公共祖先，把这个传上来的结点继续往上传；<br>两边都没有找到则直接返回None，表示没有找到。</p>
<p>前两题都是根据二叉树本身的性质（搜索二叉树的有序性以及满二叉树的编号规律）进行寻找，<br>而这一题的解法是通用的，且这里的递归框架更是具有通用性：<br>后序遍历树，使树自下而上传递信息，<br>根据这些信息构造相同结构的新的信息往上传，类似承上启下，这里是承下启上</p>
<h3 id="代码-51"><a href="#代码-51" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></div><div class="line">        self.val = x</div><div class="line">        self.left = <span class="keyword">None</span></div><div class="line">        self.right = <span class="keyword">None</span></div><div class="line">	</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findParent</span><span class="params">(self, root, pNode1, pNode2)</span>:</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root <span class="keyword">or</span> root <span class="keyword">is</span> pNode1 <span class="keyword">or</span> root <span class="keyword">is</span> pNode2: <span class="keyword">return</span> root</div><div class="line">        left = self.findParent2(root.left, pNode1, pNode2)</div><div class="line">        right = self.findParent2(root.right, pNode1, pNode2)</div><div class="line">        <span class="keyword">return</span> root <span class="keyword">if</span> left <span class="keyword">and</span> right <span class="keyword">else</span> left <span class="keyword">or</span> right</div></pre></td></tr></table></figure>
<h2 id="数组中重复的数字"><a href="#数组中重复的数字" class="headerlink" title="数组中重复的数字"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/51_%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97.py" target="_blank" rel="external">数组中重复的数字</a></h2><h3 id="题目描述-52"><a href="#题目描述-52" class="headerlink" title="题目描述"></a>题目描述</h3><p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。<br>数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。<br>请找出数组中重复的数字，没有则返回-1。<br>例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是重复的数字2或者3。</p>
<h3 id="最优题解-52"><a href="#最优题解-52" class="headerlink" title="最优题解"></a>最优题解</h3><p>时间O(n), 空间O(1)</p>
<p>由于长度为n的数组里的所有数字都在0到n-1的范围内，所以如果没有重复数字的话，<br>那么从小到大排序后的数组每个数和它的下标应该是相等的。所以我们只需从头遍历数组，<br>看每个数字和它下标是否相等，相等就遍历下一个，<br>不相等就和它应该在的位置上（下标和它相等）的数字交换，<br>交换前先检查一下如果那个数字和它相等那么就找到了重复数字了，并且没有必要交换，遍历下一个。</p>
<h3 id="代码-52"><a href="#代码-52" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="comment"># 返回重复数字的列表，没有直接返回-1</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">duplicate1</span><span class="params">(self, numbers)</span>:</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> numbers:</div><div class="line">            <span class="keyword">return</span> <span class="number">-1</span></div><div class="line">        duplicate_num = []</div><div class="line">        length = len(numbers)</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> numbers:</div><div class="line">            <span class="keyword">if</span> i &lt; <span class="number">0</span> <span class="keyword">or</span> i &gt; length - <span class="number">1</span>:</div><div class="line">                <span class="keyword">return</span> <span class="number">-1</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</div><div class="line">            <span class="comment"># 当再次遍历到那个重复数字时该重复数字是在正确位置上的，所以不会进入while循环</span></div><div class="line">            <span class="keyword">while</span> numbers[i] != i:  <span class="comment"># 这里用while而不是if是因为交换过来的数字还没被检查过</span></div><div class="line">                <span class="keyword">if</span> numbers[i] == numbers[numbers[i]]:</div><div class="line">                    duplicate_num.append(numbers[i])</div><div class="line">                    <span class="keyword">break</span>  <span class="comment"># 找到了就跳到下一个，因为没有发生交换</span></div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    index = numbers[i]  <span class="comment"># 这里必须把numbers[i]抽出来而不能直接带入下面的表达式中</span></div><div class="line">                    numbers[i], numbers[index] = numbers[index], numbers[i]</div><div class="line">        <span class="keyword">return</span> duplicate_num <span class="keyword">if</span> duplicate_num <span class="keyword">else</span> <span class="number">-1</span></div></pre></td></tr></table></figure>
<h2 id="构建乘积数组"><a href="#构建乘积数组" class="headerlink" title="构建乘积数组"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/52_%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84.py" target="_blank" rel="external">构建乘积数组</a></h2><h3 id="题目描述-53"><a href="#题目描述-53" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1]<br>使得B中的元素B[i]=A[0]*A<a href="https://github.com/Hk4Fun/algorithm_offer/tree/master/target_offer" target="_blank" rel="external">1</a>*…*A[i-1]*A[i+1]*…*A[n-1]，不能使用除法。</p>
<h3 id="最优题解-53"><a href="#最优题解-53" class="headerlink" title="最优题解"></a>最优题解</h3><p>时间O(n)，空间O(1)</p>
<p>把B[i]拆成前i项和后（n-i）项，分别求乘积，再相乘<br>即B[i]=C[i]*D[i]=(A[0]*A<a href="https://github.com/Hk4Fun/algorithm_offer/tree/master/target_offer" target="_blank" rel="external">1</a>* …*A[i-1])*(A[i+1]*…*A[n-1])<br>而C[i]=C[i-1]*A[i-1], D[i]=D[i+1]*A[i+1]<br>同时利用数组B的空间来节省数组C和D的空间</p>
<h3 id="代码-53"><a href="#代码-53" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">multiply</span><span class="params">(self, A)</span>:</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> A <span class="keyword">or</span> len(A) == <span class="number">1</span>:</div><div class="line">            <span class="keyword">return</span></div><div class="line">        length = len(A)</div><div class="line">        B = [<span class="number">1</span>]</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, length):</div><div class="line">            B.append(B[i - <span class="number">1</span>] * A[i - <span class="number">1</span>])  <span class="comment"># 自上而下计算上三角</span></div><div class="line">        tmp = <span class="number">1</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length - <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</div><div class="line">            tmp *= A[i + <span class="number">1</span>]  <span class="comment"># 自下而上计算下三角</span></div><div class="line">            B[i] *= tmp  <span class="comment"># B[i]=C[i]*D[i]</span></div><div class="line">        <span class="keyword">return</span> B</div></pre></td></tr></table></figure>
<h2 id="正则表达式匹配"><a href="#正则表达式匹配" class="headerlink" title="正则表达式匹配"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/53_%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D.py" target="_blank" rel="external">正则表达式匹配</a></h2><h3 id="题目描述-54"><a href="#题目描述-54" class="headerlink" title="题目描述"></a>题目描述</h3><p>请实现一个函数用来匹配包括’.’和’*‘的正则表达式。<br>模式中的字符’.’表示任意一个字符，而’ <em> ‘表示它前面的字符可以出现任意次（包含0次）。<br>在本题中，匹配是指字符串的所有字符匹配整个模式。<br>例如，字符串”aaa”与模式”a.a”和”ab\</em>ac*a”匹配，但是与”aa.a”和”ab*a”均不匹配</p>
<h3 id="最优题解-54"><a href="#最优题解-54" class="headerlink" title="最优题解"></a>最优题解</h3><p>当模式中的第二个字符是“*”时：<br>如果字符串第一个字符跟模式第一个字符不匹配，则模式后移2个字符，字符串不变，继续匹配；<br>如果字符串第一个字符跟模式第一个字符匹配，可以有3种匹配方式：<br>1、字符串后移1字符，模式不变，即继续匹配字符下一位，因为*可以匹配多位；<br>2、模式后移2字符，字符串不变，相当于x*被忽略；<br>3、字符串后移1字符，模式后移2字符；<br>其中第三种情况可以由前两种组合，所以可以省略<br>而当模式中的第二个字符不是“*”时：<br>1、如果字符串第一个字符和模式中的第一个字符相匹配，那么字符串和模式都后移一个字符，接着匹配剩余的。<br>2、如果字符串第一个字符和模式中的第一个字符相不匹配，直接返回false。</p>
<h3 id="代码-54"><a href="#代码-54" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">match</span><span class="params">(self, s, pattern)</span>:</span></div><div class="line">        <span class="keyword">if</span> s == <span class="keyword">None</span> <span class="keyword">or</span> pattern == <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">        <span class="keyword">if</span> s == <span class="string">''</span> <span class="keyword">and</span> pattern == <span class="string">''</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">        <span class="keyword">if</span> s != <span class="string">''</span> <span class="keyword">and</span> pattern == <span class="string">''</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">        <span class="keyword">if</span> len(pattern) &gt; <span class="number">1</span> <span class="keyword">and</span> pattern[<span class="number">1</span>] == <span class="string">'*'</span>:</div><div class="line">            <span class="keyword">if</span> s != <span class="string">''</span> <span class="keyword">and</span> (pattern[<span class="number">0</span>] == s[<span class="number">0</span>] <span class="keyword">or</span> pattern[<span class="number">0</span>] == <span class="string">'.'</span>):</div><div class="line">                <span class="keyword">return</span> self.match1(s[<span class="number">1</span>:], pattern) \</div><div class="line">                       <span class="keyword">or</span> self.match1(s, pattern[<span class="number">2</span>:]) \</div><div class="line">                    <span class="comment"># or self.match(s[1:], pattern[2:]) # 该情况可以由前两种情况组合，所以可以省略</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                <span class="keyword">return</span> self.match1(s, pattern[<span class="number">2</span>:])</div><div class="line">        <span class="keyword">if</span> s != <span class="string">''</span> <span class="keyword">and</span> (s[<span class="number">0</span>] == pattern[<span class="number">0</span>] <span class="keyword">or</span> pattern[<span class="number">0</span>] == <span class="string">'.'</span>):</div><div class="line">            <span class="keyword">return</span> self.match1(s[<span class="number">1</span>:], pattern[<span class="number">1</span>:])</div><div class="line">        <span class="keyword">return</span> <span class="keyword">False</span></div></pre></td></tr></table></figure>
<h2 id="表示数值的字符串"><a href="#表示数值的字符串" class="headerlink" title="表示数值的字符串"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/54_%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2.py" target="_blank" rel="external">表示数值的字符串</a></h2><h3 id="题目描述-55"><a href="#题目描述-55" class="headerlink" title="题目描述"></a>题目描述</h3><p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。<br>例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。<br>但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。</p>
<h3 id="最优题解-55"><a href="#最优题解-55" class="headerlink" title="最优题解"></a>最优题解</h3><p>数字的格式可以用A[.[B]][e|EC]或者.B[e|EC]表示，其中A和C都是整数（可以有正负号，也可以没有），<br>而B是一个无符号整数。考虑这么几种情况：<br>对于小数点’.’，前后A和B的出现形成或的关系：</p>
<ol>
<li>小数可以没有整数部分，例如.123等于0.123；</li>
<li>小数点后面可以没有数字，例如233.等于233.0；</li>
<li>当然小数点前面和后面可以有数字，例如233.666</li>
<li>但不能单独出现小数点’.’<br>对于指数符号e或E，前后形成与的关系：<br>当e或E前面没有数字时，整个字符串不能表示数字，例如.e1、e1；<br>当e或E后面没有整数时，整个字符串不能表示数字，例如12e、12e+5.4</li>
</ol>
<h3 id="代码-55"><a href="#代码-55" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isNumeric1</span><span class="params">(self, s)</span>:</span></div><div class="line">        <span class="keyword">import</span> re <span class="comment"># 使用内置的re标准库快速匹配</span></div><div class="line">        <span class="keyword">if</span> s:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">True</span> <span class="keyword">if</span> re.match(<span class="string">r'^[+-]?(\d+|(\.\d+)|(\d+\.)|(\d+\.\d+))([eE][+-]?\d+)?$'</span>, s) <span class="keyword">else</span> <span class="keyword">False</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">		</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isNumeric2</span><span class="params">(self, s)</span>:</span> <span class="comment"># 自己造轮子</span></div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">scanUnsignedInteger</span><span class="params">(s)</span>:</span></div><div class="line">            beforeLength = len(s)</div><div class="line">            <span class="keyword">while</span> s <span class="keyword">and</span> s[<span class="number">0</span>] &gt;= <span class="string">'0'</span> <span class="keyword">and</span> s[<span class="number">0</span>] &lt;= <span class="string">'9'</span>:</div><div class="line">                s.pop(<span class="number">0</span>)</div><div class="line">            <span class="keyword">return</span> len(s) &lt; beforeLength</div><div class="line">			</div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">scanInteger</span><span class="params">(s)</span>:</span></div><div class="line">            <span class="keyword">if</span> s <span class="keyword">and</span> (s[<span class="number">0</span>] == <span class="string">'+'</span> <span class="keyword">or</span> s[<span class="number">0</span>] == <span class="string">'-'</span>):</div><div class="line">                s.pop(<span class="number">0</span>)</div><div class="line">            <span class="keyword">return</span> scanUnsignedInteger(s)</div><div class="line">			</div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">        s = list(s)</div><div class="line">        numeric = scanInteger(s)</div><div class="line">        <span class="keyword">if</span> s <span class="keyword">and</span> s[<span class="number">0</span>] == <span class="string">'.'</span>:</div><div class="line">            s.pop(<span class="number">0</span>)</div><div class="line">            numeric = scanUnsignedInteger(s) <span class="keyword">or</span> numeric</div><div class="line">			</div><div class="line">        <span class="keyword">if</span> s <span class="keyword">and</span> (s[<span class="number">0</span>] == <span class="string">'e'</span> <span class="keyword">or</span> s[<span class="number">0</span>] == <span class="string">'E'</span>):</div><div class="line">            s.pop(<span class="number">0</span>)</div><div class="line">            numeric = scanInteger(s) <span class="keyword">and</span> numeric</div><div class="line">        <span class="keyword">return</span> numeric <span class="keyword">and</span> s == []</div></pre></td></tr></table></figure>
<h2 id="字符流中第一个不重复的字符"><a href="#字符流中第一个不重复的字符" class="headerlink" title="字符流中第一个不重复的字符"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/55_%E5%AD%97%E7%AC%A6%E6%B5%81%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E7%AC%A6.py" target="_blank" rel="external">字符流中第一个不重复的字符</a></h2><h3 id="题目描述-56"><a href="#题目描述-56" class="headerlink" title="题目描述"></a>题目描述</h3><p>请实现一个函数用来找出字符流中第一个只出现一次的字符。<br>例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。<br>当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。<br>如果当前字符流没有存在出现一次的字符，返回#字符。</p>
<h3 id="最优题解-56"><a href="#最优题解-56" class="headerlink" title="最优题解"></a>最优题解</h3><p>哈希表值表示该字符在字符流中首次出现的位置，另外用index来记录目前读取的字符流的位置<br>读取字符时在相应的哈希表位置上看一下是否&gt;=0(哈希表初始化为-1)，<br>如果是说明该字符之前出现过，则把值更新为-2，表示该字符重复出现；<br>否则说明是第一次出现，把值更新为该字符的出现的位置index<br>找出当前第一个出现一次的字符时只需扫描整个哈希表，找出最小的大于等于0的值（在字符流中首次出现的位置）对应字符返回即可</p>
<h3 id="代码-56"><a href="#代码-56" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.hashList = [<span class="number">-1</span>] * <span class="number">256</span></div><div class="line">        self.index = <span class="number">0</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Insert</span><span class="params">(self, char)</span>:</span></div><div class="line">        asc = ord(char)</div><div class="line">        <span class="keyword">if</span> self.hashList[asc] == <span class="number">-1</span>:</div><div class="line">            self.hashList[asc] = self.index</div><div class="line">        <span class="keyword">elif</span> self.hashList[asc] &gt;= <span class="number">0</span>:</div><div class="line">            self.hashList[asc] = <span class="number">-2</span></div><div class="line">        self.index += <span class="number">1</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FirstAppearingOnce</span><span class="params">(self)</span>:</span></div><div class="line">        ch = <span class="string">'#'</span></div><div class="line">        minIndex = float(<span class="string">"inf"</span>)</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">256</span>):</div><div class="line">            <span class="keyword">if</span> <span class="number">0</span> &lt;= self.hashList[i] &lt; minIndex:</div><div class="line">                ch = chr(i)</div><div class="line">                minIndex = self.hashList[i]</div><div class="line">        <span class="keyword">return</span> ch</div></pre></td></tr></table></figure>
<h2 id="链表中环的入口结点"><a href="#链表中环的入口结点" class="headerlink" title="链表中环的入口结点"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/56_%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E7%BB%93%E7%82%B9.py" target="_blank" rel="external">链表中环的入口结点</a></h2><h3 id="题目描述-57"><a href="#题目描述-57" class="headerlink" title="题目描述"></a>题目描述</h3><p>一个链表中包含环，请找出该链表的环的入口结点。</p>
<h3 id="最优题解-57"><a href="#最优题解-57" class="headerlink" title="最优题解"></a>最优题解</h3><p>先获取环的长度n，然后在头部设两个指针p1，p2，让p1先走n步，然后两个指针以相同速度向前移动，<br>当二者首次相遇时，相遇点即为环的入口点。那么如何获取环的长度？这在15_5中也有相应的思路：<br>在头部设两个指针，快指针fast每次走2步，慢指针slow每次走1步，则两者一定在环中相遇。<br>相遇后fast不动，让slow接着走，一边走一边计步数，则当它再次来到相遇点（fast的位置）时，<br>所走过的步数即为环的长度。记得在获取环的长度之前先判断是否含环：slow和fast能相遇说明含环</p>
<h3 id="代码-57"><a href="#代码-57" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></div><div class="line">        self.val = x</div><div class="line">        self.next = <span class="keyword">None</span></div><div class="line">		</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">EntryNodeOfLoop</span><span class="params">(self, pHead)</span>:</span></div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">isLoop</span><span class="params">(head)</span>:</span></div><div class="line">            slow = fast = head</div><div class="line">            <span class="keyword">while</span> fast.next <span class="keyword">and</span> fast.next.next:</div><div class="line">                slow = slow.next</div><div class="line">                fast = fast.next.next</div><div class="line">                <span class="keyword">if</span> slow <span class="keyword">is</span> fast:</div><div class="line">                    <span class="keyword">return</span> slow</div><div class="line">            <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">        </div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">loopLen</span><span class="params">(meetnode)</span>:</span></div><div class="line">            cur, length = meetnode, <span class="number">1</span></div><div class="line">            <span class="keyword">while</span> cur.next != meetnode:</div><div class="line">                cur = cur.next</div><div class="line">                length += <span class="number">1</span></div><div class="line">            <span class="keyword">return</span> length</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pHead: <span class="keyword">return</span></div><div class="line">        meetnode = isLoop(pHead)</div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> meetnode: <span class="keyword">return</span> </div><div class="line">        length = loopLen(meetnode)</div><div class="line">        cur1 = cur2 = pHead</div><div class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(length):</div><div class="line">            cur1 = cur1.next</div><div class="line">        <span class="keyword">while</span> cur1 <span class="keyword">is</span> <span class="keyword">not</span> cur2:</div><div class="line">            cur1, cur2 = cur1.next, cur2.next</div><div class="line">        <span class="keyword">return</span> cur1</div></pre></td></tr></table></figure>
<h2 id="删除链表中重复的结点"><a href="#删除链表中重复的结点" class="headerlink" title="删除链表中重复的结点"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/57_%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E7%BB%93%E7%82%B9.py" target="_blank" rel="external">删除链表中重复的结点</a></h2><h3 id="题目描述-58"><a href="#题目描述-58" class="headerlink" title="题目描述"></a>题目描述</h3><p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。<br>例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5</p>
<h3 id="最优题解-58"><a href="#最优题解-58" class="headerlink" title="最优题解"></a>最优题解</h3><p>双指针。<br>pre和cur，cur负责在前面‘探路’，遇到重复结点就一直往后删除，<br>确认是唯一结点就让pre后移，这样pre其实一直指向唯一结点的尾部。<br>注意头结点可能和后面的结点重复，所以头结点可能被删除<br>为了减少代码的理解复杂度，引入伪结点dummy</p>
<h3 id="代码-58"><a href="#代码-58" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></div><div class="line">        self.val = x</div><div class="line">        self.next = <span class="keyword">None</span></div><div class="line">		</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplication</span><span class="params">(self, pHead)</span>:</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pHead: <span class="keyword">return</span></div><div class="line">        pre = dummy = ListNode(<span class="number">0</span>) <span class="comment"># 使用伪结点</span></div><div class="line">        dummy.next = cur = pHead</div><div class="line">        <span class="keyword">while</span> cur:</div><div class="line">            <span class="keyword">if</span> cur.next <span class="keyword">and</span> cur.next.val == cur.val: <span class="comment"># 遇到相等的结点</span></div><div class="line">                val = cur.val</div><div class="line">                <span class="keyword">while</span> cur <span class="keyword">and</span> cur.val == val: <span class="comment"># 连续删除重复结点</span></div><div class="line">                    pre.next = cur.next</div><div class="line">                    cur = cur.next</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                pre, cur = pre.next, cur.next</div><div class="line">        <span class="keyword">return</span> dummy.next <span class="comment"># 伪结点的下一个结点就是链表头结点</span></div></pre></td></tr></table></figure>
<h2 id="二叉树的下一个结点（中序）"><a href="#二叉树的下一个结点（中序）" class="headerlink" title="二叉树的下一个结点（中序）"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/58_1_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9%EF%BC%88%E4%B8%AD%E5%BA%8F%EF%BC%89.py" target="_blank" rel="external">二叉树的下一个结点（中序）</a></h2><h3 id="题目描述-59"><a href="#题目描述-59" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。<br>注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p>
<h3 id="最优题解-59"><a href="#最优题解-59" class="headerlink" title="最优题解"></a>最优题解</h3><p>该结点若有右子树就找到右子树的最左结点；<br>没有右子树则向上找到第一个当前结点是其父结点左孩子的结点的父结点；<br>退到了根节点仍没找到则返回None</p>
<h3 id="代码-59"><a href="#代码-59" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></div><div class="line">        self.val = x</div><div class="line">        self.left = <span class="keyword">None</span></div><div class="line">        self.right = <span class="keyword">None</span></div><div class="line">        self.parent = <span class="keyword">None</span></div><div class="line">		</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetNext</span><span class="params">(self, pNode)</span>:</span></div><div class="line">        <span class="comment"># write code here</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pNode: <span class="keyword">return</span></div><div class="line">        <span class="keyword">if</span> pNode.right:</div><div class="line">            cur = pNode.right</div><div class="line">            <span class="keyword">while</span> cur.left:</div><div class="line">                cur = cur.left</div><div class="line">            <span class="keyword">return</span> cur</div><div class="line">        <span class="keyword">while</span> pNode.next:</div><div class="line">            <span class="keyword">if</span> pNode.next.left <span class="keyword">is</span> pNode:</div><div class="line">                <span class="keyword">return</span> pNode.next</div><div class="line">            pNode = pNode.next</div></pre></td></tr></table></figure>
<h3 id="举一反三-10"><a href="#举一反三-10" class="headerlink" title="举一反三"></a>举一反三</h3><ul>
<li><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/58_2_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8A%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9%EF%BC%88%E4%B8%AD%E5%BA%8F%EF%BC%89.py" target="_blank" rel="external">二叉树的上一个结点（中序）</a></li>
<li><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/58_3_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9%EF%BC%88%E5%89%8D%E5%BA%8F%EF%BC%89.py" target="_blank" rel="external">二叉树的下一个结点（前序）</a></li>
<li><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/58_4_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8A%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9%EF%BC%88%E5%89%8D%E5%BA%8F%EF%BC%89.py" target="_blank" rel="external">二叉树的上一个结点（前序）</a></li>
<li><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/58_5_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9%EF%BC%88%E5%90%8E%E5%BA%8F%EF%BC%89.py" target="_blank" rel="external">二叉树的下一个结点（后序）</a></li>
<li><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/58_6_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8A%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9%EF%BC%88%E5%90%8E%E5%BA%8F%EF%BC%89.py" target="_blank" rel="external">二叉树的上一个结点（后序）</a></li>
<li><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/58_7_%E6%80%BB%E7%BB%931-6.py" target="_blank" rel="external">总结</a></li>
<li><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/58_8_%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%BB%93%E7%82%B9%E7%9A%84%E7%88%B6%E7%BB%93%E7%82%B9.py" target="_blank" rel="external">二叉树中结点的父结点</a></li>
</ul>
<h2 id="对称的二叉树"><a href="#对称的二叉树" class="headerlink" title="对称的二叉树"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/59_%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91.py" target="_blank" rel="external">对称的二叉树</a></h2><h3 id="题目描述-60"><a href="#题目描述-60" class="headerlink" title="题目描述"></a>题目描述</h3><p>请实现一个函数，用来判断一颗二叉树是不是对称的。<br>注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</p>
<h3 id="最优题解-60"><a href="#最优题解-60" class="headerlink" title="最优题解"></a>最优题解</h3><p>前序遍历，把当前结点的左右子树看成俩棵树，<br>只有当左树的左子树和右树的右子树相同<br>并且左树的右子树和右树的左子树相同才对称</p>
<h3 id="代码-60"><a href="#代码-60" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></div><div class="line">        self.val = x</div><div class="line">        self.left = <span class="keyword">None</span></div><div class="line">        self.right = <span class="keyword">None</span></div><div class="line">		</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetrical</span><span class="params">(self, pRoot)</span>:</span></div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">sym</span><span class="params">(root1, root2)</span>:</span></div><div class="line">            <span class="keyword">if</span> (root1 <span class="keyword">and</span> <span class="keyword">not</span> root2) <span class="keyword">or</span> (<span class="keyword">not</span> root1 <span class="keyword">and</span> root2): <span class="keyword">return</span> <span class="keyword">False</span> </div><div class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root1 <span class="keyword">and</span> <span class="keyword">not</span> root2: <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">            <span class="keyword">if</span> root1.val != root2.val: <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">            <span class="keyword">return</span> sym(root1.left, root2.right) <span class="keyword">and</span> sym(root1.right, root2.left)</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> sym(pRoot, pRoot)</div></pre></td></tr></table></figure>
<h2 id="把二叉树打印成多行"><a href="#把二叉树打印成多行" class="headerlink" title="把二叉树打印成多行"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/60_%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%93%E5%8D%B0%E6%88%90%E5%A4%9A%E8%A1%8C.py" target="_blank" rel="external">把二叉树打印成多行</a></h2><h3 id="题目描述-61"><a href="#题目描述-61" class="headerlink" title="题目描述"></a>题目描述</h3><p>从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</p>
<h3 id="最优题解-61"><a href="#最优题解-61" class="headerlink" title="最优题解"></a>最优题解</h3><p>层次遍历，队列实现</p>
<h3 id="代码-61"><a href="#代码-61" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></div><div class="line">        self.val = x</div><div class="line">        self.left = <span class="keyword">None</span></div><div class="line">        self.right = <span class="keyword">None</span></div><div class="line">		</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="comment"># 返回二维列表[[1,2],[4,5]]</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Print</span><span class="params">(self, pRoot)</span>:</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot: <span class="keyword">return</span> []</div><div class="line">        level, res = [pRoot], []</div><div class="line">        <span class="keyword">while</span> level:</div><div class="line">            next_level = []</div><div class="line">            res.append([])</div><div class="line">            <span class="keyword">for</span> cur <span class="keyword">in</span> level:</div><div class="line">                res[<span class="number">-1</span>].append(cur.val)</div><div class="line">                <span class="keyword">if</span> cur.left:</div><div class="line">                    next_level.append(cur.left)</div><div class="line">                <span class="keyword">if</span> cur.right:</div><div class="line">                    next_level.append(cur.right)</div><div class="line">                level = next_level</div><div class="line">        <span class="keyword">return</span> res</div></pre></td></tr></table></figure>
<h2 id="按之字型顺序打印二叉树"><a href="#按之字型顺序打印二叉树" class="headerlink" title="按之字型顺序打印二叉树"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/61_%E6%8C%89%E4%B9%8B%E5%AD%97%E5%9E%8B%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91.py" target="_blank" rel="external">按之字型顺序打印二叉树</a></h2><h3 id="题目描述-62"><a href="#题目描述-62" class="headerlink" title="题目描述"></a>题目描述</h3><p>请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，<br>第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。</p>
<h3 id="最优题解-62"><a href="#最优题解-62" class="headerlink" title="最优题解"></a>最优题解</h3><p>一个队列实现。用一个队列来保存即可，<br>只不过在打印时奇数层append(cur.val)而偶数层insert(0, cur.val)。<br>为什么可以只用一个队列来完成？<br>因为队列取数和存数在两头，而栈都在同一头，所以队列可以保证存数时不影响取数。<br>每次在取出本层结点时固定本层的结点数即可，不会越界取出下一层的结点，<br>使得下一层的结点能在下一个循环取出。</p>
<h3 id="代码-62"><a href="#代码-62" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></div><div class="line">        self.val = x</div><div class="line">        self.left = <span class="keyword">None</span></div><div class="line">        self.right = <span class="keyword">None</span></div><div class="line">		</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Print</span><span class="params">(self, pRoot)</span>:</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot: <span class="keyword">return</span> []</div><div class="line">        queue = [pRoot]</div><div class="line">        res = []</div><div class="line">        next = <span class="number">0</span></div><div class="line">        <span class="keyword">while</span> queue:</div><div class="line">            res.append([])</div><div class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(queue)):</div><div class="line">                cur = queue.pop(<span class="number">0</span>)</div><div class="line">                <span class="keyword">if</span> next == <span class="number">0</span>:</div><div class="line">                    res[<span class="number">-1</span>].append(cur.val)</div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    res[<span class="number">-1</span>].insert(<span class="number">0</span>, cur.val)</div><div class="line">                <span class="keyword">if</span> cur.left:</div><div class="line">                    queue.append(cur.left)</div><div class="line">                <span class="keyword">if</span> cur.right:</div><div class="line">                    queue.append(cur.right)</div><div class="line">            next = <span class="number">1</span> - next</div><div class="line">        <span class="keyword">return</span> res</div></pre></td></tr></table></figure>
<h2 id="二叉树的序列化和反序列化"><a href="#二叉树的序列化和反序列化" class="headerlink" title="二叉树的序列化和反序列化"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/62_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96.py" target="_blank" rel="external">二叉树的序列化和反序列化</a></h2><h3 id="题目描述-63"><a href="#题目描述-63" class="headerlink" title="题目描述"></a>题目描述</h3><p>请实现两个函数，分别用来序列化和反序列化二叉树。这里没有规定序列化的方式。</p>
<h3 id="最优题解-63"><a href="#最优题解-63" class="headerlink" title="最优题解"></a>最优题解</h3><p>序列化可以采用多种遍历方式，本来可以仿照第6题序列化成前序+中序或后序+中序，<br>但这要求结点值不能重复，所以不能使用双遍历的方式。采用单遍历就允许结点值重复，<br>可是单次遍历是无法确定一个二叉树的，所以可以<strong>在遍历到None时也加入遍历序列中</strong>。<br>这里的序列化字符串用‘#’表示None,为了防止12，3以及1，23产生歧义而分不清，使用逗号将每个结点的值分开。</p>
<h3 id="代码-63"><a href="#代码-63" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></div><div class="line">        self.val = x</div><div class="line">        self.left = <span class="keyword">None</span></div><div class="line">        self.right = <span class="keyword">None</span></div><div class="line">		</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Serialize</span><span class="params">(self, root)</span>:</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="string">'#'</span></div><div class="line">        level, s = [root], <span class="string">''</span></div><div class="line">        <span class="keyword">while</span> level:</div><div class="line">            next_level = []</div><div class="line">            <span class="keyword">for</span> cur <span class="keyword">in</span> level:</div><div class="line">                <span class="keyword">if</span> <span class="keyword">not</span> cur:</div><div class="line">                    s += <span class="string">'#,'</span></div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    s += str(cur.val) + <span class="string">','</span></div><div class="line">                <span class="keyword">if</span> cur: </div><div class="line">                    next_level.append(cur.left)</div><div class="line">                    next_level.append(cur.right)</div><div class="line">            level = next_level</div><div class="line">        <span class="keyword">return</span> s[:<span class="number">-1</span>]</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Deserialize</span><span class="params">(self, s)</span>:</span></div><div class="line">        s = s.split(<span class="string">','</span>)</div><div class="line">        <span class="keyword">if</span> s[<span class="number">0</span>] == <span class="string">'#'</span>: <span class="keyword">return</span></div><div class="line">        root = TreeNode(int(s[<span class="number">0</span>]))</div><div class="line">        queue = [root]</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s))[<span class="number">1</span>::<span class="number">2</span>]:</div><div class="line">            cur = queue.pop(<span class="number">0</span>)</div><div class="line">            <span class="keyword">if</span> s[i] != <span class="string">'#'</span>:</div><div class="line">                left = TreeNode(int(s[i]))</div><div class="line">                cur.left = left</div><div class="line">                queue.append(left)</div><div class="line">            <span class="keyword">if</span> s[i + <span class="number">1</span>] != <span class="string">'#'</span>:</div><div class="line">                right = TreeNode(int(s[i + <span class="number">1</span>]))</div><div class="line">                cur.right = right</div><div class="line">                queue.append(right)</div><div class="line">        <span class="keyword">return</span> root</div></pre></td></tr></table></figure>
<h2 id="二叉搜索树中的第k个结点"><a href="#二叉搜索树中的第k个结点" class="headerlink" title="二叉搜索树中的第k个结点"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/63_%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9.py" target="_blank" rel="external">二叉搜索树中的第k个结点</a></h2><h3 id="题目描述-64"><a href="#题目描述-64" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一棵二叉搜索树，请找出其中的第k大的结点。例如，</p>
<p><img src="http://ox186n2j0.bkt.clouddn.com/1532023500895.jpg" alt="二叉搜索树"></p>
<p>按结点数值大小顺序第三个结点的值为4。</p>
<h3 id="最优题解-64"><a href="#最优题解-64" class="headerlink" title="最优题解"></a>最优题解</h3><p>二叉搜索树的中序遍历序列是递增排序的，所以中序遍历二叉树，递归实现，找到就返回</p>
<h3 id="代码-64"><a href="#代码-64" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></div><div class="line">        self.val = x</div><div class="line">        self.left = <span class="keyword">None</span></div><div class="line">        self.right = <span class="keyword">None</span></div><div class="line">		</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="comment"># 返回对应节点TreeNode</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.k = <span class="number">0</span></div><div class="line">        </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">KthNode</span><span class="params">(self, pRoot, k)</span>:</span></div><div class="line">        <span class="comment"># write code here</span></div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">inorder</span><span class="params">(root)</span>:</span></div><div class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></div><div class="line">            res = inorder(root.left)</div><div class="line">            <span class="keyword">if</span> res: <span class="keyword">return</span> res</div><div class="line">            self.k -= <span class="number">1</span></div><div class="line">            <span class="keyword">if</span> self.k == <span class="number">0</span>:</div><div class="line">                <span class="keyword">return</span> root</div><div class="line">            <span class="keyword">return</span> inorder(root.right)</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot: <span class="keyword">return</span></div><div class="line">        self.k = k</div><div class="line">        <span class="keyword">return</span> inorder(pRoot)</div></pre></td></tr></table></figure>
<h2 id="数据流的中位数"><a href="#数据流的中位数" class="headerlink" title="数据流的中位数"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/64_%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0.py" target="_blank" rel="external">数据流的中位数</a></h2><h3 id="题目描述-65"><a href="#题目描述-65" class="headerlink" title="题目描述"></a>题目描述</h3><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。<br>如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p>
<h3 id="最优题解-65"><a href="#最优题解-65" class="headerlink" title="最优题解"></a>最优题解</h3><p>构建大根堆和小根堆，则插入O(logn)，取中位数O(1)<br>如果用一个数组存储所有到来数据，然后在取中位数时排序返回，则插入O(1)，取中位数O(nlogn)<br>由此可见，动态构建大根堆和小根堆相当于把排序时间平分到每次插入操作中，这样在获取中位数时可以O(1)<br>有两个条件要满足：<br>1、保证数据平均分配到两个堆中，即两个堆中数据的数目之差不能超过1；<br>2、保证大根堆里所有数据都要小于小根堆中的数据</p>
<p>当数据总数为奇数时，新加入的元素，应当进入大根堆，<br>注意不是直接进入大根堆，而是经小根堆筛选后取小根堆中最大元素进入大根堆；<br>当数据总数为偶数时，新加入的元素，应当进入小根堆，<br>注意不是直接进入小根堆，而是经大根堆筛选后取大根堆中最大元素进入小根堆<br>取数时若总数个数为奇数则直接取大堆堆顶，偶数时取两堆堆顶平均值</p>
<p>这里构建堆用heapq，其构建的都是小根堆（优先队列），所以为了构建大根堆需要在存数取数时加上负号</p>
<h3 id="代码-65"><a href="#代码-65" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.count = <span class="number">0</span></div><div class="line">        self.maxheap = []</div><div class="line">        self.minheap = []</div><div class="line">        </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Insert</span><span class="params">(self, num)</span>:</span></div><div class="line">        <span class="keyword">import</span> heapq</div><div class="line">        self.count += <span class="number">1</span></div><div class="line">        <span class="keyword">if</span> self.count &amp; <span class="number">1</span>: <span class="comment"># 奇数时，新加入的元素应当进入大根堆</span></div><div class="line">            heapq.heappush(self.maxheap, -heapq.heappushpop(self.minheap, num))</div><div class="line">        <span class="keyword">else</span>: <span class="comment"># 偶数时，新加入的元素应当进入小根堆</span></div><div class="line">            heapq.heappush(self.minheap, -heapq.heappushpop(self.maxheap, -num))</div><div class="line">        </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetMedian</span><span class="params">(self, fuck)</span>:</span></div><div class="line">        <span class="keyword">return</span> -self.maxheap[<span class="number">0</span>] <span class="keyword">if</span> self.count &amp; <span class="number">1</span> <span class="keyword">else</span> (-self.maxheap[<span class="number">0</span>] + self.minheap[<span class="number">0</span>]) / <span class="number">2.0</span></div></pre></td></tr></table></figure>
<h2 id="滑动窗口的最大值"><a href="#滑动窗口的最大值" class="headerlink" title="滑动窗口的最大值"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/65_1_%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC.py" target="_blank" rel="external">滑动窗口的最大值</a></h2><h3 id="题目描述-66"><a href="#题目描述-66" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个数组和滑动窗口的大小k，找出所有滑动窗口里数值的最大值。<br>例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，<br>他们的最大值分别为{4,4,6,6,6,5}；<br>针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个：<br>{[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}，<br>{2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。</p>
<h3 id="最优题解-66"><a href="#最优题解-66" class="headerlink" title="最优题解"></a>最优题解</h3><p>时间复杂度O（n），空间复杂度O（n）</p>
<p>用一个双端队列，其中保存当前可能为最大值的数的下标，每当窗口滑动一次<br>1.新增加的值从队尾开始比较，把前面所有比他小的值从队尾取出，直到遇到比它大的数就停止：<br>  因为这些数已经不再可能成为后面滑动窗口的最大值了，有种‘长江后浪推前浪’的感觉，<br>  新来的数会淘汰掉前面比它小的数，而如果前面的数比它大则自己没有资格淘汰前面的数，<br>  更别说更前面的数。但该数还是有‘潜质’成为最大数的，因为可能由于前面的数被滑动窗口<br>  的移动而强行淘汰使得自己成为最大数，所以会进入队尾等待‘考核’。</p>
<p>2.判断当前最大值是否过期，过期则从队首取出：<br>  当一个数字的下标与当前正在处理的数字的下标之差大于等于滑动窗口大小时，<br>  该最大值过期，即已经从窗口中滑出，需要从队首删除。滑动窗口总是要往右移的，<br>  再大的数也会被淘汰。<br>每次通过以上两步操作使得队列第一个位置为当前窗口的最大值</p>
<h3 id="代码-66"><a href="#代码-66" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxInWindows</span><span class="params">(self, num, size)</span>:</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> num <span class="keyword">or</span> <span class="keyword">not</span> size: <span class="keyword">return</span> []</div><div class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> deque</div><div class="line">        queue, res = deque([]), []</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(num)):</div><div class="line">            <span class="keyword">while</span> queue <span class="keyword">and</span> num[queue[<span class="number">-1</span>]] &lt;= num[i]:</div><div class="line">                queue.pop()</div><div class="line">            <span class="keyword">if</span> queue <span class="keyword">and</span> i - queue[<span class="number">0</span>] &gt;= size:</div><div class="line">                queue.popleft()</div><div class="line">            queue.append(i)</div><div class="line">            <span class="keyword">if</span> i &gt;= size - <span class="number">1</span>:</div><div class="line">                res.append(num[queue[<span class="number">0</span>]])</div><div class="line">        <span class="keyword">return</span> res</div></pre></td></tr></table></figure>
<h2 id="矩阵中的路径"><a href="#矩阵中的路径" class="headerlink" title="矩阵中的路径"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/66_%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84.py" target="_blank" rel="external">矩阵中的路径</a></h2><h3 id="题目描述-67"><a href="#题目描述-67" class="headerlink" title="题目描述"></a>题目描述</h3><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。<br>路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。<br>如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。<br>例如<br>[[a b c e],<br>[s f c s],<br>[a d e e]]<br>矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，<br>因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。</p>
<h3 id="最优题解-67"><a href="#最优题解-67" class="headerlink" title="最优题解"></a>最优题解</h3><p>回溯法，用一个状态数组保存之前访问过的字符位置，然后再分别按上，下，左，右分别递归</p>
<h3 id="代码-67"><a href="#代码-67" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasPath</span><span class="params">(self, matrix, rows, cols, path)</span>:</span></div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">hasPathCore</span><span class="params">(row, col, pathLength, visited)</span>:</span></div><div class="line">            <span class="keyword">if</span> len(path) == pathLength:  <span class="comment"># 来到末尾，成功找到路径</span></div><div class="line">                <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">            hasPath = <span class="keyword">False</span></div><div class="line">            <span class="keyword">if</span> <span class="number">0</span> &lt;= row &lt; rows <span class="keyword">and</span> <span class="number">0</span> &lt;= col &lt; cols \</div><div class="line">                    <span class="keyword">and</span> matrix[row * cols + col] == path[pathLength] \</div><div class="line">                    <span class="keyword">and</span> <span class="keyword">not</span> visited[row * cols + col]:</div><div class="line">                pathLength += <span class="number">1</span></div><div class="line">                visited[row * cols + col] = <span class="keyword">True</span></div><div class="line">                hasPath = hasPathCore(row, col - <span class="number">1</span>, pathLength, visited) <span class="keyword">or</span> \</div><div class="line">                          hasPathCore(row - <span class="number">1</span>, col, pathLength, visited) <span class="keyword">or</span> \</div><div class="line">                          hasPathCore(row, col + <span class="number">1</span>, pathLength, visited) <span class="keyword">or</span> \</div><div class="line">                          hasPathCore(row + <span class="number">1</span>, col, pathLength, visited)</div><div class="line">                <span class="keyword">if</span> <span class="keyword">not</span> hasPath:  <span class="comment"># 上下左右都没找到路径，则回退</span></div><div class="line">                    pathLength -= <span class="number">1</span></div><div class="line">                    visited[row * cols + col] = <span class="keyword">False</span></div><div class="line">            <span class="keyword">return</span> hasPath</div></pre></td></tr></table></figure>
<h2 id="机器人的运动范围"><a href="#机器人的运动范围" class="headerlink" title="机器人的运动范围"></a><a href="https://github.com/Hk4Fun/algorithm_offer/blob/master/target_offer/67_%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4.py" target="_blank" rel="external">机器人的运动范围</a></h2><h3 id="题目描述-68"><a href="#题目描述-68" class="headerlink" title="题目描述"></a>题目描述</h3><p>地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，<br>每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。<br>例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。<br>但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</p>
<h3 id="最优题解-68"><a href="#最优题解-68" class="headerlink" title="最优题解"></a>最优题解</h3><p>回溯法。<br>       1.从(0,0)开始走，先判断四个方向是否满足条件，满足就把相应位置标记为True，<br>       再递归，最终统计有几处标记为True<br>       2.判断当前节点是否可达的标准为：<br>       1）当前节点在矩阵内；<br>       2）当前节点未被访问过；<br>       3）当前节点满足题目要求。<br>       注意，这里不是寻找路径，而是类似于扫雷，<br>       走过的地方发现满足条件就算作能够到达，走不下去了也不必回退<br>       注意这里若去遍历所有位置看是否满足条件是不行的，因为有可能出现单个‘孤岛’或者是连在一起的‘孤岛’，<br>       即这些位置虽然满足条件，但四周并不满足条件，这样机器人是无法到达这些位置的</p>
<h3 id="代码-68"><a href="#代码-68" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">movingCount1</span><span class="params">(self, threshold, rows, cols)</span>:</span></div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">canReach</span><span class="params">(row, col)</span>:</span></div><div class="line">            sum = <span class="number">0</span></div><div class="line">            <span class="keyword">while</span> row <span class="keyword">or</span> col:</div><div class="line">                sum += row % <span class="number">10</span> + col % <span class="number">10</span></div><div class="line">                row //= <span class="number">10</span></div><div class="line">                col //= <span class="number">10</span></div><div class="line">            <span class="keyword">return</span> sum &lt;= threshold</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">movingCountCore</span><span class="params">(row, col, visited)</span>:</span></div><div class="line">            <span class="keyword">for</span> i, j <span class="keyword">in</span> [(row, col - <span class="number">1</span>), (row, col + <span class="number">1</span>), (row - <span class="number">1</span>, col), (row + <span class="number">1</span>, col)]:</div><div class="line">                <span class="keyword">if</span> <span class="number">0</span> &lt;= i &lt; rows <span class="keyword">and</span> <span class="number">0</span> &lt;= j &lt; cols \</div><div class="line">                        <span class="keyword">and</span> canReach(i, j) \</div><div class="line">                        <span class="keyword">and</span> <span class="keyword">not</span> visited[i * cols + j]:  <span class="comment"># 先判断四个方向是否满足条件</span></div><div class="line">                    visited[i * cols + j] = <span class="keyword">True</span></div><div class="line">                    movingCountCore(i, j, visited)</div><div class="line">					</div><div class="line">        <span class="keyword">if</span> threshold == <span class="keyword">None</span> <span class="keyword">or</span> threshold &lt; <span class="number">0</span> <span class="keyword">or</span> <span class="keyword">not</span> cols <span class="keyword">or</span> <span class="keyword">not</span> rows:</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span></div><div class="line">        visited = [<span class="keyword">False</span>] * (rows * cols)</div><div class="line">        visited[<span class="number">0</span>] = <span class="keyword">True</span></div><div class="line">        movingCountCore(<span class="number">0</span>, <span class="number">0</span>, visited)  <span class="comment"># 从（0，0）开始移动</span></div><div class="line">        <span class="keyword">return</span> sum(visited)</div></pre></td></tr></table></figure>
<p>## </p>
<h3 id="题目描述-69"><a href="#题目描述-69" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="最优题解-69"><a href="#最优题解-69" class="headerlink" title="最优题解"></a>最优题解</h3><h3 id="代码-69"><a href="#代码-69" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure>
<p>##</p>
<h3 id="题目描述-70"><a href="#题目描述-70" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="最优题解-70"><a href="#最优题解-70" class="headerlink" title="最优题解"></a>最优题解</h3><h3 id="代码-70"><a href="#代码-70" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> 剑指offer </tag>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[廖雪峰web实战总结]]></title>
      <url>/2017/10/09/%E5%BB%96%E9%9B%AA%E5%B3%B0web%E5%AE%9E%E6%88%98%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>敲完<a href="https://github.com/Hk4Fun/awesome-python3-webapp" target="_blank" rel="external">代码</a>却一直没写个总结，因为感觉火候不到，学了一段时间的Django后回来重温，更是感觉廖大大的<a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001432170937506ecfb2f6adf8e4757939732f3e32b781c000" target="_blank" rel="external">这个web实战</a>很是经典，借鉴了不少的框架设计思想：<code>orm（modle）、router（urls）、mvc（mvt）、handlers（views）</code>等</p>
<a id="more"></a>
<h2 id="主要模块"><a href="#主要模块" class="headerlink" title="主要模块"></a>主要模块</h2><h3 id="orm-py"><a href="#orm-py" class="headerlink" title="orm.py"></a>orm.py</h3><p>建立类与数据库表的映射，对数据库进行封装。<br>把表映射成类，把行（记录）映射为实例，把字段映射为实例的属性，而每个字段实际上是每个 <code>Field</code> 的实例，这也就定义了字段的类型。<br>因为数据库中每张表的字段都不一样，所以我们需要动态的生成类，此时元类派上用场，这里推荐<a href="https://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python" target="_blank" rel="external">StackOverflow上的一个高票回答</a>帮助理解元类。<br>为什么要辛辛苦苦地建立orm而不直接连接数据库操作呢？我的理解有以下几点：</p>
<ol>
<li>安全：避免SQL语句的拼接，参数化的SQL语句可以有效防止SQL注入</li>
<li>封装：对不懂SQL语句的程序员可直接使用orm提供的函数操作数据库，而不用专门去学习SQL语句，可应对多种数据库，无非就是 <code>migrate</code> 一下，无需关心底层的SQL语句是如何生成的</li>
<li>插件化：从django的setting可以看出，更换数据库只需更换orm引擎，而不用更改任何的代码</li>
<li>分层：从2、3可以看出，所以还是那句话：计算机领域没有什么问题是不能靠分层解决的</li>
</ol>
<h3 id="models-py"><a href="#models-py" class="headerlink" title="models.py"></a>models.py</h3><p>建立数据模型。<br>与django的 <code>models.py</code> 功能一样，实现数据库的建模，也就是定义表的内容和结构。<br>由于上面的orm实现的不是很完善，我们还是需要自己收到那个在数据库中建立这张表的（借助 <code>schema.sql</code> 实现），而在django中只需migrate（迁移）一下就可以了。<br>这里我们定义了三张表： <code>User</code> 、<code>Blog</code> 、<code>Comment</code>，具体都有哪些字段及其类型看代码就清楚了</p>
<h3 id="webframe-py"><a href="#webframe-py" class="headerlink" title="webframe.py"></a>webframe.py</h3><p>框架的核心模块。<br>在web开发中想要让时间和精力更多放在业务逻辑函数的设计上，编写更少的代码从而提高开发效率，就只能在底层框架上封装一个更高级的框架。<br>Django干的就是这件事，而本框架主要基于 <code>aiohttp</code> 异步web框架进行再次封装，主要是从URL函数中解析需要接收的参数，进而从request中获取必要的参数构造成字典以 <code>**kw</code> 传给该URL函数并调用，然后对url和静态资源进行了映射（借鉴了flask的router装饰器，即注册url函数。<br>关于装饰器的理解，还是<a href="https://stackoverflow.com/questions/739654/how-to-make-a-chain-of-function-decorators/1594484#1594484" target="_blank" rel="external">一个StackOverflow的高票回答</a>），在app.py的初始化函数init()中被调用</p>
<h3 id="handlers-py"><a href="#handlers-py" class="headerlink" title="handlers.py"></a>handlers.py</h3><p>编写业务逻辑函数的模块。<br>所有处理业务逻辑的函数都在这里编写，也就是说需求改动时只需改动该模块即可（当然，要修改数据模型还得到 <code>modles.py</code> 中）。<br>但该模块还是有不足之处：参考django的设计，应该把该模块按照功能进行分割，一个功能一个app，便于维护和复用，因为到后面需求越来越复杂，全部堆在一个模块肯定乱手脚（我在代码中用注释分隔开了。。。）</p>
<h3 id="app-py"><a href="#app-py" class="headerlink" title="app.py"></a>app.py</h3><p>整个web app的起点和终点。<br>实现的各个中间件（ <code>middlewares</code> , 拦截器）在请求到来时进行拦截，主要是打印相关日志信息和身份验证，而在应答数据返回时进行拦截，主要是进行模板的渲染和其他数据流类型的相关处理。<br>在 <code>init()</code> 中完成所有的初始化：连接数据库、加载中间件和jinja2模板、注册url路由、添加静态资源、异步监听请求等。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>从上面介绍的各个功能模块来看，该web框架借鉴了django和flask等知名web开发框架的设计思想，MVC的实现无处不在，对理解web开发框架的实现有参考价值。</p>
<p>其他模块非主要模块，主要是进行设置的读取和markdown语法的转换以及各种异常请求的处理，这里不再详细介绍。想了解以上各个模块更多的实现细节请直接阅读代码吧，毕竟 “<strong>Talk is cheap, show me the code</strong>”，我几乎对每一行进行了注释以及相关知识的补充，非常适合小白学习。</p>
<h2 id="数据流向"><a href="#数据流向" class="headerlink" title="数据流向"></a>数据流向</h2><p>当收到一个http请求时，首先会被 <code>logger_factory</code> （输出请求的信息）、 <code>data_factory</code> （打印post提交的数据）、 <code>auth_factory</code> （cookie解析）这三个中间件拦截。<br>然后才根据请求的url被映射到到<code>handlers.py</code>中的各个相应的url函数进行处理。<br>而在执行这些url函数之前，会被 <code>RequestHandle</code> 先处理（hook），主要是从url函数中解析需要接收的参数，进而从request中获取必要的参数构造成字典以 <code>**kw</code> 传给该url函数并调用。<br>最后在应答返回数据前会被response_factory所拦截，进行模板的渲染，将 <code>request handler</code> 的返回值根据返回的类型转换为 <code>web.Response</code> 对象，吻合aiohttp框架的需求</p>
<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><ul>
<li><strong>框架</strong>：其实上面已经提到了，比如 <code>handlers.py</code> 的臃肿、orm框架的不完善等。</li>
<li><strong>功能</strong>：很多博客的小功能还未实现，如分享、标签、统计等等</li>
<li><strong>前端</strong>：前端使用的uikit这个css框架界面不是很友好，而自己的前端知识又不足，恶补了前端知识后发现前端也是个大坑，考虑使用bootstrap</li>
<li><strong>数据库</strong>：可以学习一下hexo的文章管理，它是不需要存储在数据库的，如果发表的文章比较长，放在数据库很不方便，单独形成一个md文件然后打开读取渲染岂不是更加灵活，也就是说我们可以在blog.body存放该文章的路径即可</li>
</ul>
<h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><ul>
<li>廖雪峰大神的<a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000" target="_blank" rel="external">python教程</a>、<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">git教程</a>、<a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000" target="_blank" rel="external">javascript教程</a>（才发现原来廖大大是我北邮学长。。。）</li>
<li>几位前辈优秀的代码注释和补充：<a href="https://github.com/xwlyy/awesome-python3-webapp" target="_blank" rel="external">xwlyy</a>、<a href="https://github.com/KaimingWan/PureBlog" target="_blank" rel="external">KaimingWan</a>、<a href="https://github.com/zhouxinkai/awesome-python3-webapp" target="_blank" rel="external">zhouxinkai</a>、<a href="https://github.com/Engine-Treasure/awesome-python3-webapp" target="_blank" rel="external">Engine-Treasure</a>、<a href="https://github.com/ReedSun/Preeminent" target="_blank" rel="external">Preeminent</a></li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://jinja.pocoo.org/docs/2.9/" target="_blank" rel="external">Jinja2官方文档</a></li>
<li><a href="https://docs.python.org/3/library/asyncio.html" target="_blank" rel="external">asyncio官方文档</a></li>
<li><a href="http://aiohttp.readthedocs.io/en/stable/web.html" target="_blank" rel="external">aiohttp官方文档</a></li>
<li><a href="http://aiomysql.readthedocs.io/en/latest/index.html" target="_blank" rel="external">aiomysql官方文档</a></li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> python </tag>
            
            <tag> orm </tag>
            
            <tag> mvc </tag>
            
            <tag> django </tag>
            
            <tag> web </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[DO VPS搭建SS并使用ServerSpeeder加速]]></title>
      <url>/2017/09/27/DO-VPS%E6%90%AD%E5%BB%BASS%E5%B9%B6%E4%BD%BF%E7%94%A8ServerSpeeder%E5%8A%A0%E9%80%9F/</url>
      <content type="html"><![CDATA[<p><strong>10$</strong> 的 <a href="&#39;https://m.do.co/c/ba18ef5fa022&#39;"><strong>邀请码</strong></a> 和 <a href="&quot;https://education.github.com/pack&quot;"><strong>github student pack</strong></a> 赠送的 <strong>50$</strong> 优惠券让我入了DO VPS的坑。想着就借此搭个SS也不错，才发现新加坡节点比旧金山稳定多了，然后开始各种折腾。do家的vps采用kvm架构且支持ipv6，可以在校外通过它连接byrbt，校内通过ipv6实现免流，且流量可以说是不限的。<br><a id="more"></a></p>
<h2 id="配置SSH"><a href="#配置SSH" class="headerlink" title="配置SSH"></a>配置SSH</h2><p>如何生成密钥对？<br><a href="https://www.digitalocean.com/community/tutorials/how-to-use-ssh-keys-with-digitalocean-droplets" title="https://www.digitalocean.com/community/tutorials/how-to-use-ssh-keys-with-digitalocean-droplets" target="_blank" rel="external">Linux/MAC</a>      <strong>/</strong>  <a href="https://www.digitalocean.com/community/tutorials/how-to-use-ssh-keys-with-putty-on-digitalocean-droplets-windows-users" title="https://www.digitalocean.com/community/tutorials/how-to-use-ssh-keys-with-putty-on-digitalocean-droplets-windows-users" target="_blank" rel="external">Windows</a></p>
<p>如果使用了密钥对，就可以不用每次登陆都输入密码。</p>
<p>如果不用DO的sshkey上传，自己在客户端生成密钥对后，将公钥id_rsa.pub写进服务端的<code>/root/.ssh/authorized_keys</code>，然后到服务端<code>/etc/ssh/sshd_config</code>修改ssh配置： <strong>将”PasswordAuthentication yes”修改为”PasswordAuthentication no”</strong></p>
<p>这样就可以不用每次登陆都输入密码，当然如果还是yes的话就可以在没有密钥对时通过密码登录。</p>
<p>私钥保存在本地客户端就行了（windows下为.ppk文件，Linux下就是id_rsa）</p>
<p>如果有多台终端设备，则在设备上生成密钥对后把公钥加在服务端的<code>/root/.ssh/authorized_keys</code>后面</p>
<p>SSH其他常用配置选项：</p>
<ul>
<li>服务端<code>/etc/ssh/sshd_config</code>：</li>
</ul>
<p><strong>Port 22</strong><br>定义了SSH服务监听的断口号，SSH服务默认使用的端口号是22</p>
<p><strong>Proctocol 2,1</strong><br>定义了SSH服务器使用SSH协议的顺序。默认识先使用SSH2协议，如果不成功则使用SSH1协议，为了安全起见，可以设置只使用SSH2协议。</p>
<p><strong>ListenAddress 0.0.0.0</strong><br>定义SSH服务器帮定的IP地址,默认绑定服务器所有可用的IP地址.</p>
<p><strong>PermitRootLogin yes</strong><br>定义是否允许管理员登陆</p>
<p><strong>PermitEmptyPasswords no</strong><br>定义是否允许空密码登陆.</p>
<p><strong>PasswordAuthentication no</strong><br>定义是否使用口令认证方式,如果准备使用公钥认证可以设置为no</p>
<p><strong>AuthorizedKeysFile .ssh/authorized_keys</strong><br>定义默认公钥文件路径</p>
<p>详细见官方文档<a href="https://man.openbsd.org/sshd_config" target="_blank" rel="external">https://man.openbsd.org/sshd_config</a></p>
<ul>
<li>客户端<code>/etc/ssh/ssh_config</code>:</li>
</ul>
<p>详细见官方文档<a href="https://man.openbsd.org/ssh_config" target="_blank" rel="external">https://man.openbsd.org/ssh_config</a></p>
<h2 id="配置ServerSpeeder"><a href="#配置ServerSpeeder" class="headerlink" title="配置ServerSpeeder"></a>配置ServerSpeeder</h2><p>先安装serverspeeder（锐速），因为锐速对支持的Linux发行版本和内核版本都有要求，安装过程中可能会让更换内核并重启，目前锐速ServerSpeeder无限带宽破解版支持的内核有：</p>
<ul>
<li>CentOS-6.8：2.6.32-642.el7.x86_64</li>
<li>CentOS-7.2：3.10.0-327.el7.x86_64</li>
<li>CentOS：4.4.0-x86_64-linode63</li>
<li>Ubuntu_14.04：4.2.0-35-generic</li>
<li>Debian_8：3.16.0-4-amd64</li>
</ul>
<p>而DO官网提供的镜像都不符合，因此还是要更换内核（我在官网选择的版本为centos 7.3.1611 x64）：</p>
<p>1、首先下载并更换内核：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">rpm -ivh http:<span class="regexp">//</span>xz.wn789.com<span class="regexp">/CentOSkernel/</span>kernel-<span class="number">3.10</span>.<span class="number">0</span>-<span class="number">229.1</span>.<span class="number">2</span>.el7.x86_64.rpm --force</div><div class="line">rpm -qa | grep kernel <span class="comment">#查看内核是否安装成功</span></div></pre></td></tr></table></figure>
<p>2、重启VPS，查看内核是否修改成功：<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">reboot</span> <span class="comment">#重启VPS</span></div><div class="line">uname -r <span class="comment">#当前使用内核版本</span></div></pre></td></tr></table></figure></p>
<p><img src="http://ox186n2j0.bkt.clouddn.com/1506760764914.jpg" alt=""></p>
<p>3、下载脚本到服务器，然后再执行脚本安装：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">wget -<span class="keyword">N</span> --<span class="keyword">no</span>-check-certificate http<span class="variable">s:</span>//raw.githubusercontent.<span class="keyword">com</span>/wn789/serverspeeder/master/serverspeeder.<span class="keyword">sh</span></div><div class="line">bash serverspeeder.<span class="keyword">sh</span></div></pre></td></tr></table></figure></p>
<p>4、安装过程很简单，如果你的VPS内核支持安装，根本无需你手动操作，直接一键完成</p>
<p>5、锐速serverspeeder常用命令：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">service serverSpeeder start #启动</div><div class="line">service serverSpeeder stop #停止</div><div class="line">service serverSpeeder reload #重新加载配置</div><div class="line">service serverSpeeder restart #重启</div><div class="line">service serverSpeeder status #状态</div><div class="line">service serverSpeeder stats #统计</div><div class="line">service serverSpeeder renewLic #更新许可文件</div><div class="line">service serverSpeeder update #更新</div><div class="line">chattr -i /serverspeeder/etc/apx* &amp;&amp; /serverspeeder/bin/serverSpeeder.sh uninstall -f #卸载</div></pre></td></tr></table></figure></p>
<h2 id="配置Shadowsocks"><a href="#配置Shadowsocks" class="headerlink" title="配置Shadowsocks"></a>配置Shadowsocks</h2><p>使用 <a href="https://teddysun.com/342.html" target="_blank" rel="external"><strong>一键安装 Python 版 Shadowsocks</strong></a> 安装</p>
<p>安装方法：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">wget --<span class="keyword">no</span>-check-certificate -O shadowsocks.<span class="keyword">sh</span> http<span class="variable">s:</span>//raw.githubusercontent.<span class="keyword">com</span>/teddysun/shadowsocks_install/master/shadowsocks.<span class="keyword">sh</span></div><div class="line">chmod +<span class="keyword">x</span> shadowsocks.<span class="keyword">sh</span></div><div class="line">./shadowsocks.<span class="keyword">sh</span> <span class="number">2</span>&gt;&amp;<span class="number">1</span> | tee shadowsocks.<span class="built_in">log</span></div></pre></td></tr></table></figure></p>
<p>配置：</p>
<p>服务器地址：vps主机公网ip</p>
<p>服务器端口：如不设定，默认为 8989</p>
<p>密码：如不设定，默认为 teddysun.com）</p>
<p>加密方式：<strong>aes-256-cfb</strong>（如不设定，默认为 aes-256-gcm）</p>
<p>安装完成后，脚本提示如下：</p>
<p><img src="http://ox186n2j0.bkt.clouddn.com/1506760763636.jpg" alt=""></p>
<p>卸载方法：</p>
<p>./shadowsocks.sh uninstall</p>
<p>单用户配置文件示例：<br>配置文件路径：/etc/shadowsocks.json<br><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line"><span class="attr">"server"</span>:<span class="string">"0.0.0.0"</span>,</div><div class="line"><span class="attr">"server_port"</span>:your_server_port,</div><div class="line"><span class="attr">"local_address"</span>:<span class="string">"127.0.0.1"</span>,</div><div class="line"><span class="attr">"local_port"</span>:<span class="number">1080</span>,</div><div class="line"><span class="attr">"password"</span>:<span class="string">"your_password"</span>,</div><div class="line"><span class="attr">"timeout"</span>:<span class="number">300</span>,</div><div class="line"><span class="attr">"method"</span>:<span class="string">"your_encryption_method"</span>,</div><div class="line"><span class="attr">"fast_open"</span>: <span class="literal">false</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>多用户多端口配置文件示例：<br>配置文件路径：/etc/shadowsocks.json<br><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line"><span class="attr">"server"</span>:<span class="string">"0.0.0.0"</span>,</div><div class="line"><span class="attr">"local_address"</span>:<span class="string">"127.0.0.1"</span>,</div><div class="line"><span class="attr">"local_port"</span>:<span class="number">1080</span>,</div><div class="line"><span class="attr">"port_password"</span>:&#123;</div><div class="line"> 	<span class="attr">"8989"</span>:<span class="string">"password0"</span>,</div><div class="line"> 	<span class="attr">"9001"</span>:<span class="string">"password1"</span>,</div><div class="line"> 	<span class="attr">"9002"</span>:<span class="string">"password2"</span>,</div><div class="line"> 	<span class="attr">"9003"</span>:<span class="string">"password3"</span>,</div><div class="line"> 	<span class="attr">"9004"</span>:<span class="string">"password4"</span></div><div class="line">&#125;,</div><div class="line"><span class="attr">"timeout"</span>:<span class="number">300</span>,</div><div class="line"><span class="attr">"method"</span>:<span class="string">"your_encryption_method"</span>,</div><div class="line"><span class="attr">"fast_open"</span>: <span class="literal">false</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>常用命令：<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">启动：<span class="meta-keyword">/etc/</span>init.d/shadowsocks start</div><div class="line">停止：<span class="meta-keyword">/etc/</span>init.d/shadowsocks stop</div><div class="line">重启：<span class="meta-keyword">/etc/</span>init.d/shadowsocks restart</div><div class="line">状态：<span class="meta-keyword">/etc/</span>init.d/shadowsocks status</div></pre></td></tr></table></figure></p>
<p><a href="https://github.com/shadowsocks/shadowsocks-windows/releases" target="_blank" rel="external">Shadowsocks for Windows 客户端下载</a></p>
<p><a href="https://github.com/shadowsocks/shadowsocks-android/releases" target="_blank" rel="external">Shadowsocks for Android 客户端下载</a></p>
<p>客户端配置太简单，懒，直接上图：</p>
<p><img src="http://ox186n2j0.bkt.clouddn.com/1506760765315.jpg" alt=""></p>
<p>最后可以到油管搜索4K视频测试</p>
<hr>
<h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><ol>
<li><a href="https://teddysun.com/342.html" target="_blank" rel="external"><strong><em>Shadowsocks Python版一键安装脚本</em></strong> by <strong><em>秋水逸冰</em></strong></a></li>
<li><a href="http://www.openssh.com/manual.html" target="_blank" rel="external"><strong><em>OpenSSH Manual Pages</em></strong></a></li>
<li><a href="https://www.digitalocean.com/community/tutorials/how-to-use-ssh-keys-with-putty-on-digitalocean-droplets-windows-users" target="_blank" rel="external"><strong><em>How To Use SSH Keys with PuTTY on DigitalOcean Droplets (Windows users)</em></strong></a></li>
</ol>
]]></content>
      
        
        <tags>
            
            <tag> VPS </tag>
            
            <tag> 翻墙 </tag>
            
            <tag> SSH </tag>
            
            <tag> ServerSpeeder </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
